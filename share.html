<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>åˆ†é•œå¼ç¼–è¾‘å™¨</title>
    <style>:root { --bg: #0f0f0f; --grid: #333; --node: #1e1e1e; --accent: #007acc; --text: #d4d4d4; }
* { box-sizing: border-box; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--bg); color: var(--text); font-family: 'Consolas', monospace; overflow: hidden; }

header { position: absolute; background: rgba(37, 37, 38, 0.9); backdrop-filter: blur(10px); display: flex; align-items: center; padding: 0 15px; z-index: 1000; justify-content: space-between; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; margin: 10px; }
.nav-left { display: flex; gap: 10px; }
.btn { background: #333; border: 1px solid #444; color: #fff; padding: 5px 15px; cursor: pointer; border-radius: 4px; font-size: 13px; transition: 0.2s; }
.btn:hover { border-color: var(--accent); }
/* æŒ‰é’®é¢œè‰²ç±» */
.btn-green { background: hsl(120, 100%, 30%); }
.btn-green:hover { background: hsl(120, 100%, 60%); }
.btn-yellow { background: hsl(40, 100%, 30%); }
.btn-yellow:hover { background: hsl(40, 100%, 60%); }
.btn-red { background: hsl(0, 100%, 30%); }
.btn-red:hover { background: hsl(0, 100%, 60%); }
.btn-blue { background: hsl(210, 100%, 30%); }
.btn-blue:hover { background: hsl(210, 100%, 60%); }
.btn-purple { background: hsl(50, 100%, 30%); }
.btn-purple:hover { background: hsl(50, 100%, 60%); }
.btn-help { border: none; width: 28px; height: 28px; border-radius: 50%; color: white; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; }
.btn-help:not([class*="btn-"]) { background: var(--accent); }

#viewport { width: 100vw; height: 100vh; overflow: hidden; cursor: grab; position: relative; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

#container { position: absolute; top: 0; left: 0; transform-origin: 0 0; }
#svg-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15; overflow: visible; }
#nodes-layer { position: absolute; top: 0; left: 0; z-index: 10; }
#nodes-canvas { position: absolute; top: 0; left: 0; z-index: 9; pointer-events: none; }
#laser-path { fill: none; stroke: #ff0000; stroke-width: 4; stroke-linecap: round; filter: drop-shadow(0 0 5px #ff0000); }
.connection { fill: none; stroke: #666; stroke-width: 3; }

/* èŠ‚ç‚¹æ ·å¼ä¼˜åŒ– */
.node { position: absolute; background: var(--node); border: 2px solid #444; border-radius: 8px; z-index: 10; display: flex; flex-direction: column; overflow: visible; }
.node.active { border-color: hsl(120, 100%, 50%); }

.node-header { padding: 0 8px; background: #2d2d2d; cursor: move; display: flex; align-items: center; gap: 4px; border-radius: 6px 6px 0 0; height: 38px; white-space: nowrap; overflow: hidden; }

/* å®ä¾‹åŒ–èŠ‚ç‚¹æ ·å¼ */
.node-instance { background: #1a2332; border: none; }
.node-instance.active { border-color: hsl(120, 100%, 50%); }
.node-header-instance { background: hsl(220, 100%, 30%); }
.node-title { background: transparent; border: none; color: #9cdcfe; font-weight: bold; outline: none; min-width: 30px; flex: 0 1 auto; font-size: 12px; user-select: none; overflow: hidden; text-overflow: ellipsis; }
.node-coords { flex: 0 0 auto; font-size: 11px; color: #888; margin: 0; }
.tool-group { margin-left: auto; display: flex; align-items: center; gap: 4px; }
.tool-icon { cursor: pointer; color: #999; font-size: 16px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: 0.2s; margin: 0; padding: 0; }
.tool-icon:hover { background: #444; color: #fff; }
.tool-icon.close:hover { background: #a33; }

.editor-wrapper { flex: 1; display: flex; background: #1e1e1e; position: relative; overflow: hidden; border-radius: 0 0 8px 8px; }
.line-numbers { padding: 12px 5px; color: #555; text-align: right; font-size: 13px; background: #181818; min-width: 38px; border-right: 1px solid #252525; line-height: 1.6; user-select: none; }
.code-input { flex: 1; background: transparent; color: #ce9178; border: none; padding: 12px; resize: none; outline: none; font-family: inherit; font-size: 13px; line-height: 1.6; white-space: pre; tab-size: 2; overflow-y: hidden; }
.code-input:focus { background: #151515; }
.code-input:hover { overflow-y: auto; } /* ä»…åœ¨é¼ æ ‡æ‚¬æµ®ä¸”å¿…è¦æ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */

/* ç«¯å£äº¤äº’å¼ºåŒ– */ 
.port { 
    position: absolute; 
    z-index: 100; 
    transition: all 0.2s; 
    background: #444; 
}



/* è¾“å…¥å£ï¼šä¿æŒåœ†ç‚¹ï¼Œä½†å¢åŠ éšå½¢æ„Ÿåº”åŒº */ 
.port-in { 
    left: -8px; 
    top: 50%; 
    width: 12px; 
    height: 12px; 
    border-radius: 50%; 
    border: 2px solid #aaa; 
    transform: translateY(-50%); 
}
/* å¢åŠ ä¸€ä¸ªé€æ˜çš„ä¼ªå…ƒç´ æ‰©å¤§ç‚¹å‡»é¢ç§¯ */ 
.port-in::after { 
    content: ''; 
    position: absolute; 
    inset: -10px; 
    border-radius: 50%; 
}

/* è¾“å‡ºå£ï¼šæ”¹ä¸ºé•¿æ–¹å½¢æ¡ */ 
.port-out { 
    right: -4px; 
    top: 0; 
    width: 8px; /* å®½åº¦é€‚ä¸­ï¼Œæ–¹ä¾¿æ•æ‰ */ 
    height: 100%; /* é«˜åº¦å……æ»¡æ•´ä¸ªèŠ‚ç‚¹è¾¹ç¼˜ */ 
    border-radius: 0 4px 4px 0; /* å³ä¾§åœ†è§’ */ 
    cursor: crosshair; 
    border: none; 
    border-left: 1px solid #333; 
}

/* æ‚¬æµ®æ•ˆæœï¼šé•¿æ–¹å½¢å˜äº®è“ */ 
.port-out:hover { 
    background: var(--accent); 
    width: 10px; /* æ‚¬æµ®æ—¶ç¨å¾®åŠ å®½ */ 
    box-shadow: 2px 0 10px rgba(0, 122, 204, 0.5); 
}

.port-in:hover { 
    background: var(--accent); 
    transform: translateY(-50%) scale(1.4); 
}

/* å°åœ°å›¾ Minimap */
#minimap { position: fixed; bottom: 20px; right: 20px; width: 150px; height: 150px; background: rgba(30, 30, 30, 0.8); border: 1px solid #444; border-radius: 50%; z-index: 1500; overflow: hidden; pointer-events: auto; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
#minimap-canvas { width: 100%; height: 100%; pointer-events: none; }
#minimap-viewport { position: absolute; border: 1px solid var(--accent); background: rgba(0, 122, 204, 0.1); pointer-events: none; border-radius: 50%; }

/* å®šä½æŒ‰é’®æ ·å¼ */
.btn-locate {
    position: absolute;
    top: 5px;
    left: 5px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 3px;
    padding: 3px 8px;
    font-size: 10px;
    cursor: pointer;
    z-index: 1510;
    transition: all 0.2s;
    pointer-events: auto;
}

.btn-locate:hover {
    background: #005a9e;
    transform: scale(1.05);
}

.modal-mask { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 2000; align-items: center; justify-content: center; }
.modal-panel { display: none; position: fixed; inset: 0; background: transparent; z-index: 2000; align-items: center; justify-content: center; }
.modal-box { background: #1e1e1e; width: 70%; max-height: 85%; display: flex; flex-direction: column; border-radius: 8px; border: 1px solid #444; }

/* ç»˜ç”»å·¥å…·æ æ ·å¼ */
#drawing-toolbar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(37, 37, 38, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    min-width: auto;
    width: auto;
    flex-wrap: nowrap;
}

#drawing-toolbar input[type="color"] {
    width: 32px;
    height: 32px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    cursor: pointer;
    background: transparent;
    padding: 0;
}

#drawing-toolbar input[type="range"] {
    width: 80px;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(68, 68, 68, 0.8);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0;
}

#drawing-toolbar input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 122, 204, 0.5);
    margin: 0;
}

#drawing-toolbar input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: none;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 122, 204, 0.5);
    margin: 0;
}

.tool-btn {
    width: 36px;
    height: 36px;
    border: 1px solid transparent;
    border-radius: 8px;
    background: rgba(51, 51, 51, 0.8);
    color: #fff;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(5px);
    padding: 0;
    margin: 0;
}

.tool-btn:hover {
    border-color: var(--accent);
    background: rgba(68, 68, 68, 0.9);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 122, 204, 0.3);
}

.tool-btn.active {
    border-color: hsl(120, 100%, 50%);
    background: rgba(0, 100, 0, 0.3);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
}

/* ç»˜ç”»è·¯å¾„æ ·å¼ */
.drawing-path {
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
    pointer-events: none;
    z-index: 8;
}

/* å›¾ç‰‡ç›¸å…³æ ·å¼ */
.image-item {
    position: absolute;
    background: transparent;
    border: 2px solid transparent;
    border-radius: 4px;
    overflow: hidden;
    cursor: move;
    user-select: none;
    z-index: 100;
    transition: all 0.2s ease;
}

.image-item.selected {
    border-color: hsl(120, 100%, 50%);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    background: rgba(0, 255, 0, 0.1);
}

.image-item img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: block;
}

/* æ‹–æ‹½çŠ¶æ€æ ·å¼ */
#viewport.drag-over {
    background-color: rgba(0, 122, 204, 0.1);
    border: 2px dashed rgba(0, 122, 204, 0.5);
}

/* å›¾ç‰‡æ§åˆ¶æ‰‹æŸ„æ ·å¼ */
.image-controls {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
}

/* ä»…å°†æ­¤æ ·å¼åº”ç”¨äºå›¾ç‰‡æ§ä»¶ä¸­çš„ç¼©æ”¾æ‰‹æŸ„ */
.image-controls .resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: var(--accent);
    border: 2px solid white;
    border-radius: 50%;
    pointer-events: auto;
    cursor: nwse-resize;
    transition: all 0.2s ease;
    z-index: 101;
}

.image-controls .resize-handle:hover {
    transform: scale(1.3);
    background: hsl(200, 100%, 70%);
}

.image-controls .resize-nw {
    top: -6px;
    left: -6px;
    cursor: nwse-resize;
}

.image-controls .resize-ne {
    top: -6px;
    right: -6px;
    cursor: nesw-resize;
}

.image-controls .resize-se {
    bottom: -6px;
    right: -6px;
    cursor: nwse-resize;
}

.image-controls .resize-sw {
    bottom: -6px;
    left: -6px;
    cursor: nesw-resize;
}

/* å›¾ç‰‡å·¥å…·æ æ ·å¼ */
.image-toolbar {
    position: fixed;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(30, 30, 30, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 15px;
    z-index: 2000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    min-width: 200px;
}

.image-toolbar .toolbar-section h3 {
    margin: 0 0 15px 0;
    color: var(--accent);
    font-size: 14px;
    font-weight: bold;
    text-align: center;
}

.image-toolbar .tool-item {
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.image-toolbar .tool-item label {
    font-size: 12px;
    color: #ccc;
    display: flex;
    align-items: center;
    gap: 8px;
}

.image-toolbar .tool-item input[type="range"] {
    width: 100%;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(68, 68, 68, 0.8);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
}

.image-toolbar .tool-item input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 122, 204, 0.5);
}

.image-toolbar .tool-item input[type="number"] {
    background: #333;
    border: 1px solid #444;
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    width: 60px;
}

.image-toolbar .tool-item button {
    background: #333;
    border: 1px solid #444;
    color: #fff;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 12px;
    transition: 0.2s;
}

.image-toolbar .tool-item button:hover {
    border-color: var(--accent);
    background: #444;
}

/* å³é”®èœå•æ ·å¼ */
.context-menu {
    position: fixed;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px 0;
    z-index: 10000;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    min-width: 120px;
}

.menu-item {
    padding: 8px 16px;
    cursor: pointer;
    font-size: 13px;
    color: #333;
    transition: all 0.2s ease;
    user-select: none;
}

.menu-item:hover {
    background: #f0f0f0;
    color: var(--accent);
}

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(33, 150, 243, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(33, 150, 243, 0.7);
        }
        
        /* è‡ªå®šä¹‰æ»‘åŠ¨æ¡æ ·å¼ */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #1976D2;
            transform: scale(1.1);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: #1976D2;
            transform: scale(1.1);
        }
        
        /* æŒ‰é’®æ‚¬åœæ•ˆæœ */
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* è¾“å…¥æ¡†ç„¦ç‚¹æ•ˆæœ */
        input[type="number"]:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        /* ç»˜ç”»æ¨¡å¼æ¿€æ´»æ—¶çš„è§†è§‰æç¤º */
.drawing-mode-active {
    border: 2px solid #ff9900 !important;
    box-shadow: 0 0 10px rgba(255, 153, 0, 0.5) !important;
}

/* åœ¨ç»˜ç”»å·¥å…·æ æŒ‰é’®æ¿€æ´»æ—¶ç»™ç”»å¸ƒæ·»åŠ æç¤º */
#viewport.drawing-active {
    cursor: crosshair;
}

#viewport.erasing-active {
    cursor: pointer;
}</style>
</head>

<body oncontextmenu="return false;"> <!-- ç¦ç”¨æµè§ˆå™¨é»˜è®¤å³é”®èœå• -->

    <div id="viewport">
        <header class="floating-header">
            <div class="nav-left">
                <button class="btn-help btn-green" onclick="AudioSystem.playButtonSound(); app.addNewNode()"> æ–°å»º </button>
                <button class="btn-help btn-red" onclick="AudioSystem.playButtonSound(); app.clearAll()"> æ¸…ç©º </button>
                <button class="btn-help btn-yellow" onclick="AudioSystem.playButtonSound(); app.exportCode()"> åˆæˆ </button>
                
                <button class="btn-help btn-purple" onclick="AudioSystem.playButtonSound(); app.importJson()"> å¯¼å…¥ </button>
                <button class="btn-help btn-purple" onclick="AudioSystem.playButtonSound(); app.exportJson()"> å¯¼å‡º </button>
                <button class="btn-help btn-blue" id="locate-first-node" title="å®šä½åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹"
                    onclick="AudioSystem.playButtonSound()"> å®šä½ </button>
                <button class="btn-help btn-green" onclick="AudioSystem.playButtonSound(); CutImgSystem.showPanel('split')"> åˆ‡å›¾ </button>
                <button class="btn-help btn-red" onclick="AudioSystem.playButtonSound(); HelpSystem.showHelp()">è®¾ç½®</button>
                
                <input type="file" id="json-import" accept=".json" style="display: none;"
                    onchange="app.handleFileImport(event)">
            </div>
            


        </header>
        <div id="container">
            <div id="nodes-layer"></div>
            <!-- CanvasèŠ‚ç‚¹æ¸²æŸ“å±‚ -->
            <canvas id="nodes-canvas"></canvas>
        </div>
        <!-- å°†SVGç”»å¸ƒç§»å‡ºcontainerï¼Œå•ç‹¬æ§åˆ¶å…¶å˜æ¢ -->
        <svg id="svg-canvas">
            <defs>
                <!-- æ¿€å…‰ç¬”æ¸å˜æ•ˆæœ -->
                <linearGradient id="laserGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff0000;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ff0000;stop-opacity:0" />
                </linearGradient>
            </defs>
            <g id="conns-group"></g>
            <path id="laser-path" d=""></path>
        </svg>
    </div>
    
    <!-- æ— é™ç”»å¸ƒ -->
    <canvas id="infinite-canvas" style="position: fixed; top: 0; left: 0; z-index: 999; display: none; cursor: crosshair;"></canvas>

    <div id="minimap">

        <div id="minimap-viewport"></div>
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="modal-code" class="modal-mask">
        <div class="modal-box" style="width: 80%; max-width: 1000px;">
            <div
                style="padding:15px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                <div style="display:flex; align-items:center; gap:10px;">
                    <strong>ä»£ç é¢„è§ˆ</strong>
                    <button class="btn copy-code-btn" id="modal-copy-btn"
                        style="font-size:12px; padding:3px 10px;">å¤åˆ¶ä»£ç </button>
                </div>
                <button class="btn" onclick="app.closeModals()">å…³é—­</button>
            </div>
            <pre id="modal-content" style="padding:20px; margin:0; overflow:auto; color:#9cdcfe; font-size:14px;"></pre>
        </div>
    </div>

    <div id="modal-help" class="modal-panel">
        <div class="modal-box" style="max-width: 800px; max-height: 80vh; overflow: hidden;">
            <div style="padding:15px; border-bottom:1px solid #333; display:flex; justify-content:space-between;">
                <strong>æ“ä½œæŒ‡å—</strong>
                <button class="btn" onclick="app.closeModals()">å…³é—­</button>
            </div>
            <div id="help-content" style="padding:20px; overflow-y: auto; max-height: calc(80vh - 80px);"></div>
        </div>
    </div>

    <!-- ç»˜ç”»å·¥å…·æ  -->
    <div id="drawing-toolbar">
        <button class="tool-btn" id="infinite-canvas-btn" title="æ— é™ç”»å¸ƒ" onclick="AudioSystem.playButtonSound(); toggleInfiniteCanvas()">âˆ</button>
        <button class="tool-btn" data-tool="emoji" title="è¡¨æƒ…">ğŸ˜€</button>
        <button class="tool-btn" data-tool="brush" title="ç”»ç¬”">ç¬”</button>
        <input type="color" id="brush-color" value="#ff0000">
        <input type="range" id="brush-size" min="1" max="20" value="1">
        <button class="tool-btn" data-tool="eraser" title="æ©¡çš®æ“¦">æ“¦</button>
        <button class="tool-btn" id="clear-drawing-btn" data-tool="clear" title="æ¸…ç©ºç»˜ç”»">æ¸…</button>
    </div>
    
    <!-- Emojièœå• -->
    <div id="emoji-menu" style="display: none; position: fixed; background: rgba(37, 37, 38, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 15px; z-index: 1001; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); width: 420px; height: 200px; overflow-y: auto;">
        <div class="emoji-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 8px;"></div>
    </div>

    <!-- å›¾ç‰‡ç¼–è¾‘æ§åˆ¶é¢æ¿ -->
    <div id="image-editor-panel"
        style="display: none; position: fixed; top: 100px; right: 20px; background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 12px; color: white; z-index: 1000; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); width: 280px;">
        <h3 style="margin: 0 0 20px 0; font-size: 18px; color: #2196F3; text-align: center;">åŸºç¡€åŠŸèƒ½</h3>

        <!-- ä½ç½®è°ƒæ•´ - ç¬¬ä¸€è¡Œ -->
        <div style="margin-bottom: 20px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">

            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="move-to-center-btn"
                    style="padding: 8px 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    åæ ‡
                </button>
                <div style="flex: 1;">
                    <input type="number" id="image-x" min="0"
                        style="width: 100%; padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 14px; box-sizing: border-box;">
                </div>
                <div style="flex: 1;">
                    <input type="number" id="image-y" min="0"
                        style="width: 100%; padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 14px; box-sizing: border-box;">
                </div>
            </div>
        </div>

        <!-- æ—‹è½¬è°ƒæ•´ - ç¬¬äºŒè¡Œ -->
        <div style="margin-bottom: 20px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="rotation-btn"
                    style="padding: 8px 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">æ—‹è½¬</button>
                <input type="range" id="image-rotation" min="0" max="360" value="0"
                    style="width: 100px; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; outline: none; -webkit-appearance: none;">
                <span id="rotation-value"
                    style="width: 0px; text-align: center; font-size: 14px; color: #BBDEFB;">0Â°</span>

            </div>
        </div>

        <!-- ç¼©æ”¾è°ƒæ•´ - ç¬¬ä¸‰è¡Œ -->
        <div style="margin-bottom: 20px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="reset-scale-btn"
                    style="padding: 8px 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">ç¼©æ”¾</button>
                <input type="range" id="image-scale" min="1" max="6" step="0.1" value="1"
                    style="width: 100px; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; outline: none; -webkit-appearance: none;">
                <span id="scale-value"
                    style="width: 0px; text-align: center; font-size: 14px; color: #BBDEFB;">1.0x</span>
            </div>
        </div>

        <!-- ç¿»è½¬è°ƒæ•´ - ç¬¬å››è¡Œ -->
        <div style="margin-bottom: 20px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="reset-flip-btn"
                    style="padding: 8px 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    ç¿»è½¬
                </button>
                <div style="display: flex; gap: 10px; flex: 1; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 5px; flex: 1;">
                        <input type="checkbox" id="flip-horizontal" style="cursor: pointer; transform: scale(1.2);">
                        <label for="flip-horizontal" style="color: white; font-size: 14px; cursor: pointer;">å·¦å³</label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; flex: 1;">
                        <input type="checkbox" id="flip-vertical" style="cursor: pointer; transform: scale(1.2);">
                        <label for="flip-vertical" style="color: white; font-size: 14px; cursor: pointer;">ä¸Šä¸‹</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- å›¾ç‰‡è£å‰ªåŠŸèƒ½ - æ”¾åœ¨åŸºç¡€åŠŸèƒ½ä¸‹é¢ -->
        <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <button id="crop-image-btn"
                style="width: 100%; padding: 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: all 0.2s ease;">
                è£ å‰ª
            </button>
        </div>
        
        <!-- å›¾ç‰‡è°ƒè‰²åŠŸèƒ½ - æ”¾åœ¨è£å‰ªåŠŸèƒ½ä¸‹é¢ -->
        <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <button id="color-adjust-btn"
                style="width: 100%; padding: 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: all 0.2s ease;">
                è°ƒ è‰²
            </button>
        </div>
        
        <!-- å›¾å±‚æ“ä½œåŠŸèƒ½ - æ”¾åœ¨è°ƒè‰²åŠŸèƒ½ä¸‹é¢ -->
        <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #2196F3; text-align: center;">å›¾å±‚æ“ä½œ</h4>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                <button onclick="imageHandler.moveImageUp()"
                    style="padding: 8px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    ä¸Šç§»
                </button>
                <button onclick="imageHandler.moveImageDown()"
                    style="padding: 8px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    ä¸‹ç§»
                </button>
                <button onclick="imageHandler.moveImageToTop()"
                    style="padding: 8px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    ç½®é¡¶
                </button>
                <button onclick="imageHandler.moveImageToBottom()"
                    style="padding: 8px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                    ç½®ä½
                </button>
            </div>
        </div>
        
        <!-- ä¿å­˜å›¾ç‰‡åŠŸèƒ½ - æ”¾åœ¨å›¾å±‚æ“ä½œä¸‹é¢ -->
        <div style="margin-bottom: 0; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
            <button id="save-image-btn"
                style="width: 100%; padding: 12px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: all 0.2s ease;">
                ä¿ å­˜
            </button>
        </div>

    </div>




                                                                            
    <script>
        // ç­‰å¾…DOMåŠ è½½å®Œæˆååˆå§‹åŒ–ç³»ç»Ÿ
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMåŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–ç³»ç»Ÿ');
            if (typeof MusicSystem !== 'undefined') {
                MusicSystem.init();
            }
            if (typeof VideoSystem !== 'undefined') {
                VideoSystem.init();
            }
        });
        
        // åˆ‡æ¢æ— é™ç”»å¸ƒç³»ç»Ÿ
        function toggleInfiniteCanvas() {
            if (typeof infiniteCanvas !== 'undefined') {
                if (infiniteCanvas.isActive) {
                    infiniteCanvas.deactivate();
                } else {
                    infiniteCanvas.activate();
                }
            }
        }
    </script>

<script>// audio.js - ç‹¬ç«‹çš„éŸ³é¢‘æ¨¡å—ï¼ˆä»…ä¿ç•™éŸ³æ•ˆåŠŸèƒ½ï¼‰
const AudioSystem = {
    // ç²˜è´´è¿‡æ¥çš„ audio å¯¹è±¡æ‰€æœ‰å±æ€§
    audio: {
        audioContext: null,
        masterGain: null,
        initialized: false
    },
    
    // éŸ³ä¹å¯ç”¨çŠ¶æ€
    enabled: true,
    
    // åˆ‡æ¢éŸ³ä¹å¼€å…³
    toggleMusic() {
        this.enabled = !this.enabled;
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('audioEnabled', this.enabled);
        
        // æ›´æ–°å¯¼èˆªæ æŒ‰é’®çŠ¶æ€
        const navButton = document.getElementById('music-toggle');
        if (navButton) {
            if (this.enabled) {
                // å¼€å¯éŸ³ä¹
                navButton.className = 'btn-help btn-green';
                navButton.title = 'å…³é—­éŸ³ä¹';
                // æ¸…é™¤å†…è”æ ·å¼ï¼Œè®©ç±»æ ·å¼ç”Ÿæ•ˆ
                navButton.style.backgroundColor = '';
                navButton.style.color = '';
            } else {
                // å…³é—­éŸ³ä¹
                navButton.className = 'btn-help';
                navButton.style.backgroundColor = '#666';
                navButton.style.color = '#ccc';
                navButton.title = 'å¼€å¯éŸ³ä¹';
            }
        }
        
        // æ›´æ–°è®¾ç½®é¢æ¿ä¸­çš„æŒ‰é’®çŠ¶æ€
        const settingButton = document.getElementById('music-toggle-setting');
        if (settingButton) {
            if (this.enabled) {
                settingButton.className = 'setting-btn btn-green';
                settingButton.textContent = 'å¼€å¯';
            } else {
                settingButton.className = 'setting-btn btn-gray';
                settingButton.textContent = 'å…³é—­';
            }
        }
        
        // æ’­æ”¾æŒ‰é’®éŸ³æ•ˆï¼ˆå¦‚æœéŸ³ä¹å¼€å¯ï¼‰
        if (this.enabled) {
            this.playButtonSound();
        }
    },

    // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
    initAudio() {
        // åŠ è½½ä¿å­˜çš„éŸ³æ•ˆå¼€å…³çŠ¶æ€
        const savedEnabled = localStorage.getItem('audioEnabled');
        if (savedEnabled !== null) {
            this.enabled = savedEnabled === 'true';
        }
        
        // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’è§¦å‘ï¼‰
        const initAudioContext = () => {
            if (!this.audio.initialized) {
                try {
                    console.log('åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡...');
                    this.audio.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audio.masterGain = this.audio.audioContext.createGain();
                    this.audio.masterGain.connect(this.audio.audioContext.destination);
                    this.audio.masterGain.gain.value = 0.8; // æé«˜ä¸»éŸ³é‡ä»¥ä¾¿æµ‹è¯•
                    this.audio.initialized = true;
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–æˆåŠŸï¼');
                    
                    // æ’­æ”¾ä¸€ä¸ªæµ‹è¯•éŸ³æ•ˆï¼Œç¡®è®¤éŸ³é¢‘ç³»ç»Ÿå·¥ä½œæ­£å¸¸
                    if (this.enabled) {
                        this.playButtonSound();
                    }
                    
                    // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                    document.removeEventListener('click', initAudioContext);
                    document.removeEventListener('keydown', initAudioContext);
                } catch (e) {
                    console.error('Web Audio API ä¸æ”¯æŒ:', e);
                }
            }
        };
        
        // ç›´æ¥å°è¯•åˆå§‹åŒ–ï¼ŒåŒæ—¶ä¿ç•™ç”¨æˆ·äº¤äº’è§¦å‘ä½œä¸ºåå¤‡
        try {
            initAudioContext();
        } catch (e) {
            console.log('ç­‰å¾…ç”¨æˆ·äº¤äº’åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡...');
            // åœ¨ç”¨æˆ·ç¬¬ä¸€æ¬¡äº¤äº’æ—¶åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
            document.addEventListener('click', initAudioContext);
            document.addEventListener('keydown', initAudioContext);
        }
    },
    
    // ç”Ÿæˆç™½å™ªå£°æ ·æœ¬
    generateWhiteNoise(duration = 0.1) {
        if (!this.audio.initialized) return null;
        
        const sampleRate = this.audio.audioContext.sampleRate;
        const buffer = this.audio.audioContext.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
            data[i] = Math.random() * 2 - 1; // ç”Ÿæˆ -1 åˆ° 1 ä¹‹é—´çš„éšæœºæ•°
        }
        
        return buffer;
    },
    
    // æ’­æ”¾å™ªå£°éŸ³æ•ˆ
    playNoiseSound(type = 'white', duration = 0.1, frequency = 440, volume = 0.5) {
        // å¦‚æœéŸ³ä¹è¢«ç¦ç”¨ï¼Œç›´æ¥è¿”å›
        if (!this.enabled) {
            return;
        }
        
        console.log(`å°è¯•æ’­æ”¾éŸ³æ•ˆ: ${type}, é¢‘ç‡: ${frequency}, æ—¶é•¿: ${duration}s`);
        
        // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œå°è¯•åˆå§‹åŒ–
        if (!this.audio.initialized) {
            console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œå°è¯•åˆå§‹åŒ–...');
            this.initAudio();
            return;
        }
        
        try {
            const audioContext = this.audio.audioContext;
            const gainNode = audioContext.createGain();
            
            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºè¿è¡ŒçŠ¶æ€
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            let source;
            if (type === 'white') {
                // ç®€åŒ–ï¼šç›´æ¥ä½¿ç”¨æŒ¯è¡å™¨ç”Ÿæˆå™ªå£°
                source = audioContext.createOscillator();
                source.type = 'sawtooth'; // é”¯é½¿æ³¢æ¥è¿‘ç™½å™ªå£°
                source.frequency.value = frequency;
            } else {
                // ä½¿ç”¨æŒ‡å®šç±»å‹çš„æŒ¯è¡å™¨
                source = audioContext.createOscillator();
                source.type = type;
                source.frequency.value = frequency;
            }
            
            // è®¾ç½®éŸ³é‡åŒ…ç»œ
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            // ç›´æ¥è¿æ¥ï¼Œç®€åŒ–éŸ³é¢‘å›¾
            source.connect(gainNode);
            gainNode.connect(this.audio.masterGain);
            
            // æ’­æ”¾
            source.start();
            source.stop(audioContext.currentTime + duration);
            
            console.log('éŸ³æ•ˆæ’­æ”¾æˆåŠŸ');
        } catch (e) {
            console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', e);
        }
    },
    
    // æ’­æ”¾æŒ‰é’®ç‚¹å‡»éŸ³æ•ˆ
    playButtonSound() {
        this.playNoiseSound('white', 0.1, 800, 0.3);
    },
    
    // æ’­æ”¾è¿æ¥å»ºç«‹éŸ³æ•ˆ
    playConnectionSound() {
        this.playNoiseSound('sine', 0.15, 600, 0.4);
    },
    
    // æ’­æ”¾è¿æ¥æ–­å¼€éŸ³æ•ˆ
    playDisconnectSound() {
        this.playNoiseSound('white', 0.1, 300, 0.3);
    },
    
    // æ’­æ”¾åˆ é™¤èŠ‚ç‚¹éŸ³æ•ˆ
    playDeleteSound() {
        this.playNoiseSound('square', 0.2, 200, 0.5);
    },
    
    // æ’­æ”¾åˆ›å»ºèŠ‚ç‚¹éŸ³æ•ˆ
    playCreateSound() {
        this.playNoiseSound('sine', 0.15, 1000, 0.4);
    },
    
    // æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
    playErrorSound() {
        this.playNoiseSound('sawtooth', 0.3, 150, 0.5);
    }
};

// å¯¼å‡ºæ¨¡å—ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ–‡ä»¶ä½¿ç”¨
window.AudioSystem = AudioSystem;

// music.js - éŸ³ä¹æ’­æ”¾æ¨¡å—
const MusicSystem = {
    // éŸ³é¢‘æ’­æ”¾å™¨åˆ—è¡¨
    audioPlayers: [],
    
    // éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹
    musicListNodes: [],
    
    // ç”Ÿæˆéšæœºé¢œè‰²ï¼ˆä½¿ç”¨HSLæ¨¡å¼ï¼‰
    getRandomColor() {
        const hue = Math.floor(Math.random() * 360);
        const saturation = 70 + Math.floor(Math.random() * 30);
        const lightness = 50 + Math.floor(Math.random() * 10);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    },
    
    // åˆå§‹åŒ–éŸ³ä¹ç³»ç»Ÿ
    init() {
        console.log('=== MusicSystem: åˆå§‹åŒ–éŸ³ä¹ç³»ç»Ÿ ===');
        this.loadFromLocalStorage();
        this.initDragAndDrop();
    },
    
    // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
    initDragAndDrop() {
        console.log('=== MusicSystem: åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½ ===');
        
        // è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶
        this.setupGlobalDragEvents();
    },
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    saveToLocalStorage() {
        // é¿å…é¢‘ç¹ä¿å­˜ï¼Œä½¿ç”¨é˜²æŠ–
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        
        this.saveTimeout = setTimeout(() => {
            console.log('MusicSystem: ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
            
            try {
                // æ£€æŸ¥éŸ³é¢‘æ’­æ”¾å™¨åˆ—è¡¨
                if (this.audioPlayers.length === 0) {
                    console.log('MusicSystem: æ²¡æœ‰éŸ³é¢‘æ’­æ”¾å™¨éœ€è¦ä¿å­˜');
                    return;
                }
                
                console.log('MusicSystem: éŸ³é¢‘æ’­æ”¾å™¨æ•°é‡:', this.audioPlayers.length);
                
                // ä¿å­˜éŸ³é¢‘æ’­æ”¾å™¨
                const audioPlayersData = this.audioPlayers.map(player => {
                    // ç¡®ä¿è·å–æœ‰æ•ˆçš„ä½ç½®å€¼
                    const left = player.element.style.left || '0px';
                    const top = player.element.style.top || '0px';
                    return {
                        id: player.id,
                        audioUrl: player.audio.src,
                        x: parseInt(left) || 0,
                        y: parseInt(top) || 0,
                        currentTime: player.currentTime,
                        isPlaying: player.isPlaying,
                        backgroundColor: player.element.style.backgroundColor || this.getRandomColor()
                    };
                });
                
                // ä¿å­˜éŸ³ä¹åˆ—è¡¨
                const musicListData = this.musicListNodes.map(node => ({
                    id: node.id,
                    x: parseInt(node.element.style.left) || 0,
                    y: parseInt(node.element.style.top) || 0,
                    audioFiles: node.audioFiles.map(file => ({
                        name: file.name,
                        lastModified: file.lastModified,
                        size: file.size,
                        type: file.type
                    })),
                    currentIndex: node.currentIndex,
                    playbackMode: node.playbackMode,
                    currentTime: node.currentTime
                }));
                
                // æ£€æŸ¥æœ¬åœ°å­˜å‚¨å¤§å°
                const audioPlayersString = JSON.stringify(audioPlayersData);
                const musicListString = JSON.stringify(musicListData);
                const totalSize = audioPlayersString.length + musicListString.length;
                
                console.log('MusicSystem: éŸ³é¢‘æ’­æ”¾å™¨æ•°æ®å¤§å°:', audioPlayersString.length, 'å­—èŠ‚');
                console.log('MusicSystem: éŸ³ä¹åˆ—è¡¨æ•°æ®å¤§å°:', musicListString.length, 'å­—èŠ‚');
                console.log('MusicSystem: æ€»æ•°æ®å¤§å°:', totalSize, 'å­—èŠ‚');
                
                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ¬åœ°å­˜å‚¨é™åˆ¶ï¼ˆçº¦5MBï¼‰
                if (totalSize > 5 * 1024 * 1024) {
                    console.warn('MusicSystem: æœ¬åœ°å­˜å‚¨æ•°æ®è¶…è¿‡5MBé™åˆ¶ï¼Œå¯èƒ½æ— æ³•ä¿å­˜');
                    // åªä¿å­˜æœ€è¿‘çš„å‡ ä¸ªæ’­æ”¾å™¨
                    const trimmedPlayers = audioPlayersData.slice(-5); // åªä¿å­˜æœ€è¿‘çš„5ä¸ª
                    localStorage.setItem('musicSystemAudioPlayers', JSON.stringify(trimmedPlayers));
                } else {
                    localStorage.setItem('musicSystemAudioPlayers', audioPlayersString);
                    localStorage.setItem('musicSystemMusicLists', musicListString);
                }
                
                console.log('MusicSystem: ä¿å­˜æˆåŠŸ');
                
                // éªŒè¯ä¿å­˜
                const savedData = localStorage.getItem('musicSystemAudioPlayers');
                console.log('MusicSystem: ä¿å­˜åéªŒè¯:', savedData ? 'æˆåŠŸ' : 'å¤±è´¥');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    console.log('MusicSystem: ä¿å­˜åæ’­æ”¾å™¨æ•°é‡:', parsedData.length);
                }
            } catch (error) {
                console.error('MusicSystem: ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
                console.error('MusicSystem: é”™è¯¯è¯¦æƒ…:', error.message);
            }
        }, 100); // 100msé˜²æŠ–
    },
    
    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
    loadFromLocalStorage() {
        console.log('MusicSystem: ä»æœ¬åœ°å­˜å‚¨åŠ è½½');
        
        try {
            // æ¸…ç©ºç°æœ‰æ’­æ”¾å™¨ï¼Œé¿å…é‡å¤
            this.clearAllPlayers();
            
            // æ£€æŸ¥æœ¬åœ°å­˜å‚¨æ˜¯å¦æœ‰æ•°æ®
            const audioPlayersData = localStorage.getItem('musicSystemAudioPlayers');
            console.log('MusicSystem: æœ¬åœ°å­˜å‚¨çŠ¶æ€ - éŸ³é¢‘æ’­æ”¾å™¨:', audioPlayersData ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            
            // åŠ è½½éŸ³é¢‘æ’­æ”¾å™¨
            if (audioPlayersData) {
                console.log('MusicSystem: æ‰¾åˆ°éŸ³é¢‘æ’­æ”¾å™¨æ•°æ®ï¼Œé•¿åº¦:', audioPlayersData.length, 'å­—èŠ‚');
                try {
                    const players = JSON.parse(audioPlayersData);
                    console.log('MusicSystem: è§£æå‡ºéŸ³é¢‘æ’­æ”¾å™¨æ•°é‡:', players.length);
                    
                    if (players.length === 0) {
                        console.log('MusicSystem: æ²¡æœ‰éŸ³é¢‘æ’­æ”¾å™¨æ•°æ®');
                        return;
                    }
                    
                    // æ‰¹é‡åˆ›å»ºDOMå…ƒç´ ï¼Œå‡å°‘é‡æ’
                    const fragment = document.createDocumentFragment();
                    const nodesLayer = document.getElementById('nodes-layer');
                    const container = nodesLayer || document.body;
                    
                    players.forEach((playerData, index) => {
                        console.log('MusicSystem: åŠ è½½æ’­æ”¾å™¨', index + 1, ':', playerData.id, 'ä½ç½®:', playerData.x, playerData.y);
                        this.restoreAudioPlayer(playerData, fragment);
                    });
                    
                    // ä¸€æ¬¡æ€§æ·»åŠ åˆ°DOM
                    if (fragment.childNodes.length > 0) {
                        container.appendChild(fragment);
                    }
                    
                } catch (parseError) {
                    console.error('MusicSystem: è§£æéŸ³é¢‘æ’­æ”¾å™¨æ•°æ®å¤±è´¥:', parseError);
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem('musicSystemAudioPlayers');
                    console.log('MusicSystem: å·²æ¸…é™¤æŸåçš„éŸ³é¢‘æ’­æ”¾å™¨æ•°æ®');
                }
            } else {
                console.log('MusicSystem: æœ¬åœ°å­˜å‚¨ä¸­æ²¡æœ‰éŸ³é¢‘æ’­æ”¾å™¨æ•°æ®');
            }
            
            // åŠ è½½éŸ³ä¹åˆ—è¡¨
            const musicListData = localStorage.getItem('musicSystemMusicLists');
            if (musicListData) {
                console.log('MusicSystem: æ‰¾åˆ°éŸ³ä¹åˆ—è¡¨æ•°æ®ï¼Œé•¿åº¦:', musicListData.length, 'å­—èŠ‚');
                try {
                    const lists = JSON.parse(musicListData);
                    console.log('MusicSystem: è§£æå‡ºéŸ³ä¹åˆ—è¡¨æ•°é‡:', lists.length);
                    lists.forEach((listData, index) => {
                        console.log('MusicSystem: åŠ è½½éŸ³ä¹åˆ—è¡¨', index + 1, ':', listData.id);
                        this.restoreMusicList(listData);
                    });
                } catch (parseError) {
                    console.error('MusicSystem: è§£æéŸ³ä¹åˆ—è¡¨æ•°æ®å¤±è´¥:', parseError);
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem('musicSystemMusicLists');
                    console.log('MusicSystem: å·²æ¸…é™¤æŸåçš„éŸ³ä¹åˆ—è¡¨æ•°æ®');
                }
            } else {
                console.log('MusicSystem: æœ¬åœ°å­˜å‚¨ä¸­æ²¡æœ‰éŸ³ä¹åˆ—è¡¨æ•°æ®');
            }
            
            console.log('MusicSystem: åŠ è½½å®Œæˆï¼Œå½“å‰éŸ³é¢‘æ’­æ”¾å™¨æ•°é‡:', this.audioPlayers.length);
        } catch (error) {
            console.error('MusicSystem: ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¤±è´¥:', error);
            console.error('MusicSystem: é”™è¯¯è¯¦æƒ…:', error.message);
        }
    },
    
    // æ¸…ç©ºæ‰€æœ‰æ’­æ”¾å™¨
    clearAllPlayers() {
        console.log('MusicSystem: æ¸…ç©ºæ‰€æœ‰æ’­æ”¾å™¨');
        
        // ç§»é™¤DOMå…ƒç´ 
        this.audioPlayers.forEach(player => {
            if (player.element && player.element.parentNode) {
                player.element.parentNode.removeChild(player.element);
            }
            if (player.audio && player.audio.parentNode) {
                player.audio.parentNode.removeChild(player.audio);
            }
        });
        
        // æ¸…ç©ºæ•°ç»„
        this.audioPlayers = [];
    },
    
    // æ¢å¤éŸ³é¢‘æ’­æ”¾å™¨
    restoreAudioPlayer(playerData, fragment) {
        console.log('MusicSystem: æ¢å¤éŸ³é¢‘æ’­æ”¾å™¨:', playerData.id);
        
        try {
            const playerId = playerData.id;
            const playButton = document.createElement('button');
            playButton.id = playerId;
            playButton.className = 'audio-player';
            playButton.innerHTML = playerData.isPlaying ? 'â¸' : 'â–¶';
            
            // æ‰¹é‡è®¾ç½®æ ·å¼ï¼Œå‡å°‘é‡æ’
            Object.assign(playButton.style, {
                position: 'absolute',
                width: '60px',
                height: '60px',
                borderRadius: '50%',
                border: 'none',
                backgroundColor: playerData.backgroundColor || this.getRandomColor(),
                color: 'white',
                fontSize: '20px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: '1000',
                left: playerData.x + 'px',
                top: playerData.y + 'px'
            });
            
            // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
            const audioElement = document.createElement('audio');
            audioElement.src = playerData.audioUrl;
            audioElement.loop = true;
            audioElement.style.display = 'none';
            
            // æ·»åŠ åˆ°DocumentFragmentæˆ–ç›´æ¥æ·»åŠ åˆ°DOM
            if (fragment) {
                fragment.appendChild(playButton);
                fragment.appendChild(audioElement);
            } else {
                // æ·»åŠ åˆ°nodes-layer
                const nodesLayer = document.getElementById('nodes-layer');
                if (nodesLayer) {
                    nodesLayer.appendChild(playButton);
                    nodesLayer.appendChild(audioElement);
                } else {
                    document.body.appendChild(playButton);
                    document.body.appendChild(audioElement);
                }
            }
            
            // å­˜å‚¨æ’­æ”¾å™¨ä¿¡æ¯
            const playerInfo = {
                id: playerId,
                element: playButton,
                audio: audioElement,
                playButton: playButton,
                isPlaying: playerData.isPlaying,
                currentTime: playerData.currentTime
            };
            this.audioPlayers.push(playerInfo);
            
            // æ’­æ”¾/æš‚åœäº‹ä»¶
            playButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleAudioPlayback(playerId);
            });
            
            // éŸ³é¢‘äº‹ä»¶
            // ç”±äºè®¾ç½®äº† loop = trueï¼Œended äº‹ä»¶ä¸ä¼šè§¦å‘ï¼Œæ‰€ä»¥ç§»é™¤è¿™ä¸ªç›‘å¬å™¨
            
            audioElement.addEventListener('timeupdate', () => {
                playerInfo.currentTime = audioElement.currentTime;
                // å®šæœŸä¿å­˜ - å‡å°‘é¢‘ç‡ï¼Œé¿å…æ€§èƒ½é—®é¢˜
                if (Math.random() < 0.01) { // 1% çš„æ¦‚ç‡ä¿å­˜
                    this.saveToLocalStorage();
                }
            });
            
            // æ‹–æ‹½åŠŸèƒ½ - å‚è€ƒscript.jsä¸­çš„èŠ‚ç‚¹æ‹–æ‹½å®ç°
            let isDragging = false;
            let startX, startY;
            
            console.log('MusicSystem: ä¸ºæ’­æ”¾å™¨æ·»åŠ æ‹–æ‹½äº‹ä»¶ç›‘å¬å™¨:', playerId);
            
            // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
            const mouseDownHandler = (e) => {
                if (e.button === 0) { // å·¦é”®
                    e.stopPropagation();
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // æ”¹å˜é¼ æ ‡æ ·å¼
                    document.body.style.cursor = 'grabbing';
                    console.log('MusicSystem: å¼€å§‹æ‹–æ‹½');
                }
            };
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            const mouseMoveHandler = (e) => {
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // è®¡ç®—ç§»åŠ¨è·ç¦»
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // è·å–å½“å‰ä½ç½®
                    const currentX = parseInt(playButton.style.left || 0);
                    const currentY = parseInt(playButton.style.top || 0);
                    
                    // è®¡ç®—æ–°ä½ç½®
                    const newX = currentX + deltaX;
                    const newY = currentY + deltaY;
                    
                    // æ›´æ–°ä½ç½®
                    playButton.style.left = newX + 'px';
                    playButton.style.top = newY + 'px';
                    
                    // æ›´æ–°èµ·å§‹ä½ç½®
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    console.log('MusicSystem: ç§»åŠ¨åˆ°ä½ç½®:', newX, newY);
                }
            };
            
            // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
            const mouseUpHandler = (e) => {
                if (isDragging) {
                    e.stopPropagation();
                    isDragging = false;
                    
                    // æ¢å¤é¼ æ ‡æ ·å¼
                    document.body.style.cursor = '';
                    
                    // ä¿å­˜æ–°ä½ç½®åˆ°æœ¬åœ°å­˜å‚¨
                    this.saveToLocalStorage();
                    console.log('MusicSystem: ç»“æŸæ‹–æ‹½ï¼Œä¿å­˜ä½ç½®');
                }
            };
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            playButton.addEventListener('mousedown', mouseDownHandler);
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            
            // å³é”®åˆ é™¤åŠŸèƒ½
            this.setupRightClickDelete(playButton, playerId, false);
            
            console.log('MusicSystem: æ’­æ”¾å™¨æ¢å¤æˆåŠŸ:', playerId);
        } catch (error) {
            console.error('MusicSystem: æ¢å¤æ’­æ”¾å™¨å¤±è´¥:', error);
        }
    },
    
    // æ¢å¤éŸ³ä¹åˆ—è¡¨
    restoreMusicList(listData) {
        console.log('MusicSystem: æ¢å¤éŸ³ä¹åˆ—è¡¨:', listData.id);
        
        try {
            // ç”±äºéŸ³ä¹åˆ—è¡¨éœ€è¦Fileå¯¹è±¡ï¼Œè€Œæœ¬åœ°å­˜å‚¨åªèƒ½å­˜å‚¨åŸºæœ¬æ•°æ®ç±»å‹
            // è¿™é‡Œåªæ¢å¤ä½ç½®ä¿¡æ¯ï¼Œå®é™…éŸ³é¢‘æ–‡ä»¶éœ€è¦é‡æ–°åŠ è½½
            console.log('MusicSystem: éŸ³ä¹åˆ—è¡¨æ¢å¤éœ€è¦é‡æ–°åŠ è½½æ–‡ä»¶ï¼Œæš‚æ—¶è·³è¿‡');
        } catch (error) {
            console.error('MusicSystem: æ¢å¤éŸ³ä¹åˆ—è¡¨å¤±è´¥:', error);
        }
    },
    
    // å…¨å±€å˜é‡ï¼šé˜²æ­¢é‡å¤å¤„ç†æ‹–æ‹½äº‹ä»¶
    isProcessingDrop: false,
    
    // è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶
    setupGlobalDragEvents() {
        console.log('MusicSystem: è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶');
        
        const self = this; // ä¿å­˜thiså¼•ç”¨
        
        // é€šç”¨æ‹–æ‹½å¤„ç†å‡½æ•°
        const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('MusicSystem: æ‹–æ‹½ç»è¿‡:', e.target.id || e.target.tagName);
        };
        
        const handleDrop = (e) => {
            // é˜²æ­¢é‡å¤å¤„ç†æ‹–æ‹½äº‹ä»¶
            if (self.isProcessingDrop) {
                console.log('MusicSystem: è·³è¿‡é‡å¤çš„dropäº‹ä»¶');
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            console.log('MusicSystem: æ‹–æ‹½é‡Šæ”¾:', e.target.id || e.target.tagName);
            
            try {
                self.isProcessingDrop = true;
                const files = e.dataTransfer.files;
                console.log('MusicSystem: é‡Šæ”¾æ–‡ä»¶æ•°é‡:', files.length);
                
                if (files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        console.log('MusicSystem: æ–‡ä»¶:', file.name, file.type);
                        
                        if (file.type.startsWith('audio/') || file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/i)) {
                            console.log('MusicSystem: å¤„ç†éŸ³é¢‘æ–‡ä»¶:', file.name);
                            self.handleAudioFileDrop(file, e.clientX + i * 70, e.clientY);
                        } else {
                            console.log('MusicSystem: è·³è¿‡ééŸ³é¢‘æ–‡ä»¶:', file.name);
                        }
                    }
                }
            } catch (error) {
                console.error('MusicSystem: å¤„ç†æ‹–æ‹½é‡Šæ”¾å¤±è´¥:', error);
                alert('å¤„ç†æ‹–æ‹½å¤±è´¥ï¼Œè¯·é‡è¯•');
            } finally {
                // å»¶è¿Ÿé‡ç½®ï¼Œç¡®ä¿äº‹ä»¶å¤„ç†å®Œæˆ
                setTimeout(() => {
                    self.isProcessingDrop = false;
                    console.log('MusicSystem: é‡ç½®æ‹–æ‹½å¤„ç†æ ‡å¿—');
                }, 500);
            }
        };
        
        // åœ¨å¤šä¸ªå¯èƒ½çš„å®¹å™¨å…ƒç´ ä¸Šæ·»åŠ æ‹–æ‹½äº‹ä»¶ç›‘å¬å™¨
        // è¿™æ ·å¯ä»¥ç¡®ä¿æ— è®ºç”¨æˆ·å°†æ–‡ä»¶æ‹–æ‹½åˆ°å“ªä¸ªåŒºåŸŸï¼Œéƒ½èƒ½è¢«æ­£ç¡®æ•è·
        const containers = [
            document.getElementById('viewport'),
            document.getElementById('container'),
            document.getElementById('nodes-layer'),
            document.body
        ];
        
        containers.forEach((container, index) => {
            if (container) {
                container.addEventListener('dragover', handleDragOver);
                container.addEventListener('drop', handleDrop);
                console.log(`MusicSystem: å·²æ·»åŠ ${index === 0 ? 'viewport' : index === 1 ? 'container' : index === 2 ? 'nodes-layer' : 'body'}æ‹–æ‹½äº‹ä»¶`);
            }
        });
        
        console.log('MusicSystem: å…¨å±€æ‹–æ‹½äº‹ä»¶è®¾ç½®å®Œæˆ');
    },
    
    // å¤„ç†éŸ³é¢‘æ–‡ä»¶æ‹–æ‹½
    handleAudioFileDrop(file, x, y) {
        console.log('MusicSystem: å¤„ç†éŸ³é¢‘æ–‡ä»¶:', file.name);
        
        try {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const audioUrl = event.target.result;
                    this.createAudioPlayer(audioUrl, x, y);
                } catch (error) {
                    console.error('MusicSystem: å¤„ç†éŸ³é¢‘URLå¤±è´¥:', error);
                    alert('å¤„ç†éŸ³é¢‘æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            };
            reader.onerror = (error) => {
                console.error('MusicSystem: æ–‡ä»¶è¯»å–å¤±è´¥:', error);
                alert('è¯»å–éŸ³é¢‘æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•');
            };
            reader.readAsDataURL(file);
        } catch (error) {
            console.error('MusicSystem: åˆå§‹åŒ–æ–‡ä»¶è¯»å–å¤±è´¥:', error);
            alert('åˆå§‹åŒ–æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    },
    
    // åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨
    createAudioPlayer(audioUrl, x, y) {
        console.log('MusicSystem: åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨');
        
        try {
            const playerId = 'audio-player-' + Date.now();
            const playButton = document.createElement('button');
            playButton.id = playerId;
            playButton.className = 'audio-player';
            playButton.innerHTML = 'â–¶';
            playButton.style.position = 'absolute';
            playButton.style.width = '60px';
            playButton.style.height = '60px';
            playButton.style.borderRadius = '50%';
            playButton.style.border = 'none';
            playButton.style.backgroundColor = this.getRandomColor();
            playButton.style.color = 'white';
            playButton.style.fontSize = '20px';
            playButton.style.fontWeight = 'bold';
            playButton.style.cursor = 'pointer';
            playButton.style.display = 'flex';
            playButton.style.alignItems = 'center';
            playButton.style.justifyContent = 'center';
            playButton.style.zIndex = '1000';
            
            // è®¡ç®—ä½ç½®
            const container = document.getElementById('container');
            if (container) {
                const rect = container.getBoundingClientRect();
                // è®¡ç®—ç›¸å¯¹äºcontainerçš„åæ ‡
                const containerX = x - rect.left;
                const containerY = y - rect.top;
                
                // è€ƒè™‘å½“å‰çš„ç¼©æ”¾å’Œå¹³ç§»å€¼ï¼ˆä»appå¯¹è±¡è·å–ï¼‰
                if (window.app) {
                    // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                    const worldX = (containerX - app.panX) / app.zoom;
                    const worldY = (containerY - app.panY) / app.zoom;
                    playButton.style.left = worldX + 'px';
                    playButton.style.top = worldY + 'px';
                } else {
                    // å¦‚æœappå¯¹è±¡ä¸å­˜åœ¨ï¼Œä½¿ç”¨åŸå§‹è®¡ç®—
                    playButton.style.left = containerX + 'px';
                    playButton.style.top = containerY + 'px';
                }
            } else {
                playButton.style.left = x + 'px';
                playButton.style.top = y + 'px';
            }
            
            // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
            const audioElement = document.createElement('audio');
            audioElement.src = audioUrl;
            audioElement.loop = true;
            audioElement.style.display = 'none';
            
            // æ·»åŠ åˆ°nodes-layer
            const nodesLayer = document.getElementById('nodes-layer');
            const targetContainer = nodesLayer || document.body;
            
            // ä½¿ç”¨DocumentFragmentä¼˜åŒ–DOMæ“ä½œ
            const fragment = document.createDocumentFragment();
            fragment.appendChild(playButton);
            fragment.appendChild(audioElement);
            targetContainer.appendChild(fragment);
            
            // å­˜å‚¨æ’­æ”¾å™¨ä¿¡æ¯
            const playerInfo = {
                id: playerId,
                element: playButton,
                audio: audioElement,
                playButton: playButton,
                isPlaying: false,
                currentTime: 0
            };
            this.audioPlayers.push(playerInfo);
            
            // æ’­æ”¾/æš‚åœäº‹ä»¶
            playButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleAudioPlayback(playerId);
            });
            
            // éŸ³é¢‘äº‹ä»¶
            // ç”±äºè®¾ç½®äº† loop = trueï¼Œended äº‹ä»¶ä¸ä¼šè§¦å‘ï¼Œæ‰€ä»¥ç§»é™¤è¿™ä¸ªç›‘å¬å™¨
            
            audioElement.addEventListener('timeupdate', () => {
                playerInfo.currentTime = audioElement.currentTime;
                // å®šæœŸä¿å­˜ - å‡å°‘é¢‘ç‡ï¼Œé¿å…æ€§èƒ½é—®é¢˜
                if (Math.random() < 0.01) { // 1% çš„æ¦‚ç‡ä¿å­˜
                    this.saveToLocalStorage();
                }
            });
            
            // æ‹–æ‹½åŠŸèƒ½ - å‚è€ƒscript.jsä¸­çš„èŠ‚ç‚¹æ‹–æ‹½å®ç°
            let isDragging = false;
            let startX, startY;
            
            console.log('MusicSystem: ä¸ºæ–°æ’­æ”¾å™¨æ·»åŠ æ‹–æ‹½äº‹ä»¶ç›‘å¬å™¨:', playerId);
            
            // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
            const mouseDownHandler = (e) => {
                if (e.button === 0) { // å·¦é”®
                    e.stopPropagation();
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // æ”¹å˜é¼ æ ‡æ ·å¼
                    document.body.style.cursor = 'grabbing';
                    console.log('MusicSystem: å¼€å§‹æ‹–æ‹½');
                }
            };
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            const mouseMoveHandler = (e) => {
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // è®¡ç®—ç§»åŠ¨è·ç¦»
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // è·å–å½“å‰ä½ç½®
                    const currentX = parseInt(playButton.style.left || 0);
                    const currentY = parseInt(playButton.style.top || 0);
                    
                    // è®¡ç®—æ–°ä½ç½®
                    const newX = currentX + deltaX;
                    const newY = currentY + deltaY;
                    
                    // æ›´æ–°ä½ç½®
                    playButton.style.left = newX + 'px';
                    playButton.style.top = newY + 'px';
                    
                    // æ›´æ–°èµ·å§‹ä½ç½®
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    console.log('MusicSystem: ç§»åŠ¨åˆ°ä½ç½®:', newX, newY);
                }
            };
            
            // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
            const mouseUpHandler = (e) => {
                if (isDragging) {
                    e.stopPropagation();
                    isDragging = false;
                    
                    // æ¢å¤é¼ æ ‡æ ·å¼
                    document.body.style.cursor = '';
                    
                    // ä¿å­˜æ–°ä½ç½®åˆ°æœ¬åœ°å­˜å‚¨
                    this.saveToLocalStorage();
                    console.log('MusicSystem: ç»“æŸæ‹–æ‹½ï¼Œä¿å­˜ä½ç½®');
                }
            };
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            playButton.addEventListener('mousedown', mouseDownHandler);
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            
            // å³é”®åˆ é™¤åŠŸèƒ½
            this.setupRightClickDelete(playButton, playerId, false);
            
            console.log('MusicSystem: æ’­æ”¾å™¨åˆ›å»ºæˆåŠŸ:', playerId);
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        } catch (error) {
            console.error('MusicSystem: åˆ›å»ºæ’­æ”¾å™¨å¤±è´¥:', error);
            alert('åˆ›å»ºæ’­æ”¾å™¨å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    },
    
    // åˆ‡æ¢éŸ³é¢‘æ’­æ”¾çŠ¶æ€
    toggleAudioPlayback(playerId) {
        const player = this.audioPlayers.find(p => p.id === playerId);
        if (!player) return;
        
        if (player.isPlaying) {
            player.audio.pause();
            player.playButton.innerHTML = 'â–¶';
            player.isPlaying = false;
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        } else {
            // æš‚åœå…¶ä»–æ’­æ”¾å™¨
            this.audioPlayers.forEach(p => {
                if (p.isPlaying) {
                    p.audio.pause();
                    p.playButton.innerHTML = 'â–¶';
                    p.isPlaying = false;
                }
            });
            
            // ä»ä¸Šæ¬¡ä½ç½®ç»§ç»­æ’­æ”¾
            if (player.currentTime > 0) {
                player.audio.currentTime = player.currentTime;
            }
            player.audio.play();
            player.playButton.innerHTML = 'â¸';
            player.isPlaying = true;
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        }
    },
    

    
    // åˆ›å»ºéŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹
    createMusicListNode(audioFiles, x, y) {
        console.log('MusicSystem: åˆ›å»ºéŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹');
        
        const nodeId = 'music-list-' + Date.now();
        const node = document.createElement('div');
        node.id = nodeId;
        node.className = 'node music-list-node';
        node.style.position = 'absolute';
        node.style.width = '400px';
        node.style.minHeight = '300px';
        node.style.maxHeight = '500px';
        node.style.backgroundColor = '#1e1e1e';
        node.style.border = '2px solid #444';
        node.style.borderRadius = '8px';
        node.style.display = 'flex';
        node.style.flexDirection = 'column';
        node.style.overflow = 'hidden';
        
        // è®¡ç®—ä½ç½®
        const container = document.getElementById('container');
        if (container) {
            const rect = container.getBoundingClientRect();
            node.style.left = (x - rect.left) + 'px';
            node.style.top = (y - rect.top) + 'px';
        } else {
            node.style.left = x + 'px';
            node.style.top = y + 'px';
        }
        
        // åˆ›å»ºæ ‡é¢˜æ 
        const titleBar = document.createElement('div');
        titleBar.className = 'node-header';
        titleBar.style.padding = '10px';
        titleBar.style.backgroundColor = '#2d2d2d';
        titleBar.style.display = 'flex';
        titleBar.style.alignItems = 'center';
        titleBar.style.justifyContent = 'space-between';
        
        // æ ‡é¢˜
        const title = document.createElement('div');
        title.className = 'node-title';
        title.textContent = 'éŸ³ä¹åˆ—è¡¨';
        
        // æ’­æ”¾æ¨¡å¼æŒ‰é’®ç»„
        const modeButtons = document.createElement('div');
        modeButtons.style.display = 'flex';
        modeButtons.style.gap = '5px';
        
        // å•å¾ªç¯æŒ‰é’®
        const singleLoopBtn = document.createElement('button');
        singleLoopBtn.className = 'mode-btn';
        singleLoopBtn.textContent = 'å•æ›²';
        singleLoopBtn.style.padding = '3px 8px';
        singleLoopBtn.style.border = '1px solid #444';
        singleLoopBtn.style.borderRadius = '4px';
        singleLoopBtn.style.backgroundColor = '#333';
        singleLoopBtn.style.color = '#fff';
        singleLoopBtn.style.fontSize = '12px';
        singleLoopBtn.style.cursor = 'pointer';
        
        // é¡ºåºå¾ªç¯æŒ‰é’®
        const orderLoopBtn = document.createElement('button');
        orderLoopBtn.className = 'mode-btn active';
        orderLoopBtn.textContent = 'é¡ºåº';
        orderLoopBtn.style.padding = '3px 8px';
        orderLoopBtn.style.border = '1px solid #444';
        orderLoopBtn.style.borderRadius = '4px';
        orderLoopBtn.style.backgroundColor = '#2196F3';
        orderLoopBtn.style.color = '#fff';
        orderLoopBtn.style.fontSize = '12px';
        orderLoopBtn.style.cursor = 'pointer';
        
        // éšæœºå¾ªç¯æŒ‰é’®
        const randomLoopBtn = document.createElement('button');
        randomLoopBtn.className = 'mode-btn';
        randomLoopBtn.textContent = 'éšæœº';
        randomLoopBtn.style.padding = '3px 8px';
        randomLoopBtn.style.border = '1px solid #444';
        randomLoopBtn.style.borderRadius = '4px';
        randomLoopBtn.style.backgroundColor = '#333';
        randomLoopBtn.style.color = '#fff';
        randomLoopBtn.style.fontSize = '12px';
        randomLoopBtn.style.cursor = 'pointer';
        
        // å…³é—­æŒ‰é’®
        const closeBtn = document.createElement('button');
        closeBtn.className = 'tool-icon close';
        closeBtn.textContent = 'å…³';
        closeBtn.style.width = '24px';
        closeBtn.style.height = '24px';
        closeBtn.style.display = 'flex';
        closeBtn.style.alignItems = 'center';
        closeBtn.style.justifyContent = 'center';
        closeBtn.style.borderRadius = '50%';
        closeBtn.style.backgroundColor = 'transparent';
        closeBtn.style.color = '#999';
        closeBtn.style.border = 'none';
        closeBtn.style.cursor = 'pointer';
        
        // æ·»åŠ æŒ‰é’®åˆ°æŒ‰é’®ç»„
        modeButtons.appendChild(singleLoopBtn);
        modeButtons.appendChild(orderLoopBtn);
        modeButtons.appendChild(randomLoopBtn);
        
        // æ·»åŠ å…ƒç´ åˆ°æ ‡é¢˜æ 
        titleBar.appendChild(title);
        titleBar.appendChild(modeButtons);
        titleBar.appendChild(closeBtn);
        
        // åˆ›å»ºéŸ³ä¹åˆ—è¡¨å®¹å™¨
        const listContainer = document.createElement('div');
        listContainer.className = 'music-list';
        listContainer.style.flex = '1';
        listContainer.style.padding = '10px';
        listContainer.style.overflowY = 'auto';
        
        // åˆ›å»ºéŸ³ä¹åˆ—è¡¨
        const ul = document.createElement('ul');
        ul.style.listStyle = 'none';
        ul.style.padding = '0';
        ul.style.margin = '0';
        ul.style.display = 'flex';
        ul.style.flexDirection = 'column';
        ul.style.gap = '5px';
        
        // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
        const audioElement = document.createElement('audio');
        audioElement.style.display = 'none';
        document.body.appendChild(audioElement);
        
        // éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹ä¿¡æ¯
        const listNodeInfo = {
            id: nodeId,
            element: node,
            audio: audioElement,
            audioFiles: audioFiles,
            currentIndex: -1,
            playbackMode: 'order',
            isPlaying: false,
            currentTime: 0,
            playButtons: [],
            listItems: []
        };
        
        // æ·»åŠ éŸ³ä¹æ–‡ä»¶åˆ°åˆ—è¡¨
        audioFiles.forEach((file, index) => {
            const li = document.createElement('li');
            li.className = 'music-item';
            li.style.padding = '8px';
            li.style.border = '1px solid #333';
            li.style.borderRadius = '4px';
            li.style.backgroundColor = '#1a1a1a';
            li.style.cursor = 'pointer';
            li.style.display = 'flex';
            li.style.alignItems = 'center';
            li.style.justifyContent = 'space-between';
            
            // æ–‡ä»¶å
            const fileName = document.createElement('span');
            fileName.textContent = file.name;
            
            // æ’­æ”¾æŒ‰é’®
            const playBtn = document.createElement('button');
            playBtn.className = 'play-btn';
            playBtn.textContent = 'â–¶';
            playBtn.style.width = '24px';
            playBtn.style.height = '24px';
            playBtn.style.border = 'none';
            playBtn.style.borderRadius = '4px';
            playBtn.style.backgroundColor = '#333';
            playBtn.style.color = '#fff';
            playBtn.style.cursor = 'pointer';
            
            // æ·»åŠ åˆ°æŒ‰é’®å’Œåˆ—è¡¨é¡¹æ•°ç»„
            listNodeInfo.playButtons.push(playBtn);
            listNodeInfo.listItems.push(li);
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬
            playBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.playMusicFromList(listNodeInfo, index);
            });
            
            li.addEventListener('click', () => {
                this.playMusicFromList(listNodeInfo, index);
            });
            
            // æ·»åŠ å…ƒç´ åˆ°åˆ—è¡¨é¡¹
            li.appendChild(fileName);
            li.appendChild(playBtn);
            ul.appendChild(li);
        });
        
        // æ·»åŠ åˆ—è¡¨åˆ°å®¹å™¨
        listContainer.appendChild(ul);
        
        // æ·»åŠ å…ƒç´ åˆ°èŠ‚ç‚¹
        node.appendChild(titleBar);
        node.appendChild(listContainer);
        
        // æ·»åŠ åˆ°nodes-layer
        const nodesLayer = document.getElementById('nodes-layer');
        if (nodesLayer) {
            nodesLayer.appendChild(node);
        } else {
            document.body.appendChild(node);
        }
        
        // å…³é—­æŒ‰é’®äº‹ä»¶
        closeBtn.addEventListener('click', () => {
            this.removeMusicListNode(nodeId);
        });
        
        // æ’­æ”¾æ¨¡å¼æŒ‰é’®äº‹ä»¶
        singleLoopBtn.addEventListener('click', () => {
            this.setPlaybackMode(listNodeInfo, 'single');
            singleLoopBtn.className = 'mode-btn active';
            singleLoopBtn.style.backgroundColor = '#2196F3';
            orderLoopBtn.className = 'mode-btn';
            orderLoopBtn.style.backgroundColor = '#333';
            randomLoopBtn.className = 'mode-btn';
            randomLoopBtn.style.backgroundColor = '#333';
        });
        
        orderLoopBtn.addEventListener('click', () => {
            this.setPlaybackMode(listNodeInfo, 'order');
            orderLoopBtn.className = 'mode-btn active';
            orderLoopBtn.style.backgroundColor = '#2196F3';
            singleLoopBtn.className = 'mode-btn';
            singleLoopBtn.style.backgroundColor = '#333';
            randomLoopBtn.className = 'mode-btn';
            randomLoopBtn.style.backgroundColor = '#333';
        });
        
        randomLoopBtn.addEventListener('click', () => {
            this.setPlaybackMode(listNodeInfo, 'random');
            randomLoopBtn.className = 'mode-btn active';
            randomLoopBtn.style.backgroundColor = '#2196F3';
            singleLoopBtn.className = 'mode-btn';
            singleLoopBtn.style.backgroundColor = '#333';
            orderLoopBtn.className = 'mode-btn';
            orderLoopBtn.style.backgroundColor = '#333';
        });
        
        // ç›‘å¬éŸ³é¢‘ç»“æŸäº‹ä»¶
        audioElement.addEventListener('ended', () => {
            this.handleMusicEnd(listNodeInfo);
        });
        
        // ç›‘å¬éŸ³é¢‘æ—¶é—´æ›´æ–°äº‹ä»¶
        audioElement.addEventListener('timeupdate', () => {
            listNodeInfo.currentTime = audioElement.currentTime;
            // å®šæœŸä¿å­˜
            if (Math.random() < 0.1) { // 10% çš„æ¦‚ç‡ä¿å­˜
                this.saveToLocalStorage();
            }
        });
        
        // æ·»åŠ åˆ°éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹æ•°ç»„
        this.musicListNodes.push(listNodeInfo);
        
        // è®¾ç½®å³é”®åˆ é™¤åŠŸèƒ½
        this.setupRightClickDelete(node, nodeId, true);
        
        console.log('MusicSystem: éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹åˆ›å»ºæˆåŠŸ');
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        this.saveToLocalStorage();
    },
    
    // ä»éŸ³ä¹åˆ—è¡¨æ’­æ”¾éŸ³ä¹
    playMusicFromList(listNodeInfo, index) {
        console.log('MusicSystem: ä»éŸ³ä¹åˆ—è¡¨æ’­æ”¾éŸ³ä¹ï¼Œç´¢å¼•:', index);
        
        // æš‚åœå…¶ä»–æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        this.audioPlayers.forEach(p => {
            if (p.isPlaying) {
                p.audio.pause();
                p.playButton.innerHTML = 'â–¶';
                p.isPlaying = false;
            }
        });
        
        // æš‚åœå…¶ä»–éŸ³ä¹åˆ—è¡¨
        this.musicListNodes.forEach(node => {
            if (node.id !== listNodeInfo.id && node.isPlaying) {
                node.audio.pause();
                node.isPlaying = false;
                if (node.currentIndex >= 0 && node.playButtons[node.currentIndex]) {
                    node.playButtons[node.currentIndex].textContent = 'â–¶';
                }
            }
        });
        
        const file = listNodeInfo.audioFiles[index];
        const reader = new FileReader();
        reader.onload = (event) => {
            const audioUrl = event.target.result;
            listNodeInfo.audio.src = audioUrl;
            listNodeInfo.currentIndex = index;
            
            // ä»ä¸Šæ¬¡æš‚åœçš„ä½ç½®å¼€å§‹æ’­æ”¾
            if (listNodeInfo.currentTime > 0) {
                listNodeInfo.audio.currentTime = listNodeInfo.currentTime;
            }
            
            listNodeInfo.audio.play();
            listNodeInfo.isPlaying = true;
            
            // æ›´æ–°æ’­æ”¾æŒ‰é’®çŠ¶æ€
            listNodeInfo.playButtons.forEach((btn, i) => {
                if (i === index) {
                    btn.textContent = 'â¸';
                } else {
                    btn.textContent = 'â–¶';
                }
            });
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        };
        reader.readAsDataURL(file);
    },
    
    // è®¾ç½®æ’­æ”¾æ¨¡å¼
    setPlaybackMode(listNodeInfo, mode) {
        console.log('MusicSystem: è®¾ç½®æ’­æ”¾æ¨¡å¼:', mode);
        listNodeInfo.playbackMode = mode;
    },
    
    // å¤„ç†éŸ³ä¹ç»“æŸäº‹ä»¶
    handleMusicEnd(listNodeInfo) {
        console.log('MusicSystem: éŸ³ä¹ç»“æŸï¼Œæ’­æ”¾æ¨¡å¼:', listNodeInfo.playbackMode);
        
        switch (listNodeInfo.playbackMode) {
            case 'single':
                // å•æ›²å¾ªç¯
                listNodeInfo.audio.currentTime = 0;
                listNodeInfo.audio.play();
                break;
            case 'order':
                // é¡ºåºæ’­æ”¾ä¸‹ä¸€é¦–
                if (listNodeInfo.currentIndex < listNodeInfo.audioFiles.length - 1) {
                    this.playMusicFromList(listNodeInfo, listNodeInfo.currentIndex + 1);
                } else {
                    // å›åˆ°ç¬¬ä¸€é¦–
                    this.playMusicFromList(listNodeInfo, 0);
                }
                break;
            case 'random':
                // éšæœºæ’­æ”¾
                const randomIndex = Math.floor(Math.random() * listNodeInfo.audioFiles.length);
                this.playMusicFromList(listNodeInfo, randomIndex);
                break;
        }
    },
    
    // ç§»é™¤éŸ³é¢‘æ’­æ”¾å™¨
    removeAudioPlayer(playerId) {
        console.log('MusicSystem: ç§»é™¤éŸ³é¢‘æ’­æ”¾å™¨:', playerId);
        const index = this.audioPlayers.findIndex(p => p.id === playerId);
        if (index !== -1) {
            const player = this.audioPlayers[index];
            if (player.audio) {
                player.audio.pause();
            }
            if (player.element && player.element.parentNode) {
                player.element.parentNode.removeChild(player.element);
            }
            if (player.audio && player.audio.parentNode) {
                player.audio.parentNode.removeChild(player.audio);
            }
            this.audioPlayers.splice(index, 1);
            console.log('MusicSystem: æ’­æ”¾å™¨ç§»é™¤æˆåŠŸ');
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        }
    },
    
    // ç§»é™¤éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹
    removeMusicListNode(nodeId) {
        console.log('MusicSystem: ç§»é™¤éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹:', nodeId);
        const index = this.musicListNodes.findIndex(n => n.id === nodeId);
        if (index !== -1) {
            const nodeInfo = this.musicListNodes[index];
            if (nodeInfo.audio) {
                nodeInfo.audio.pause();
                if (nodeInfo.audio.parentNode) {
                    nodeInfo.audio.parentNode.removeChild(nodeInfo.audio);
                }
            }
            if (nodeInfo.element && nodeInfo.element.parentNode) {
                nodeInfo.element.parentNode.removeChild(nodeInfo.element);
            }
            this.musicListNodes.splice(index, 1);
            console.log('MusicSystem: éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹ç§»é™¤æˆåŠŸ');
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        }
    },
    
    // è®¾ç½®å³é”®åˆ é™¤åŠŸèƒ½
    setupRightClickDelete(element, id, isListNode = false) {
        let isDragging = false;
        let startX, startY;
        
        element.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        element.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    if (isListNode) {
                        this.removeMusicListNode(id);
                    } else {
                        this.removeAudioPlayer(id);
                    }
                    isDragging = false;
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }
};

// å¯¼å‡ºæ¨¡å—
window.MusicSystem = MusicSystem;

// video.js - è§†é¢‘æ’­æ”¾æ¨¡å—
const VideoSystem = {
    // è§†é¢‘æ’­æ”¾å™¨åˆ—è¡¨
    videoPlayers: [],
    // æ˜¯å¦å…è®¸å¤šä¸ªè§†é¢‘åŒæ—¶æ’­æ”¾
    allowMultiplePlayback: false,
    
    // ç”Ÿæˆéšæœºé¢œè‰²ï¼ˆä½¿ç”¨HSLæ¨¡å¼ï¼‰
    getRandomColor() {
        const hue = Math.floor(Math.random() * 360);
        const saturation = 70 + Math.floor(Math.random() * 30);
        const lightness = 50 + Math.floor(Math.random() * 10);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    },
    
    // åˆå§‹åŒ–è§†é¢‘ç³»ç»Ÿ
    init() {
        console.log('=== VideoSystem: åˆå§‹åŒ–è§†é¢‘ç³»ç»Ÿ ===');
        this.loadFromLocalStorage();
        this.initDragAndDrop();
    },
    
    // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
    initDragAndDrop() {
        console.log('=== VideoSystem: åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½ ===');
        
        // è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶
        this.setupGlobalDragEvents();
    },
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    saveToLocalStorage() {
        // é¿å…é¢‘ç¹ä¿å­˜ï¼Œä½¿ç”¨é˜²æŠ–
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        
        this.saveTimeout = setTimeout(() => {
            console.log('VideoSystem: ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
            
            try {
                // æ£€æŸ¥è§†é¢‘æ’­æ”¾å™¨åˆ—è¡¨
                if (this.videoPlayers.length === 0) {
                    console.log('VideoSystem: æ²¡æœ‰è§†é¢‘æ’­æ”¾å™¨éœ€è¦ä¿å­˜');
                    return;
                }
                
                console.log('VideoSystem: è§†é¢‘æ’­æ”¾å™¨æ•°é‡:', this.videoPlayers.length);
                
                // ä¿å­˜è§†é¢‘æ’­æ”¾å™¨
                const videoPlayersData = this.videoPlayers.map(player => {
                    // ç¡®ä¿è·å–æœ‰æ•ˆçš„ä½ç½®å€¼
                    const left = player.element.style.left || '0px';
                    const top = player.element.style.top || '0px';
                    return {
                        id: player.id,
                        videoUrl: player.video.src,
                        x: parseInt(left) || 0,
                        y: parseInt(top) || 0,
                        currentTime: player.currentTime,
                        isPlaying: player.isPlaying,
                        backgroundColor: player.element.style.backgroundColor || this.getRandomColor()
                    };
                });
                
                // æ£€æŸ¥æœ¬åœ°å­˜å‚¨å¤§å°
                const videoPlayersString = JSON.stringify(videoPlayersData);
                const totalSize = videoPlayersString.length;
                
                console.log('VideoSystem: è§†é¢‘æ’­æ”¾å™¨æ•°æ®å¤§å°:', totalSize, 'å­—èŠ‚');
                
                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ¬åœ°å­˜å‚¨é™åˆ¶ï¼ˆçº¦5MBï¼‰
                if (totalSize > 5 * 1024 * 1024) {
                    console.warn('VideoSystem: æœ¬åœ°å­˜å‚¨æ•°æ®è¶…è¿‡5MBé™åˆ¶ï¼Œå¯èƒ½æ— æ³•ä¿å­˜');
                    // åªä¿å­˜æœ€è¿‘çš„å‡ ä¸ªæ’­æ”¾å™¨
                    const trimmedPlayers = videoPlayersData.slice(-5); // åªä¿å­˜æœ€è¿‘çš„5ä¸ª
                    localStorage.setItem('videoSystemVideoPlayers', JSON.stringify(trimmedPlayers));
                } else {
                    localStorage.setItem('videoSystemVideoPlayers', videoPlayersString);
                }
                
                console.log('VideoSystem: ä¿å­˜æˆåŠŸ');
                
            } catch (error) {
                console.error('VideoSystem: ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
                console.error('VideoSystem: é”™è¯¯è¯¦æƒ…:', error.message);
            }
        }, 100); // 100msé˜²æŠ–
    },
    
    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
    loadFromLocalStorage() {
        console.log('VideoSystem: ä»æœ¬åœ°å­˜å‚¨åŠ è½½');
        
        try {
            // åŠ è½½allowMultiplePlaybackè®¾ç½®
            const savedAllowMultiple = localStorage.getItem('videoSystemAllowMultiple');
            if (savedAllowMultiple !== null) {
                this.allowMultiplePlayback = JSON.parse(savedAllowMultiple);
                console.log('VideoSystem: åŠ è½½allowMultiplePlaybackè®¾ç½®:', this.allowMultiplePlayback);
            }
            
            // æ¸…ç©ºç°æœ‰æ’­æ”¾å™¨ï¼Œé¿å…é‡å¤
            this.clearAllPlayers();
            
            // æ£€æŸ¥æœ¬åœ°å­˜å‚¨æ˜¯å¦æœ‰æ•°æ®
            const videoPlayersData = localStorage.getItem('videoSystemVideoPlayers');
            console.log('VideoSystem: æœ¬åœ°å­˜å‚¨çŠ¶æ€ - è§†é¢‘æ’­æ”¾å™¨:', videoPlayersData ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            
            // åŠ è½½è§†é¢‘æ’­æ”¾å™¨
            if (videoPlayersData) {
                console.log('VideoSystem: æ‰¾åˆ°è§†é¢‘æ’­æ”¾å™¨æ•°æ®ï¼Œé•¿åº¦:', videoPlayersData.length, 'å­—èŠ‚');
                try {
                    const players = JSON.parse(videoPlayersData);
                    console.log('VideoSystem: è§£æå‡ºè§†é¢‘æ’­æ”¾å™¨æ•°é‡:', players.length);
                    
                    if (players.length === 0) {
                        console.log('VideoSystem: æ²¡æœ‰è§†é¢‘æ’­æ”¾å™¨æ•°æ®');
                        return;
                    }
                    
                    // æ‰¹é‡åˆ›å»ºDOMå…ƒç´ ï¼Œå‡å°‘é‡æ’
                    const fragment = document.createDocumentFragment();
                    const nodesLayer = document.getElementById('nodes-layer');
                    const container = nodesLayer || document.body;
                    
                    players.forEach((playerData, index) => {
                        console.log('VideoSystem: åŠ è½½æ’­æ”¾å™¨', index + 1, ':', playerData.id, 'ä½ç½®:', playerData.x, playerData.y);
                        this.restoreVideoPlayer(playerData, fragment);
                    });
                    
                    // ä¸€æ¬¡æ€§æ·»åŠ åˆ°DOM
                    if (fragment.childNodes.length > 0) {
                        container.appendChild(fragment);
                    }
                    
                } catch (parseError) {
                    console.error('VideoSystem: è§£æè§†é¢‘æ’­æ”¾å™¨æ•°æ®å¤±è´¥:', parseError);
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem('videoSystemVideoPlayers');
                    console.log('VideoSystem: å·²æ¸…é™¤æŸåçš„è§†é¢‘æ’­æ”¾å™¨æ•°æ®');
                }
            } else {
                console.log('VideoSystem: æœ¬åœ°å­˜å‚¨ä¸­æ²¡æœ‰è§†é¢‘æ’­æ”¾å™¨æ•°æ®');
            }
            
            console.log('VideoSystem: åŠ è½½å®Œæˆï¼Œå½“å‰è§†é¢‘æ’­æ”¾å™¨æ•°é‡:', this.videoPlayers.length);
            
            // æ ¹æ®å¤šè§†é¢‘æ’­æ”¾çŠ¶æ€è®¾ç½®è§†é¢‘é™éŸ³çŠ¶æ€
            if (this.allowMultiplePlayback) {
                this.videoPlayers.forEach(p => {
                    p.video.muted = true;
                });
                console.log('VideoSystem: å¤šè§†é¢‘æ’­æ”¾å·²å¼€å¯ï¼Œå·²è®¾ç½®æ‰€æœ‰è§†é¢‘ä¸ºé™éŸ³');
            }
        } catch (error) {
            console.error('VideoSystem: ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¤±è´¥:', error);
            console.error('VideoSystem: é”™è¯¯è¯¦æƒ…:', error.message);
        }
    },
    
    // åˆ‡æ¢å…è®¸å¤šä¸ªè§†é¢‘åŒæ—¶æ’­æ”¾çš„çŠ¶æ€
    toggleMultiplePlayback() {
        this.allowMultiplePlayback = !this.allowMultiplePlayback;
        localStorage.setItem('videoSystemAllowMultiple', JSON.stringify(this.allowMultiplePlayback));
        console.log('VideoSystem: åˆ‡æ¢allowMultiplePlaybackçŠ¶æ€:', this.allowMultiplePlayback);
        
        if (this.allowMultiplePlayback) {
            // å¼€å¯å¤šè§†é¢‘æ’­æ”¾æ—¶ï¼Œå…³é—­æ‰€æœ‰è§†é¢‘å£°éŸ³
            this.videoPlayers.forEach(p => {
                p.video.muted = true;
            });
            console.log('VideoSystem: å¼€å¯å¤šè§†é¢‘æ’­æ”¾ï¼Œå·²å…³é—­æ‰€æœ‰è§†é¢‘å£°éŸ³');
        } else {
            // å…³é—­å¤šè§†é¢‘æ’­æ”¾æ—¶ï¼Œæš‚åœæ‰€æœ‰è§†é¢‘å¹¶å–æ¶ˆé™éŸ³
            this.videoPlayers.forEach(p => {
                if (p.isPlaying) {
                    p.video.pause();
                    p.isPlaying = false;
                }
                // å–æ¶ˆé™éŸ³ï¼Œå…è®¸åç»­æ’­æ”¾æ—¶æœ‰å£°éŸ³
                p.video.muted = false;
            });
            this.saveToLocalStorage();
            console.log('VideoSystem: å…³é—­å¤šè§†é¢‘æ’­æ”¾ï¼Œå·²æš‚åœæ‰€æœ‰è§†é¢‘å¹¶å…è®¸å£°éŸ³');
        }
        
        return this.allowMultiplePlayback;
    },
    
    // è·å–å…è®¸å¤šä¸ªè§†é¢‘åŒæ—¶æ’­æ”¾çš„çŠ¶æ€
    getAllowMultiplePlayback() {
        return this.allowMultiplePlayback;
    },
    
    // æš‚åœæ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„è§†é¢‘
    pauseAllVideos() {
        this.videoPlayers.forEach(p => {
            if (p.isPlaying) {
                p.video.pause();
                p.isPlaying = false;
            }
        });
        this.saveToLocalStorage();
        console.log('VideoSystem: æš‚åœæ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„è§†é¢‘');
    },
    
    // æ¸…ç©ºæ‰€æœ‰æ’­æ”¾å™¨
    clearAllPlayers() {
        console.log('VideoSystem: æ¸…ç©ºæ‰€æœ‰æ’­æ”¾å™¨');
        
        // ç§»é™¤DOMå…ƒç´ 
        this.videoPlayers.forEach(player => {
            if (player.element && player.element.parentNode) {
                player.element.parentNode.removeChild(player.element);
            }
            if (player.video && player.video.parentNode) {
                player.video.parentNode.removeChild(player.video);
            }
        });
        
        // æ¸…ç©ºæ•°ç»„
        this.videoPlayers = [];
    },
    
    // æ¢å¤è§†é¢‘æ’­æ”¾å™¨
    restoreVideoPlayer(playerData, fragment) {
        console.log('VideoSystem: æ¢å¤è§†é¢‘æ’­æ”¾å™¨:', playerData.id);
        
        try {
            const playerId = playerData.id;
            const videoContainer = document.createElement('div');
            videoContainer.id = playerId;
            videoContainer.className = 'video-player';
            
            // æ‰¹é‡è®¾ç½®æ ·å¼ï¼Œå‡å°‘é‡æ’
            Object.assign(videoContainer.style, {
                position: 'absolute',
                width: '200px',
                height: '160px',
                borderRadius: '8px',
                border: 'none',
                backgroundColor: playerData.backgroundColor || this.getRandomColor(),
                color: 'white',
                cursor: 'pointer',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: '1000',
                overflow: 'hidden',
                left: playerData.x + 'px',
                top: playerData.y + 'px'
            });
            
            // åˆ›å»ºè§†é¢‘å…ƒç´ 
            const videoElement = document.createElement('video');
            videoElement.src = playerData.videoUrl;
            videoElement.loop = true; // é»˜è®¤æ— é™å¾ªç¯æ’­æ”¾
            videoElement.style.width = '100%';
            videoElement.style.height = '100%';
            videoElement.style.objectFit = 'contain';
            videoElement.style.backgroundColor = 'black';
            
            // ç›‘å¬è§†é¢‘å…ƒæ•°æ®åŠ è½½ï¼Œè°ƒæ•´æ’­æ”¾å™¨å¤§å°
            videoElement.addEventListener('loadedmetadata', () => {
                // è·å–è§†é¢‘çš„å®é™…å®½é«˜å’Œæ¯”ä¾‹
                const videoWidth = videoElement.videoWidth;
                const videoHeight = videoElement.videoHeight;
                const aspectRatio = videoWidth / videoHeight;
                
                // è®¡ç®—åˆé€‚çš„æ’­æ”¾å™¨å°ºå¯¸
                // åŸºäºè§†é¢‘åŸå§‹å¤§å°ï¼Œä½†è®¾ç½®åˆç†çš„é™åˆ¶
                const maxDimension = 800; // æœ€å¤§å®½åº¦æˆ–é«˜åº¦
                const minDimension = 200; // æœ€å°å®½åº¦æˆ–é«˜åº¦
                
                let finalWidth, finalVideoHeight;
                
                if (videoWidth > videoHeight) {
                    // æ¨ªå±è§†é¢‘
                    finalWidth = Math.max(minDimension, Math.min(maxDimension, videoWidth));
                    finalVideoHeight = finalWidth / aspectRatio;
                } else {
                    // ç«–å±è§†é¢‘
                    finalVideoHeight = Math.max(minDimension, Math.min(maxDimension, videoHeight));
                    finalWidth = finalVideoHeight * aspectRatio;
                }
                
                // ç¡®ä¿å°ºå¯¸åœ¨åˆç†èŒƒå›´å†…
                finalWidth = Math.max(minDimension, Math.min(maxDimension, finalWidth));
                finalVideoHeight = Math.max(minDimension, Math.min(maxDimension, finalVideoHeight));
                
                // è°ƒæ•´æ’­æ”¾å™¨å®¹å™¨å¤§å°
                videoContainer.style.width = finalWidth + 'px';
                videoContainer.style.height = finalVideoHeight + 'px';
                
                // è°ƒæ•´è§†é¢‘å…ƒç´ å¤§å°
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                
                console.log(`VideoSystem: è§†é¢‘å¤§å°è°ƒæ•´ - åŸå§‹: ${videoWidth}x${videoHeight}, æ¯”ä¾‹: ${aspectRatio.toFixed(2)}, è°ƒæ•´å: ${Math.round(finalWidth)}x${Math.round(finalVideoHeight)}`);
            });
            
            // æ·»åŠ æ‹–æ‹½åŠŸèƒ½åˆ°è§†é¢‘å®¹å™¨
            let isDragging = false;
            let startX, startY;
            let startLeft, startTop;
            
            videoContainer.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                if (e.button === 0) { // åªå¤„ç†å·¦é”®
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(videoContainer.style.left) || 0;
                    startTop = parseInt(videoContainer.style.top) || 0;
                    videoContainer.style.zIndex = '2000'; // æ‹–æ‹½æ—¶ç½®äºé¡¶å±‚
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    // è€ƒè™‘ç¼©æ”¾å’Œå¹³ç§»
                    const container = document.getElementById('container');
                    if (container && window.app) {
                        // é¼ æ ‡ç§»åŠ¨çš„è·ç¦»å·²ç»æ˜¯ç›¸å¯¹äºå®¹å™¨çš„ï¼Œåªéœ€è¦è€ƒè™‘ç¼©æ”¾å› å­
                        const worldX = dx / app.zoom;
                        const worldY = dy / app.zoom;
                        
                        videoContainer.style.left = (startLeft + worldX) + 'px';
                        videoContainer.style.top = (startTop + worldY) + 'px';
                    } else {
                        videoContainer.style.left = (startLeft + dx) + 'px';
                        videoContainer.style.top = (startTop + dy) + 'px';
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    videoContainer.style.zIndex = '1000'; // æ¢å¤æ­£å¸¸å±‚çº§
                    // ä¿å­˜çŠ¶æ€
                    this.saveToLocalStorage();
                }
            });
            
            // æ·»åŠ åˆ°å®¹å™¨
            videoContainer.appendChild(videoElement);
            
            // æ·»åŠ åˆ°DocumentFragmentæˆ–ç›´æ¥æ·»åŠ åˆ°DOM
            if (fragment) {
                fragment.appendChild(videoContainer);
            } else {
                // æ·»åŠ åˆ°nodes-layer
                const nodesLayer = document.getElementById('nodes-layer');
                if (nodesLayer) {
                    nodesLayer.appendChild(videoContainer);
                } else {
                    document.body.appendChild(videoContainer);
                }
            }
            
            // å­˜å‚¨æ’­æ”¾å™¨ä¿¡æ¯
            const playerInfo = {
                id: playerId,
                element: videoContainer,
                video: videoElement,
                isPlaying: playerData.isPlaying,
                currentTime: playerData.currentTime
            };
            this.videoPlayers.push(playerInfo);
            
            // æ’­æ”¾/æš‚åœäº‹ä»¶
            videoContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleVideoPlayback(playerId);
            });
            
            // è§†é¢‘äº‹ä»¶
            videoElement.addEventListener('timeupdate', () => {
                playerInfo.currentTime = videoElement.currentTime;
                // å®šæœŸä¿å­˜ - å‡å°‘é¢‘ç‡ï¼Œé¿å…æ€§èƒ½é—®é¢˜
                if (Math.random() < 0.01) { // 1% çš„æ¦‚ç‡ä¿å­˜
                    this.saveToLocalStorage();
                }
            });
            
            // ç›‘å¬è§†é¢‘ç»“æŸäº‹ä»¶
            videoElement.addEventListener('ended', () => {
                playerInfo.isPlaying = false;
                console.log(`VideoSystem: è§†é¢‘æ’­æ”¾ç»“æŸ - ${playerId}`);
                // ä¿å­˜çŠ¶æ€
                this.saveToLocalStorage();
            });
            
            // å³é”®åˆ é™¤åŠŸèƒ½
            this.setupRightClickDelete(videoContainer, playerId);
            
            console.log('VideoSystem: æ’­æ”¾å™¨æ¢å¤æˆåŠŸ:', playerId);
        } catch (error) {
            console.error('VideoSystem: æ¢å¤æ’­æ”¾å™¨å¤±è´¥:', error);
        }
    },
    
    // è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶
    setupGlobalDragEvents() {
        console.log('VideoSystem: è®¾ç½®å…¨å±€æ‹–æ‹½äº‹ä»¶');
        
        const self = this; // ä¿å­˜thiså¼•ç”¨
        
        // é€šç”¨æ‹–æ‹½å¤„ç†å‡½æ•°
        const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('VideoSystem: æ‹–æ‹½ç»è¿‡:', e.target.id || e.target.tagName);
        };
        
        const handleDrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('VideoSystem: æ‹–æ‹½é‡Šæ”¾:', e.target.id || e.target.tagName);
            
            try {
                const files = e.dataTransfer.files;
                console.log('VideoSystem: é‡Šæ”¾æ–‡ä»¶æ•°é‡:', files.length);
                
                if (files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        console.log('VideoSystem: æ–‡ä»¶:', file.name, file.type);
                        
                        if (file.type.startsWith('video/') || file.name.toLowerCase().match(/\.(mp4|webm|ogg|avi|mov|wmv|flv|mkv)$/i)) {
                            console.log('VideoSystem: å¤„ç†è§†é¢‘æ–‡ä»¶:', file.name);
                            self.handleVideoFileDrop(file, e.clientX + i * 320, e.clientY);
                        } else {
                            console.log('VideoSystem: è·³è¿‡éè§†é¢‘æ–‡ä»¶:', file.name);
                        }
                    }
                }
            } catch (error) {
                console.error('VideoSystem: å¤„ç†æ‹–æ‹½é‡Šæ”¾å¤±è´¥:', error);
            }
        };
        
        // åœ¨viewportä¸Šæ·»åŠ æ‹–æ‹½äº‹ä»¶
        const viewport = document.getElementById('viewport');
        if (viewport) {
            viewport.addEventListener('dragover', handleDragOver);
            viewport.addEventListener('drop', handleDrop);
            console.log('VideoSystem: å·²æ·»åŠ viewportæ‹–æ‹½äº‹ä»¶');
        }
        
        // åœ¨containerä¸Šæ·»åŠ æ‹–æ‹½äº‹ä»¶
        const container = document.getElementById('container');
        if (container) {
            container.addEventListener('dragover', handleDragOver);
            container.addEventListener('drop', handleDrop);
            console.log('VideoSystem: å·²æ·»åŠ containeræ‹–æ‹½äº‹ä»¶');
        }
        
        // åœ¨nodes-layerä¸Šæ·»åŠ æ‹–æ‹½äº‹ä»¶
        const nodesLayer = document.getElementById('nodes-layer');
        if (nodesLayer) {
            nodesLayer.addEventListener('dragover', handleDragOver);
            nodesLayer.addEventListener('drop', handleDrop);
            console.log('VideoSystem: å·²æ·»åŠ nodes-layeræ‹–æ‹½äº‹ä»¶');
        }
        
        // åœ¨bodyä¸Šæ·»åŠ æ‹–æ‹½äº‹ä»¶ä½œä¸ºåå¤‡
        document.body.addEventListener('dragover', handleDragOver);
        document.body.addEventListener('drop', handleDrop);
        console.log('VideoSystem: å·²æ·»åŠ bodyæ‹–æ‹½äº‹ä»¶');
    },
    
    // å¤„ç†è§†é¢‘æ–‡ä»¶æ‹–æ‹½
    handleVideoFileDrop(file, x, y) {
        console.log('VideoSystem: å¤„ç†è§†é¢‘æ–‡ä»¶:', file.name);
        
        try {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const videoUrl = event.target.result;
                    this.createVideoPlayer(videoUrl, x, y);
                } catch (error) {
                    console.error('VideoSystem: å¤„ç†è§†é¢‘URLå¤±è´¥:', error);
                }
            };
            reader.onerror = (error) => {
                console.error('VideoSystem: æ–‡ä»¶è¯»å–å¤±è´¥:', error);
            };
            reader.readAsDataURL(file);
        } catch (error) {
            console.error('VideoSystem: åˆå§‹åŒ–æ–‡ä»¶è¯»å–å¤±è´¥:', error);
        }
    },
    
    // åˆ›å»ºè§†é¢‘æ’­æ”¾å™¨
    createVideoPlayer(videoUrl, x, y) {
        console.log('VideoSystem: åˆ›å»ºè§†é¢‘æ’­æ”¾å™¨');
        
        try {
            const playerId = 'video-player-' + Date.now();
            const videoContainer = document.createElement('div');
            videoContainer.id = playerId;
            videoContainer.className = 'video-player';
            
            // æ‰¹é‡è®¾ç½®æ ·å¼
            Object.assign(videoContainer.style, {
                position: 'absolute',
                width: '200px',
                height: '160px',
                borderRadius: '8px',
                border: 'none',
                backgroundColor: this.getRandomColor(),
                color: 'white',
                cursor: 'pointer',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: '1000',
                overflow: 'hidden'
            });
            
            // è®¡ç®—ä½ç½®
            const container = document.getElementById('container');
            if (container) {
                const rect = container.getBoundingClientRect();
                // è®¡ç®—ç›¸å¯¹äºcontainerçš„åæ ‡
                const containerX = x - rect.left;
                const containerY = y - rect.top;
                
                // è€ƒè™‘å½“å‰çš„ç¼©æ”¾å’Œå¹³ç§»å€¼ï¼ˆä»appå¯¹è±¡è·å–ï¼‰
                if (window.app) {
                    // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                    const worldX = (containerX - app.panX) / app.zoom;
                    const worldY = (containerY - app.panY) / app.zoom;
                    videoContainer.style.left = worldX + 'px';
                    videoContainer.style.top = worldY + 'px';
                    console.log(`VideoSystem: ä½ç½®è®¡ç®— - é¼ æ ‡: ${x},${y}, å®¹å™¨: ${containerX},${containerY}, ä¸–ç•Œ: ${worldX},${worldY}, ç¼©æ”¾: ${app.zoom}, å¹³ç§»: ${app.panX},${app.panY}`);
                } else {
                    // å¦‚æœappå¯¹è±¡ä¸å­˜åœ¨ï¼Œä½¿ç”¨åŸå§‹è®¡ç®—
                    videoContainer.style.left = containerX + 'px';
                    videoContainer.style.top = containerY + 'px';
                    console.log(`VideoSystem: ä½ç½®è®¡ç®— - é¼ æ ‡: ${x},${y}, å®¹å™¨: ${containerX},${containerY}`);
                }
            } else {
                videoContainer.style.left = x + 'px';
                videoContainer.style.top = y + 'px';
                console.log(`VideoSystem: ä½ç½®è®¡ç®— - é¼ æ ‡: ${x},${y}`);
            }
            
            // åˆ›å»ºè§†é¢‘å…ƒç´ 
            const videoElement = document.createElement('video');
            videoElement.src = videoUrl;
            videoElement.loop = true; // é»˜è®¤æ— é™å¾ªç¯æ’­æ”¾
            // æ ¹æ®å¤šè§†é¢‘æ’­æ”¾çŠ¶æ€è®¾ç½®é™éŸ³
            videoElement.muted = this.allowMultiplePlayback;
            videoElement.style.width = '100%';
            videoElement.style.height = '100%';
            videoElement.style.objectFit = 'contain';
            videoElement.style.backgroundColor = 'black';
            
            // ç›‘å¬è§†é¢‘å…ƒæ•°æ®åŠ è½½ï¼Œè°ƒæ•´æ’­æ”¾å™¨å¤§å°
            videoElement.addEventListener('loadedmetadata', () => {
                // è·å–è§†é¢‘çš„å®é™…å®½é«˜å’Œæ¯”ä¾‹
                const videoWidth = videoElement.videoWidth;
                const videoHeight = videoElement.videoHeight;
                const aspectRatio = videoWidth / videoHeight;
                
                // è®¡ç®—åˆé€‚çš„æ’­æ”¾å™¨å°ºå¯¸
                // åŸºäºè§†é¢‘åŸå§‹å¤§å°ï¼Œä½†è®¾ç½®åˆç†çš„é™åˆ¶
                const maxDimension = 800; // æœ€å¤§å®½åº¦æˆ–é«˜åº¦
                const minDimension = 200; // æœ€å°å®½åº¦æˆ–é«˜åº¦
                
                let finalWidth, finalVideoHeight;
                
                if (videoWidth > videoHeight) {
                    // æ¨ªå±è§†é¢‘
                    finalWidth = Math.max(minDimension, Math.min(maxDimension, videoWidth));
                    finalVideoHeight = finalWidth / aspectRatio;
                } else {
                    // ç«–å±è§†é¢‘
                    finalVideoHeight = Math.max(minDimension, Math.min(maxDimension, videoHeight));
                    finalWidth = finalVideoHeight * aspectRatio;
                }
                
                // ç¡®ä¿å°ºå¯¸åœ¨åˆç†èŒƒå›´å†…
                finalWidth = Math.max(minDimension, Math.min(maxDimension, finalWidth));
                finalVideoHeight = Math.max(minDimension, Math.min(maxDimension, finalVideoHeight));
                
                // è°ƒæ•´æ’­æ”¾å™¨å®¹å™¨å¤§å°
                videoContainer.style.width = finalWidth + 'px';
                videoContainer.style.height = finalVideoHeight + 'px';
                
                // è°ƒæ•´è§†é¢‘å…ƒç´ å¤§å°
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                
                console.log(`VideoSystem: è§†é¢‘å¤§å°è°ƒæ•´ - åŸå§‹: ${videoWidth}x${videoHeight}, æ¯”ä¾‹: ${aspectRatio.toFixed(2)}, è°ƒæ•´å: ${Math.round(finalWidth)}x${Math.round(finalVideoHeight)}`);
            });
            
            // æ·»åŠ æ‹–æ‹½åŠŸèƒ½åˆ°è§†é¢‘å®¹å™¨
            let isDragging = false;
            let startX, startY;
            let startLeft, startTop;
            
            videoContainer.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                if (e.button === 0) { // åªå¤„ç†å·¦é”®
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(videoContainer.style.left) || 0;
                    startTop = parseInt(videoContainer.style.top) || 0;
                    videoContainer.style.zIndex = '2000'; // æ‹–æ‹½æ—¶ç½®äºé¡¶å±‚
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    // è€ƒè™‘ç¼©æ”¾å’Œå¹³ç§»
                    const container = document.getElementById('container');
                    if (container && window.app) {
                        // é¼ æ ‡ç§»åŠ¨çš„è·ç¦»å·²ç»æ˜¯ç›¸å¯¹äºå®¹å™¨çš„ï¼Œåªéœ€è¦è€ƒè™‘ç¼©æ”¾å› å­
                        const worldX = dx / app.zoom;
                        const worldY = dy / app.zoom;
                        
                        videoContainer.style.left = (startLeft + worldX) + 'px';
                        videoContainer.style.top = (startTop + worldY) + 'px';
                    } else {
                        videoContainer.style.left = (startLeft + dx) + 'px';
                        videoContainer.style.top = (startTop + dy) + 'px';
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    videoContainer.style.zIndex = '1000'; // æ¢å¤æ­£å¸¸å±‚çº§
                    // ä¿å­˜çŠ¶æ€
                    this.saveToLocalStorage();
                }
            });
            
            // æ·»åŠ åˆ°å®¹å™¨
            videoContainer.appendChild(videoElement);
            
            // æ·»åŠ åˆ°nodes-layer
            const nodesLayer = document.getElementById('nodes-layer');
            const targetContainer = nodesLayer || document.body;
            targetContainer.appendChild(videoContainer);
            
            // å­˜å‚¨æ’­æ”¾å™¨ä¿¡æ¯
            const playerInfo = {
                id: playerId,
                element: videoContainer,
                video: videoElement,
                isPlaying: false,
                currentTime: 0
            };
            this.videoPlayers.push(playerInfo);
            
            // æ’­æ”¾/æš‚åœäº‹ä»¶
            videoContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleVideoPlayback(playerId);
            });
            
            // è§†é¢‘äº‹ä»¶
            videoElement.addEventListener('timeupdate', () => {
                playerInfo.currentTime = videoElement.currentTime;
                // å®šæœŸä¿å­˜ - å‡å°‘é¢‘ç‡ï¼Œé¿å…æ€§èƒ½é—®é¢˜
                if (Math.random() < 0.01) { // 1% çš„æ¦‚ç‡ä¿å­˜
                    this.saveToLocalStorage();
                }
            });
            
            // ç›‘å¬è§†é¢‘ç»“æŸäº‹ä»¶
            videoElement.addEventListener('ended', () => {
                playerInfo.isPlaying = false;
                console.log(`VideoSystem: è§†é¢‘æ’­æ”¾ç»“æŸ - ${playerId}`);
                // ä¿å­˜çŠ¶æ€
                this.saveToLocalStorage();
            });
            
            // å³é”®åˆ é™¤åŠŸèƒ½
            this.setupRightClickDelete(videoContainer, playerId);
            
            console.log('VideoSystem: æ’­æ”¾å™¨åˆ›å»ºæˆåŠŸ:', playerId);
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        } catch (error) {
            console.error('VideoSystem: åˆ›å»ºæ’­æ”¾å™¨å¤±è´¥:', error);
        }
    },
    
    // åˆ‡æ¢è§†é¢‘æ’­æ”¾çŠ¶æ€
    toggleVideoPlayback(playerId) {
        const player = this.videoPlayers.find(p => p.id === playerId);
        if (!player) return;
        
        // åªæœ‰åœ¨ä¸å…è®¸å¤šä¸ªè§†é¢‘åŒæ—¶æ’­æ”¾æ—¶ï¼Œæ‰æš‚åœå…¶ä»–è§†é¢‘
        if (!this.allowMultiplePlayback) {
            this.videoPlayers.forEach(p => {
                if (p.id !== playerId && p.isPlaying) {
                    p.video.pause();
                    p.isPlaying = false;
                }
            });
        }
        
        if (player.isPlaying) {
            player.video.pause();
            player.isPlaying = false;
        } else {
            // ä»ä¸Šæ¬¡ä½ç½®ç»§ç»­æ’­æ”¾
            if (player.currentTime > 0) {
                player.video.currentTime = player.currentTime;
            }
            player.video.play();
            player.isPlaying = true;
        }
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        this.saveToLocalStorage();
    },
    
    // ç§»é™¤è§†é¢‘æ’­æ”¾å™¨
    removeVideoPlayer(playerId) {
        console.log('VideoSystem: ç§»é™¤è§†é¢‘æ’­æ”¾å™¨:', playerId);
        const index = this.videoPlayers.findIndex(p => p.id === playerId);
        if (index !== -1) {
            const player = this.videoPlayers[index];
            if (player.video) {
                player.video.pause();
            }
            if (player.element && player.element.parentNode) {
                player.element.parentNode.removeChild(player.element);
            }
            if (player.video && player.video.parentNode) {
                player.video.parentNode.removeChild(player.video);
            }
            this.videoPlayers.splice(index, 1);
            console.log('VideoSystem: æ’­æ”¾å™¨ç§»é™¤æˆåŠŸ');
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            this.saveToLocalStorage();
        }
    },
    
    // è®¾ç½®å³é”®åˆ é™¤åŠŸèƒ½
    setupRightClickDelete(element, id) {
        let isDragging = false;
        let startX, startY;
        
        element.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        element.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    this.removeVideoPlayer(id);
                    isDragging = false;
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }
};

// å¯¼å‡ºæ¨¡å—
window.VideoSystem = VideoSystem;


// å·¥å…·å‡½æ•°ï¼šäº‹ä»¶èŠ‚æµ - ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æµç•…åº¦
function throttle(func, limit) {
    let inThrottle;
    let lastCallTime = 0;
    let lastResult;
    
    return function() {
        const context = this;
        const args = arguments;
        const now = Date.now();
        
        // å¦‚æœè·ç¦»ä¸Šæ¬¡è°ƒç”¨å·²ç»è¶…è¿‡äº†é™åˆ¶æ—¶é—´ï¼Œç›´æ¥æ‰§è¡Œ
        if (now - lastCallTime >= limit) {
            lastCallTime = now;
            lastResult = func.apply(context, args);
        } else if (!inThrottle) {
            // å¦åˆ™ï¼Œä½¿ç”¨requestAnimationFrameåœ¨ä¸‹ä¸€å¸§æ‰§è¡Œ
            inThrottle = true;
            requestAnimationFrame(() => {
                inThrottle = false;
                lastCallTime = Date.now();
                lastResult = func.apply(context, args);
            });
        }
        
        return lastResult;
    };
}

// å·¥å…·å‡½æ•°ï¼šäº‹ä»¶é˜²æŠ–
function debounce(func, wait) {
    let timeout;
    return function() {
        const args = arguments;
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}

// å››å‰æ ‘èŠ‚ç‚¹ç±»ï¼Œç”¨äºä¼˜åŒ–ç©ºé—´æŸ¥è¯¢
class QuadTreeNode {
    constructor(bounds) {
        this.bounds = bounds; // {x, y, width, height}
        this.nodes = []; // å½“å‰èŠ‚ç‚¹åŒ…å«çš„å¯¹è±¡
        this.children = null; // å››ä¸ªå­èŠ‚ç‚¹
        this.maxNodes = 8; // æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåŒ…å«çš„å¯¹è±¡æ•°é‡
    }
    
    // æ’å…¥å¯¹è±¡
    insert(obj) {
        // å¦‚æœå·²ç»æœ‰å­èŠ‚ç‚¹ï¼Œå°†å¯¹è±¡æ’å…¥åˆ°å¯¹åº”çš„å­èŠ‚ç‚¹ä¸­
        if (this.children) {
            const index = this.getChildIndex(obj);
            if (index !== -1) {
                this.children[index].insert(obj);
                return;
            }
        }
        
        // å°†å¯¹è±¡æ·»åŠ åˆ°å½“å‰èŠ‚ç‚¹
        this.nodes.push(obj);
        
        // å¦‚æœèŠ‚ç‚¹æ•°é‡è¶…è¿‡æœ€å¤§å€¼ï¼Œåˆ†è£‚èŠ‚ç‚¹
        if (this.nodes.length > this.maxNodes && !this.children) {
            this.split();
        }
    }
    
    // åˆ†è£‚èŠ‚ç‚¹ä¸ºå››ä¸ªå­èŠ‚ç‚¹
    split() {
        const {x, y, width, height} = this.bounds;
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        
        this.children = [
            new QuadTreeNode({x: x, y: y, width: halfWidth, height: halfHeight}), // å·¦ä¸Š
            new QuadTreeNode({x: x + halfWidth, y: y, width: halfWidth, height: halfHeight}), // å³ä¸Š
            new QuadTreeNode({x: x, y: y + halfHeight, width: halfWidth, height: halfHeight}), // å·¦ä¸‹
            new QuadTreeNode({x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight}) // å³ä¸‹
        ];
        
        // å°†å½“å‰èŠ‚ç‚¹çš„å¯¹è±¡é‡æ–°åˆ†é…åˆ°å­èŠ‚ç‚¹ä¸­
        for (let i = this.nodes.length - 1; i >= 0; i--) {
            const obj = this.nodes[i];
            const index = this.getChildIndex(obj);
            if (index !== -1) {
                this.children[index].insert(obj);
                this.nodes.splice(i, 1);
            }
        }
    }
    
    // è·å–å¯¹è±¡åº”è¯¥æ’å…¥åˆ°å“ªä¸ªå­èŠ‚ç‚¹
    getChildIndex(obj) {
        const {x, y, width, height} = this.bounds;
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        
        // æ£€æŸ¥å¯¹è±¡æ˜¯å¦å®Œå…¨åŒ…å«åœ¨æŸä¸ªå­èŠ‚ç‚¹ä¸­
        const leftHalf = obj.x + obj.w <= x + halfWidth;
        const rightHalf = obj.x >= x + halfWidth;
        const topHalf = obj.y + obj.h <= y + halfHeight;
        const bottomHalf = obj.y >= y + halfHeight;
        
        if (leftHalf && topHalf) return 0; // å·¦ä¸Š
        if (rightHalf && topHalf) return 1; // å³ä¸Š
        if (leftHalf && bottomHalf) return 2; // å·¦ä¸‹
        if (rightHalf && bottomHalf) return 3; // å³ä¸‹
        
        return -1; // å¯¹è±¡è·¨è¶Šå¤šä¸ªå­èŠ‚ç‚¹
    }
    
    // æŸ¥è¯¢æŒ‡å®šèŒƒå›´å†…çš„æ‰€æœ‰å¯¹è±¡
    query(range, found = []) {
        // æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦ä¸æŸ¥è¯¢èŒƒå›´ç›¸äº¤
        if (!this.isIntersecting(range)) {
            return found;
        }
        
        // å°†å½“å‰èŠ‚ç‚¹ä¸­ä¸æŸ¥è¯¢èŒƒå›´ç›¸äº¤çš„å¯¹è±¡æ·»åŠ åˆ°ç»“æœä¸­
        for (const obj of this.nodes) {
            if (this.isObjIntersecting(obj, range)) {
                found.push(obj);
            }
        }
        
        // å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œé€’å½’æŸ¥è¯¢å­èŠ‚ç‚¹
        if (this.children) {
            for (const child of this.children) {
                child.query(range, found);
            }
        }
        
        return found;
    }
    
    // æ£€æŸ¥å½“å‰èŠ‚ç‚¹çš„è¾¹ç•Œæ˜¯å¦ä¸æŸ¥è¯¢èŒƒå›´ç›¸äº¤
    isIntersecting(range) {
        const {x, y, width, height} = this.bounds;
        return !(x + width < range.left || x > range.right || y + height < range.top || y > range.bottom);
    }
    
    // æ£€æŸ¥å¯¹è±¡æ˜¯å¦ä¸æŸ¥è¯¢èŒƒå›´ç›¸äº¤
    isObjIntersecting(obj, range) {
        return !(obj.x + obj.w < range.left || obj.x > range.right || obj.y + obj.h < range.top || obj.y > range.bottom);
    }
    
    // æ¸…ç©ºå››å‰æ ‘
    clear() {
        this.nodes = [];
        if (this.children) {
            for (const child of this.children) {
                child.clear();
            }
            this.children = null;
        }
    }
    
    // é‡æ–°æ„å»ºå››å‰æ ‘
    rebuild(nodes) {
        this.clear();
        for (const node of nodes) {
            this.insert(node);
        }
    }
}

const app = {
    nodes: [], conns: [], zoom: 1, panX: 0, panY: 0,
    isPanning: false, isCutting: false, activeConn: null, dragNode: null,
    nodeMap: new Map(), // èŠ‚ç‚¹IDåˆ°èŠ‚ç‚¹å¯¹è±¡çš„æ˜ å°„è¡¨ï¼Œç”¨äºä¼˜åŒ–æŸ¥æ‰¾
    connMap: new Map(), // é‚»æ¥è¡¨ï¼Œç”¨äºä¼˜åŒ–è¿æ¥æŸ¥è¯¢ï¼šnodeId -> [targetNodeIds]
    quadTree: null, // å››å‰æ ‘ï¼Œç”¨äºä¼˜åŒ–ç©ºé—´æŸ¥è¯¢
    lastExportTime: 0, // ä¸Šæ¬¡å¯¼å‡ºæ—¶é—´ï¼Œç”¨äºé™åˆ¶å¯¼å‡ºé—´éš”
    visibleNodesUpdateRequested: false, // å¯è§èŠ‚ç‚¹æ›´æ–°è¯·æ±‚æ ‡è®°ï¼Œç”¨äºä¼˜åŒ–æ¸²æŸ“
    minimapCache: null, // å°åœ°å›¾ç¼“å­˜ï¼Œç”¨äºå‡å°‘é‡ç»˜
    minimapDirty: true, // å°åœ°å›¾æ˜¯å¦éœ€è¦æ›´æ–°çš„æ ‡è®°
    lastMinimapUpdate: 0, // ä¸Šæ¬¡æ›´æ–°å°åœ°å›¾çš„æ—¶é—´æˆ³
    minimapUpdateInterval: 100, // å°åœ°å›¾æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    useCanvasRendering: false, // æ˜¯å¦ä½¿ç”¨Canvasæ¸²æŸ“èŠ‚ç‚¹ï¼ˆæš‚æ—¶ç¦ç”¨ï¼Œç¡®ä¿åŠŸèƒ½å¯ç”¨ï¼‰
    nodesCanvas: null, // Canvaså…ƒç´ 
    nodesCtx: null, // Canvasä¸Šä¸‹æ–‡
    canvasDirty: true, // Canvasæ˜¯å¦éœ€è¦æ›´æ–°çš„æ ‡è®°
    lastCanvasUpdate: 0, // ä¸Šæ¬¡æ›´æ–°Canvasçš„æ—¶é—´æˆ³
    canvasUpdateInterval: 16, // Canvasæ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼Œçº¦60fpsï¼‰
    
    // æ€§èƒ½ç›‘æ§ç›¸å…³
    performance: {
        fps: 60,
        frameCount: 0,
        lastFpsUpdate: 0,
        renderTime: 0,
        lastRenderTime: 0,
        visibleNodes: 0
    },

    //--------------------åˆå§‹åŒ–åº”ç”¨
    init() {
        this.vp = document.getElementById('viewport');
        this.ct = document.getElementById('container');
        this.svgCanvas = document.getElementById('svg-canvas');
        this.svgGroup = document.getElementById('conns-group');
        this.laser = document.getElementById('laser-path');
        this.layer = document.getElementById('nodes-layer');
        this.miniCanvas = document.getElementById('minimap-canvas');
        this.miniView = document.getElementById('minimap-viewport');
        
        // åˆå§‹åŒ–CanvasèŠ‚ç‚¹æ¸²æŸ“
        this.nodesCanvas = document.getElementById('nodes-canvas');
        this.nodesCtx = this.nodesCanvas.getContext('2d');
        // è®¾ç½®Canvaså¤§å°ä¸è§†å£ä¸€è‡´
        this.resizeCanvas();
        // ç›‘å¬è§†å£å¤§å°å˜åŒ–ï¼Œè°ƒæ•´Canvaså¤§å°
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // åˆå§‹åŒ–å››å‰æ ‘ï¼Œè®¾ç½®è¾ƒå¤§çš„åˆå§‹è¾¹ç•Œ
        this.quadTree = new QuadTreeNode({x: -100000, y: -100000, width: 200000, height: 200000});

        // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
        AudioSystem.initAudio();
        
        // åˆå§‹åŒ–éŸ³ä¹ç³»ç»Ÿ
        if (window.MusicSystem) {
            MusicSystem.initDragAndDrop();
        }

        // åˆå§‹åŒ–ç»˜ç”»åŠŸèƒ½ - ä¼ å…¥ this.vp å’Œ this (app)
        DrawingManager.initDrawing(this.vp, this);

        // åˆå§‹åŒ–ç‰¹æ•ˆç”»å¸ƒ
        FXManager.init(this);  // æ­£ç¡®ï¼šFXManager å’Œ init

        // åˆå§‹åŒ–å­˜å‚¨ç³»ç»Ÿ
        StorageSystem.init(this, DrawingManager, window.imageHandler);

        // åŠ è½½ä¿å­˜çš„çŠ¶æ€
        StorageSystem.load();

        this.setupEvents();
        this.updateMinimap();
        this.updateVisibleNodes(); // åˆå§‹åŒ–å¯è§èŠ‚ç‚¹æ¸²æŸ“

        // åˆå§‹åŒ–ç»˜ç”»å·¥å…·çŠ¶æ€
        DrawingManager.currentTool = null;
        this.vp.style.cursor = 'grab';
        
        // åªæœ‰åœ¨å¯ç”¨Canvasæ¸²æŸ“æ—¶æ‰å¼€å§‹Canvasæ¸²æŸ“å¾ªç¯
        if (this.useCanvasRendering) {
            this.startCanvasRenderLoop();
        }
    },
    
    // è°ƒæ•´Canvaså¤§å°
    resizeCanvas() {
        this.nodesCanvas.width = this.vp.clientWidth;
        this.nodesCanvas.height = this.vp.clientHeight;
        this.canvasDirty = true;
    },
    
    // åæ ‡è½¬æ¢ï¼šå°†èŠ‚ç‚¹åæ ‡è½¬ä¸ºå±å¹•åæ ‡ç”¨äºç‰¹æ•ˆæ˜¾ç¤º
    toScreen(x, y) {
        return { x: x * this.zoom + this.panX, y: y * this.zoom + this.panY };
    },

    canPerformNodeOperation() {
        // å¦‚æœå½“å‰æœ‰æ¿€æ´»çš„ç»˜ç”»å·¥å…·ï¼Œä¸èƒ½è¿›è¡ŒèŠ‚ç‚¹æ“ä½œ
        return !DrawingManager.currentTool;
    },

    setupEvents() {
        // åŒå‡»ç©ºç”»å¸ƒåˆ›å»ºèŠ‚ç‚¹
        this.vp.ondblclick = e => {
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨ç”»å¸ƒä¸Šï¼ˆä¸æ˜¯èŠ‚ç‚¹æˆ–å…¶ä»–å…ƒç´ ï¼‰
            if (e.target === this.vp || e.target === this.ct || e.target.id === 'svg-canvas') {
                e.preventDefault();
                // åªæœ‰åœ¨æ²¡æœ‰æ¿€æ´»ç»˜ç”»å·¥å…·æ—¶æ‰èƒ½åˆ›å»ºèŠ‚ç‚¹
                if (!DrawingManager.currentTool) {
                    this.addNewNode();
                }
            }
        };

        // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
        this.vp.onmousedown = e => {
            // åªæœ‰åœ¨ç‰¹å®šæ¡ä»¶ä¸‹æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
            if (e.button === 0 && e.target === this.vp) {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©

                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ç»˜ç”»å·¥å…·
                const isDrawingTool = DrawingManager.currentTool === 'brush' ||
                    DrawingManager.currentTool === 'eraser';

                if (isDrawingTool) {
                    // å¼€å§‹ç»˜ç”»æˆ–æ“¦é™¤
                    const rect = this.ct.getBoundingClientRect();
                    const mx = (e.clientX - rect.left) / this.zoom;
                    const my = (e.clientY - rect.top) / this.zoom;
                    DrawingManager.startDrawing(mx, my);
                } else {
                    // å¦åˆ™è¿›å…¥æ‹–æ‹½æ¨¡å¼ï¼ˆè§†å›¾å¹³ç§»ï¼‰
                    this.isPanning = true;
                }
            }
            if (e.button === 2) {
                e.preventDefault(); // é˜»æ­¢å³é”®èœå•
                this.isCutting = true;
                this.cutPath = [];
            }
        };

        // å®šä½åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        const locateBtn = document.getElementById('locate-first-node');
        if (locateBtn) {
            locateBtn.onclick = () => {
                if (this.nodes.length === 0) {
                    alert('æ²¡æœ‰å¯å®šä½çš„èŠ‚ç‚¹');
                    return;
                }

                // è·å–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
                const firstNode = this.nodes[0];

                // è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ‡
                const nodeCenterX = firstNode.x + firstNode.w / 2;
                const nodeCenterY = firstNode.y + firstNode.h / 2;

                // è®¡ç®—è§†å›¾ä¸­å¿ƒç‚¹åœ¨å±å¹•ä¸Šçš„åæ ‡
                const viewportCenterX = this.vp.clientWidth / 2;
                const viewportCenterY = this.vp.clientHeight / 2;

                // è®¡ç®—ç›®æ ‡å¹³ç§»å€¼ï¼Œç¡®ä¿èŠ‚ç‚¹å±…ä¸­æ˜¾ç¤º
                const targetPanX = viewportCenterX - (nodeCenterX * this.zoom);
                const targetPanY = viewportCenterY - (nodeCenterY * this.zoom);

                // å®ç°å¹³æ»‘ç§»åŠ¨æ•ˆæœ
                this.smoothPanTo(targetPanX, targetPanY);
            };
        }

        // çª—å£å¤§å°å˜åŒ–æ—¶ï¼Œè°ƒæ•´é•œå¤´ä½ç½®ä»¥ä¿æŒå½“å‰è§†å›¾ä¸­å¿ƒ
        window.addEventListener('resize', debounce(() => {
            // è°ƒæ•´Canvaså¤§å°
            this.resizeCanvas();
            
            if (this.nodes.length > 0) {
                // é‡æ–°è®¡ç®—å½“å‰è§†å›¾ä¸­å¿ƒç‚¹å¯¹åº”çš„ä¸–ç•Œåæ ‡
                const currentCenterX = (-this.panX / this.zoom) + (this.vp.clientWidth / 2) / this.zoom;
                const currentCenterY = (-this.panY / this.zoom) + (this.vp.clientHeight / 2) / this.zoom;

                // è®¡ç®—æ–°çš„å¹³ç§»å€¼ï¼Œä¿æŒå½“å‰è§†å›¾ä¸­å¿ƒ
                const newViewportCenterX = this.vp.clientWidth / 2;
                const newViewportCenterY = this.vp.clientHeight / 2;

                this.panX = newViewportCenterX - (currentCenterX * this.zoom);
                this.panY = newViewportCenterY - (currentCenterY * this.zoom);

                this.updateTransform();
                this.updateMinimap();
            }
        }, 100));

        // ä¼˜åŒ–é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†ï¼Œä½¿ç”¨requestAnimationFrameæå‡æµç•…åº¦
        let isDraggingNode = false;
        let dragFrameRequested = false;

        const handleDragUpdate = () => {
            if (this.dragNode) {
                const node = this.dragNode;
                this.syncNodeUI(node);
                // æ‹–åŠ¨è¿‡ç¨‹ä¸­åªæ›´æ–°ä¸å½“å‰èŠ‚ç‚¹ç›¸å…³çš„è¿æ¥çº¿ï¼Œä¸æ›´æ–°å°åœ°å›¾
                this.renderConns(null, node.id);
            }
            dragFrameRequested = false;
        };

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç† - ä½¿ç”¨èŠ‚æµä¼˜åŒ–
        window.onmousemove = throttle(e => {
            const rect = this.ct.getBoundingClientRect();
            const mx = (e.clientX - rect.left) / this.zoom;
            const my = (e.clientY - rect.top) / this.zoom;

            if (this.isPanning || this.dragNode) {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©
            }

            // é¦–å…ˆå¤„ç†ç»˜ç”»
            if (DrawingManager.isDrawing || DrawingManager.isErasing) {
                // ç»˜åˆ¶æˆ–æ“¦é™¤
                DrawingManager.draw(mx, my);
                e.preventDefault(); // é˜»æ­¢å…¶ä»–è¡Œä¸º
                return; // ç›´æ¥è¿”å›ï¼Œä¸å¤„ç†å…¶ä»–é€»è¾‘
            }

            // åªæœ‰å½“ä¸æ˜¯ç»˜ç”»æ¨¡å¼æ—¶ï¼Œæ‰å¤„ç†å…¶ä»–åŠŸèƒ½
            if (this.isPanning) {
                e.preventDefault();
                this.panX += e.movementX;
                this.panY += e.movementY;
                this.updateTransform();
                this.updateVisibleNodes(); // å¹³ç§»åæ›´æ–°å¯è§èŠ‚ç‚¹
            }
            else if (this.dragNode) {
                // è®¡ç®—æ–°ä½ç½® - ç§»é™¤ç”»å¸ƒå¤§å°é™åˆ¶ï¼Œå…è®¸èŠ‚ç‚¹åœ¨ä»»æ„ä½ç½®ç§»åŠ¨
                let newX = this.dragNode.x + e.movementX / this.zoom;
                let newY = this.dragNode.y + e.movementY / this.zoom;

                // ç›´æ¥è®¾ç½®æ–°ä½ç½®ï¼Œä¸é™åˆ¶èŒƒå›´
                this.dragNode.x = newX;
                this.dragNode.y = newY;

                // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ‹–åŠ¨åŠ¨ç”»
                if (!dragFrameRequested) {
                    requestAnimationFrame(handleDragUpdate);
                    dragFrameRequested = true;
                }
            }
            else if (this.activeConn) {
                this.renderConns({ x: mx, y: my });
            }
            else if (this.isCutting) {
                this.drawLaser(mx, my);
            }
        }, 16); // çº¦60fps

        // é¼ æ ‡æ¾å¼€äº‹ä»¶å¤„ç†
        window.onmouseup = e => {
            if (this.activeConn) {
                const rect = this.ct.getBoundingClientRect();
                const mx = (e.clientX - rect.left) / this.zoom;
                const my = (e.clientY - rect.top) / this.zoom;
                const target = this.nodes.find(n => n.id !== this.activeConn.from && mx >= n.x && mx <= n.x + n.w && my >= n.y && my <= n.y + n.h);
                if (target) {
                    // ä¸å…è®¸è¿æ¥åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé˜²æ­¢æ­»å¾ªç¯
                    const targetIndex = this.nodes.findIndex(n => n.id === target.id);
                    if (targetIndex !== 0) {
                        if (!this.conns.find(c => c.from === this.activeConn.from && c.to === target.id)) {
                            this.addConnection(this.activeConn.from, target.id);
                            AudioSystem.playConnectionSound();
                            FXManager.spawn(e.clientX, e.clientY, '#00ff00'); // è¿çº¿æˆåŠŸç‰¹æ•ˆ - ç»¿è‰²
                        }
                    }
                } else {
                    const w = 380, h = 180;
                    // ä¸é™åˆ¶èŒƒå›´ï¼Œå…è®¸èŠ‚ç‚¹åœ¨ä»»æ„ä½ç½®åˆ›å»º
                    let pos = {
                        x: mx - w / 2,
                        y: my - h / 2
                    };

                    // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰èŠ‚ç‚¹é‡å 
                    let overlap = false;
                    for (const node of this.nodes) {
                        if (this.isOverlap(pos.x, pos.y, w, h, node.x, node.y, node.w, node.h)) {
                            overlap = true;
                            break;
                        }
                    }

                    // å¦‚æœé‡å ï¼Œä½¿ç”¨findNonOverlapPos
                    if (overlap) {
                        pos = this.findNonOverlapPos(w, h);
                    }

                    const newId = Date.now();
                    this.createNode(newId, pos.x, pos.y, w, h, `${this.nodes.length + 1}`, "\n".repeat(5));
                    this.addConnection(this.activeConn.from, newId);
                    AudioSystem.playConnectionSound();

                    // ç›´æ¥åœ¨é¼ æ ‡ä½ç½®æ˜¾ç¤ºç‰¹æ•ˆ
                    FXManager.spawn(e.clientX, e.clientY, '#00ff00'); // æ‹–æ‹½æ–°å»ºç‰¹æ•ˆ - ç»¿è‰²

                    // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè‡ªåŠ¨ç§»åŠ¨è§†å›¾åˆ°èŠ‚ç‚¹ä½ç½®ï¼Œè®©èŠ‚ç‚¹æ˜¾ç¤ºåœ¨ä¸­å¤®
                    if (this.nodes.length === 1) {
                        const node = this.nodes[0];
                        // è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ‡
                        const nodeCenterX = node.x + node.w / 2;
                        const nodeCenterY = node.y + node.h / 2;

                        // è®¡ç®—è§†å›¾ä¸­å¿ƒç‚¹åœ¨å±å¹•ä¸Šçš„åæ ‡
                        const viewportCenterX = this.vp.clientWidth / 2;
                        const viewportCenterY = this.vp.clientHeight / 2;

                        // è®¡ç®—ç›®æ ‡å¹³ç§»å€¼ï¼Œç¡®ä¿èŠ‚ç‚¹å±…ä¸­æ˜¾ç¤º
                        const targetPanX = viewportCenterX - (nodeCenterX * this.zoom);
                        const targetPanY = viewportCenterY - (nodeCenterY * this.zoom);

                        // ä½¿ç”¨å¹³æ»‘ç§»åŠ¨æ•ˆæœ
                        this.smoothPanTo(targetPanX, targetPanY);
                    }
                }
            }

            this.isPanning = false;
            this.dragNode = null;
            this.activeConn = null;
            this.isCutting = false;

            // ç»“æŸç»˜ç”»
            DrawingManager.endDrawing();

            this.laser.setAttribute('d', '');
            this.save();
            this.renderConns();
            this.updateMinimap(); // æ‹–åŠ¨ç»“æŸåæ›´æ–°å°åœ°å›¾
            this.updateVisibleNodes(); // æ‹–åŠ¨ç»“æŸåæ›´æ–°å¯è§èŠ‚ç‚¹
        };

        // é¼ æ ‡æ»šè½®äº‹ä»¶å¤„ç† - ä½¿ç”¨èŠ‚æµä¼˜åŒ–
        this.vp.onwheel = throttle(e => {
            e.preventDefault();

            // è·å–é¼ æ ‡åœ¨è§†å£ä¸­çš„ç›¸å¯¹ä½ç½®
            const rect = this.vp.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // è®¡ç®—é¼ æ ‡åœ¨ä¸–ç•Œåæ ‡ä¸­çš„ä½ç½®
            const worldX = (mouseX - this.panX) / this.zoom;
            const worldY = (mouseY - this.panY) / this.zoom;

            // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
            const newZoom = Math.min(Math.max(0.1, this.zoom * (e.deltaY > 0 ? 0.9 : 1.1)), 3);

            // è°ƒæ•´å¹³ç§»é‡ï¼Œä¿æŒé¼ æ ‡ä½ç½®ä¸å˜
            this.panX = mouseX - worldX * newZoom;
            this.panY = mouseY - worldY * newZoom;

            // æ›´æ–°ç¼©æ”¾æ¯”ä¾‹
            this.zoom = newZoom;

            // åº”ç”¨å˜æ¢
            this.updateTransform();
            this.updateVisibleNodes(); // ç¼©æ”¾åæ›´æ–°å¯è§èŠ‚ç‚¹
        }, 16); // çº¦60fps
    },

    //--------------------å°åœ°å›¾æ›´æ–°
    updateMinimap() {
        // åªæœ‰å½“å°åœ°å›¾éœ€è¦æ›´æ–°ä¸”è·ç¦»ä¸Šæ¬¡æ›´æ–°è¶…è¿‡æŒ‡å®šé—´éš”æ—¶æ‰é‡ç»˜
        const now = Date.now();
        if (!this.minimapDirty && now - this.lastMinimapUpdate < this.minimapUpdateInterval) {
            // åªæ›´æ–°è§†å›¾åŒºåŸŸä½ç½®ï¼Œä¸é‡ç»˜æ•´ä¸ªå°åœ°å›¾
            this.updateMinimapViewport();
            return;
        }
        
        const ctx = this.miniCanvas.getContext('2d');
        this.miniCanvas.width = 150; this.miniCanvas.height = 150;
        ctx.clearRect(0, 0, 150, 150);
        
        if (this.nodes.length === 0) return;
        
        // è®¡ç®—èŠ‚ç‚¹è¾¹ç•Œ
        const minX = Math.min(...this.nodes.map(n => n.x)) - 500;
        const minY = Math.min(...this.nodes.map(n => n.y)) - 500;
        const maxX = Math.max(...this.nodes.map(n => n.x + n.w)) + 500;
        const maxY = Math.max(...this.nodes.map(n => n.y + n.h)) + 500;
        const rangeX = maxX - minX, rangeY = maxY - minY;
        const scale = Math.min(150 / rangeX, 150 / rangeY);
        
        // ä½¿ç”¨ç‚¹è¡¨ç¤ºæ‰€æœ‰èŠ‚ç‚¹
        ctx.fillStyle = "rgba(150, 150, 150, 0.8)";
        this.nodes.forEach(n => {
            const x = (n.x + n.w / 2 - minX) * scale;
            const y = (n.y + n.h / 2 - minY) * scale;
            ctx.beginPath();
            ctx.arc(x, y, 1, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // æ›´æ–°å°åœ°å›¾ç¼“å­˜å’ŒçŠ¶æ€
        this.minimapCache = { minX, minY, scale };
        this.minimapDirty = false;
        this.lastMinimapUpdate = now;
        
        // æ›´æ–°è§†å›¾åŒºåŸŸä½ç½®
        this.updateMinimapViewport();
    },
    
    // æ›´æ–°å°åœ°å›¾è§†å›¾åŒºåŸŸä½ç½®ï¼ˆä¸é‡ç»˜æ•´ä¸ªå°åœ°å›¾ï¼‰
    updateMinimapViewport() {
        if (!this.minimapCache) return;
        
        const { minX, minY, scale } = this.minimapCache;
        const vw = this.vp.clientWidth / this.zoom, vh = this.vp.clientHeight / this.zoom;
        const vx = (-this.panX / this.zoom) - minX, vy = (-this.panY / this.zoom) - minY;
        
        // ç¡®ä¿å°åœ°å›¾ä¸­çš„è§†å›¾åŒºåŸŸæ˜¯åœ†å½¢ï¼Œå–å®½é«˜ä¸­çš„è¾ƒå°å€¼ä½œä¸ºç›´å¾„
        const viewSize = Math.min(vw, vh);
        const viewDisplaySize = viewSize * scale;
        
        this.miniView.style.width = viewDisplaySize + 'px';
        this.miniView.style.height = viewDisplaySize + 'px';
        
        // è°ƒæ•´ä½ç½®ï¼Œä½¿åœ†å½¢å±…ä¸­æ˜¾ç¤º
        const offsetX = ((vw - viewSize) / 2) * scale;
        const offsetY = ((vh - viewSize) / 2) * scale;
        
        this.miniView.style.left = (vx * scale + offsetX) + 'px';
        this.miniView.style.top = (vy * scale + offsetY) + 'px';
    },
    
    // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
    markMinimapDirty() {
        this.minimapDirty = true;
    },
    
    // æ ‡è®°Canvaséœ€è¦æ›´æ–°
    markCanvasDirty() {
        this.canvasDirty = true;
    },
    
    // å¼€å§‹Canvasæ¸²æŸ“å¾ªç¯
    startCanvasRenderLoop() {
        const renderLoop = () => {
            const now = Date.now();
            
            // æ›´æ–°FPS
            this.performance.frameCount++;
            if (now - this.performance.lastFpsUpdate >= 1000) {
                this.performance.fps = Math.round((this.performance.frameCount * 1000) / (now - this.performance.lastFpsUpdate));
                this.performance.lastFpsUpdate = now;
                this.performance.frameCount = 0;
            }
            
            if (this.canvasDirty) {
                const startTime = performance.now();
                this.renderCanvas();
                const endTime = performance.now();
                
                this.performance.lastRenderTime = Math.round(endTime - startTime);
                this.canvasDirty = false;
                this.lastCanvasUpdate = now;
            }
            
            // æ›´æ–°æ€§èƒ½ç›‘æ§UI
            this.updatePerformanceUI();
            
            requestAnimationFrame(renderLoop);
        };
        renderLoop();
    },
    
    // æ¸²æŸ“Canvaså†…å®¹
    renderCanvas() {
        if (!this.useCanvasRendering) return;
        
        const ctx = this.nodesCtx;
        const canvas = this.nodesCanvas;
        
        // æ¸…ç©ºCanvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // è·å–å¯è§èŠ‚ç‚¹
        const visibleBounds = this.getVisibleBounds();
        const visibleNodes = this.quadTree.query(visibleBounds);
        
        // æ›´æ–°å¯è§èŠ‚ç‚¹æ•°é‡
        this.performance.visibleNodes = visibleNodes.length;
        
        // æ¸²æŸ“å¯è§èŠ‚ç‚¹
        visibleNodes.forEach(node => {
            this.renderNodeCanvas(node);
        });
    },
    
    // æ›´æ–°æ€§èƒ½ç›‘æ§UI
    updatePerformanceUI() {
        // æ›´æ–°èŠ‚ç‚¹æ•°é‡
        const nodeCountEl = document.getElementById('node-count');
        if (nodeCountEl) {
            nodeCountEl.textContent = this.nodes.length;
        }
        
        // æ›´æ–°å¯è§èŠ‚ç‚¹æ•°é‡
        const visibleNodeCountEl = document.getElementById('visible-node-count');
        if (visibleNodeCountEl) {
            visibleNodeCountEl.textContent = this.performance.visibleNodes;
        }
        
        // æ›´æ–°FPS
        const fpsEl = document.getElementById('fps');
        if (fpsEl) {
            fpsEl.textContent = this.performance.fps;
        }
        
        // æ›´æ–°æ¸²æŸ“æ—¶é—´
        const renderTimeEl = document.getElementById('render-time');
        if (renderTimeEl) {
            renderTimeEl.textContent = `${this.performance.lastRenderTime}ms`;
        }
        
        // æ›´æ–°æ¸²æŸ“æ¨¡å¼
        const renderModeEl = document.getElementById('render-mode');
        if (renderModeEl) {
            renderModeEl.textContent = this.useCanvasRendering ? 'Canvas' : 'DOM';
        }
    },
    
    // åœ¨Canvasä¸Šæ¸²æŸ“å•ä¸ªèŠ‚ç‚¹
    renderNodeCanvas(node) {
        if (!this.useCanvasRendering) return;
        
        const ctx = this.nodesCtx;
        
        // ç»˜åˆ¶èŠ‚ç‚¹èƒŒæ™¯
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(node.x, node.y, node.w, node.h);
        
        // ç»˜åˆ¶èŠ‚ç‚¹è¾¹æ¡†
        ctx.strokeStyle = node.isActive ? '#00ff00' : '#444';
        ctx.lineWidth = 2;
        ctx.strokeRect(node.x, node.y, node.w, node.h);
        
        // ç»˜åˆ¶èŠ‚ç‚¹æ ‡é¢˜æ 
        ctx.fillStyle = '#2d2d2d';
        ctx.fillRect(node.x, node.y, node.w, 38);
        
        // ç»˜åˆ¶èŠ‚ç‚¹æ ‡é¢˜æ–‡å­—
        ctx.fillStyle = '#9cdcfe';
        ctx.font = 'bold 12px Consolas';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.name, node.x + 8, node.y + 19);
        
        // ç»˜åˆ¶èŠ‚ç‚¹åæ ‡
        ctx.fillStyle = '#888';
        ctx.font = '11px Consolas';
        ctx.fillText(`(${Math.round(node.x)}, ${Math.round(node.y)})`, node.x + 40, node.y + 19);
        
        // ç»˜åˆ¶ç«¯å£
        // è¾“å…¥ç«¯å£ - å·¦ä¾§ä¸­å¿ƒç‚¹çš„å°åœ†
        ctx.fillStyle = '#aaa';
        ctx.beginPath();
        ctx.arc(node.x, node.y + node.h / 2, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // è¾“å‡ºç«¯å£ - å³ä¾§çš„é•¿æ¡
        ctx.fillStyle = '#444';
        ctx.fillRect(node.x + node.w, node.y, 8, node.h);
    },

    //--------------------æ¿€å…‰åˆ‡å‰²
    drawLaser(x, y) {
        this.cutPath.push({ x, y }); if (this.cutPath.length > 10) this.cutPath.shift();
        this.laser.setAttribute('d', this.cutPath.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' '));
        if (this.cutPath.length > 1) {
            const p1 = this.cutPath[this.cutPath.length - 2], p2 = { x, y };
            const oldLen = this.conns.length;
            
            // æ‰¾å‡ºéœ€è¦åˆ é™¤çš„è¿æ¥
            const connsToDelete = [];
            this.conns.forEach(c => {
                const n1 = this.nodes.find(n => n.id === c.from), n2 = this.nodes.find(n => n.id === c.to);
                if (n1 && n2 && this.checkLineIntersect(p1, p2, this.getOut(n1), this.getIn(n2))) {
                    connsToDelete.push(c);
                }
            });
            
            // åˆ é™¤è¿™äº›è¿æ¥ï¼ŒåŒæ—¶æ›´æ–°é‚»æ¥è¡¨
            connsToDelete.forEach(c => {
                this.removeConnection(c.from, c.to);
            });
            
            // å¦‚æœæœ‰è¿æ¥è¢«æ–­å¼€ï¼Œæ’­æ”¾æ–­å¼€éŸ³æ•ˆ
            if (this.conns.length < oldLen) {
                this.playDisconnectSound();
            }
            const hit = this.nodes.find(n => x >= n.x && x <= n.x + n.w && y >= n.y && y <= n.y + n.h);
            if (hit) this.removeNode(hit.id);

            // å¤„ç†å›¾ç‰‡çš„æ¿€å…‰åˆ‡å‰²
            if (window.imageHandler && window.imageHandler.images) {
                // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ä¸å›¾ç‰‡ç›¸äº¤
                const imagesToDelete = [];
                for (const image of window.imageHandler.images) {
                    // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ç©¿è¿‡å›¾ç‰‡åŒºåŸŸ
                    if (this.checkLineIntersect(p1, p2,
                        { x: image.x, y: image.y },
                        { x: image.x + image.width, y: image.y }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: image.x + image.width, y: image.y },
                            { x: image.x + image.width, y: image.y + image.height }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: image.x + image.width, y: image.y + image.height },
                            { x: image.x, y: image.y + image.height }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: image.x, y: image.y + image.height },
                            { x: image.x, y: image.y }) ||
                        (x >= image.x && x <= image.x + image.width && y >= image.y && y <= image.y + image.height)) {
                        imagesToDelete.push(image.id);
                    }
                }

                // åˆ é™¤ç›¸äº¤çš„å›¾ç‰‡
                for (const imageId of imagesToDelete) {
                    window.imageHandler.deleteImage(imageId);
                }
            }
            
            // å¤„ç†éŸ³ä¹æ’­æ”¾å™¨çš„æ¿€å…‰åˆ‡å‰²
            if (window.MusicSystem && window.MusicSystem.audioPlayers) {
                // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ä¸éŸ³ä¹æ’­æ”¾å™¨ç›¸äº¤
                const playersToDelete = [];
                for (const player of window.MusicSystem.audioPlayers) {
                    // è·å–æ’­æ”¾å™¨å…ƒç´ çš„ä½ç½®å’Œå¤§å°
                    const rect = player.element.getBoundingClientRect();
                    const containerRect = this.ct.getBoundingClientRect();
                    
                    // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                    const playerX = (rect.left - containerRect.left) / this.zoom;
                    const playerY = (rect.top - containerRect.top) / this.zoom;
                    const playerW = rect.width / this.zoom;
                    const playerH = rect.height / this.zoom;
                    
                    // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ç©¿è¿‡æ’­æ”¾å™¨åŒºåŸŸ
                    if (this.checkLineIntersect(p1, p2,
                        { x: playerX, y: playerY },
                        { x: playerX + playerW, y: playerY }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX + playerW, y: playerY },
                            { x: playerX + playerW, y: playerY + playerH }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX + playerW, y: playerY + playerH },
                            { x: playerX, y: playerY + playerH }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX, y: playerY + playerH },
                            { x: playerX, y: playerY }) ||
                        (x >= playerX && x <= playerX + playerW && y >= playerY && y <= playerY + playerH)) {
                        playersToDelete.push(player.id);
                    }
                }

                // åˆ é™¤ç›¸äº¤çš„éŸ³ä¹æ’­æ”¾å™¨
                for (const playerId of playersToDelete) {
                    window.MusicSystem.removeAudioPlayer(playerId);
                }
            }
            
            // å¤„ç†éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹çš„æ¿€å…‰åˆ‡å‰²
            if (window.MusicSystem && window.MusicSystem.musicListNodes) {
                window.MusicSystem.musicListNodes.forEach((nodeInfo, index) => {
                    const node = nodeInfo.element;
                    if (node) {
                        const rect = node.getBoundingClientRect();
                        const containerRect = this.ct.getBoundingClientRect();
                        
                        // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                        const nodeX = (rect.left - containerRect.left) / this.zoom;
                        const nodeY = (rect.top - containerRect.top) / this.zoom;
                        const nodeW = rect.width / this.zoom;
                        const nodeH = rect.height / this.zoom;
                        
                        // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ç©¿è¿‡èŠ‚ç‚¹åŒºåŸŸ
                        if (this.checkLineIntersect(p1, p2,
                            { x: nodeX, y: nodeY },
                            { x: nodeX + nodeW, y: nodeY }) ||
                            this.checkLineIntersect(p1, p2,
                                { x: nodeX + nodeW, y: nodeY },
                                { x: nodeX + nodeW, y: nodeY + nodeH }) ||
                            this.checkLineIntersect(p1, p2,
                                { x: nodeX + nodeW, y: nodeY + nodeH },
                                { x: nodeX, y: nodeY + nodeH }) ||
                            this.checkLineIntersect(p1, p2,
                                { x: nodeX, y: nodeY + nodeH },
                                { x: nodeX, y: nodeY }) ||
                            (x >= nodeX && x <= nodeX + nodeW && y >= nodeY && y <= nodeY + nodeH)) {
                            console.log('MusicSystem: æ¿€å…‰åˆ‡å‰²éŸ³ä¹åˆ—è¡¨èŠ‚ç‚¹');
                            window.MusicSystem.removeMusicListNode(nodeInfo.id);
                        }
                    }
                });
            }

            // å¤„ç†è§†é¢‘æ’­æ”¾å™¨çš„æ¿€å…‰åˆ‡å‰²
            if (window.VideoSystem && window.VideoSystem.videoPlayers) {
                // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ä¸è§†é¢‘æ’­æ”¾å™¨ç›¸äº¤
                const playersToDelete = [];
                for (const player of window.VideoSystem.videoPlayers) {
                    // è·å–æ’­æ”¾å™¨å…ƒç´ çš„ä½ç½®å’Œå¤§å°
                    const rect = player.element.getBoundingClientRect();
                    const containerRect = this.ct.getBoundingClientRect();
                    
                    // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                    const playerX = (rect.left - containerRect.left) / this.zoom;
                    const playerY = (rect.top - containerRect.top) / this.zoom;
                    const playerW = rect.width / this.zoom;
                    const playerH = rect.height / this.zoom;
                    
                    // æ£€æŸ¥æ¿€å…‰è·¯å¾„æ˜¯å¦ç©¿è¿‡æ’­æ”¾å™¨åŒºåŸŸ
                    if (this.checkLineIntersect(p1, p2,
                        { x: playerX, y: playerY },
                        { x: playerX + playerW, y: playerY }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX + playerW, y: playerY },
                            { x: playerX + playerW, y: playerY + playerH }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX + playerW, y: playerY + playerH },
                            { x: playerX, y: playerY + playerH }) ||
                        this.checkLineIntersect(p1, p2,
                            { x: playerX, y: playerY + playerH },
                            { x: playerX, y: playerY }) ||
                        (x >= playerX && x <= playerX + playerW && y >= playerY && y <= playerY + playerH)) {
                        playersToDelete.push(player.id);
                    }
                }

                // åˆ é™¤ç›¸äº¤çš„è§†é¢‘æ’­æ”¾å™¨
                for (const playerId of playersToDelete) {
                    window.VideoSystem.removeVideoPlayer(playerId);
                }
            }

            // å¤„ç†é¢æ¿çš„æ¿€å…‰åˆ‡å‰²å…³é—­
            // ä»£ç é¢„è§ˆé¢æ¿
            const codePanel = document.getElementById('modal-code');
            if (codePanel && codePanel.style.display !== 'none') {
                codePanel.style.display = 'none';
            }

            // æ“ä½œæŒ‡å—é¢æ¿
            const helpPanel = document.getElementById('modal-help');
            if (helpPanel && helpPanel.style.display !== 'none') {
                helpPanel.style.display = 'none';
            }

            // ç»˜ç”»å·¥å…·æ 
            const drawingToolbar = document.getElementById('drawing-toolbar');
            if (drawingToolbar) {
                // ç§»é™¤æ‰€æœ‰å·¥å…·çš„activeçŠ¶æ€
                drawingToolbar.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                // é‡ç½®ç»˜ç”»å·¥å…·çŠ¶æ€
                if (window.DrawingManager) {
                    window.DrawingManager.currentTool = null;
                    window.DrawingManager.isEmojiMode = false;
                    window.DrawingManager.selectedEmoji = null;
                    // æ¢å¤é»˜è®¤é¼ æ ‡å›¾æ ‡
                    if (this.vp) {
                        this.vp.style.cursor = 'grab';
                        this.vp.classList.remove('drawing-active', 'erasing-active');
                    }
                    // éšè—Emojièœå•
                    const emojiMenu = document.getElementById('emoji-menu');
                    if (emojiMenu) {
                        emojiMenu.style.display = 'none';
                    }
                }
            }

            // å›¾ç‰‡ç¼–è¾‘æ§åˆ¶é¢æ¿
            const imageEditorPanel = document.getElementById('image-editor-panel');
            if (imageEditorPanel && imageEditorPanel.style.display !== 'none') {
                imageEditorPanel.style.display = 'none';
            }

            // åˆ‡å›¾é¢æ¿
            if (window.CutImgSystem) {
                const cutimgPanel = document.getElementById('cutimg-panel');
                if (cutimgPanel && cutimgPanel.style.display !== 'none') {
                    window.CutImgSystem.hidePanel();
                }
            }

            this.renderConns();
        }
    },


    //--------------------æ¿€å…‰åˆ‡å‰²è¾…åŠ©å‡½æ•°
    checkLineIntersect(p0, p1, p2, p3) {
        let s1_x = p1.x - p0.x, s1_y = p1.y - p0.y, s2_x = p3.x - p2.x, s2_y = p3.y - p2.y;
        let s = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / (-s2_x * s1_y + s1_x * s2_y);
        let t = (s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / (-s2_x * s1_y + s1_x * s2_y);
        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
    },
    
    // æ’­æ”¾æ–­å¼€è¿æ¥éŸ³æ•ˆï¼ˆä¿®å¤å‡½æ•°åï¼‰
    playDisconnectSound() {
        AudioSystem.playDeleteSound();
    },


    //--------------------èŠ‚ç‚¹æ“ä½œ
    addNewNode() {
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºèŠ‚ç‚¹
        if (DrawingManager.currentTool) {
            console.log('ç»˜ç”»å·¥å…·å·²æ¿€æ´»ï¼Œæ— æ³•åˆ›å»ºèŠ‚ç‚¹');
            return;
        }

        AudioSystem.playCreateSound();
        const w = 380, h = 180;
        const pos = this.findNonOverlapPos(w, h);
        const nodeId = Date.now();
        this.createNode(nodeId, pos.x, pos.y, w, h, `${this.nodes.length + 1}`, "\n".repeat(5));

        // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè‡ªåŠ¨ç§»åŠ¨è§†å›¾åˆ°èŠ‚ç‚¹ä½ç½®ï¼Œè®©èŠ‚ç‚¹æ˜¾ç¤ºåœ¨ä¸­å¤®
        if (this.nodes.length === 1) {
            const node = this.nodes[0];
            // è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ‡
            const nodeCenterX = node.x + node.w / 2;
            const nodeCenterY = node.y + node.h / 2;

            // è®¡ç®—è§†å›¾ä¸­å¿ƒç‚¹åœ¨å±å¹•ä¸Šçš„åæ ‡
            const viewportCenterX = this.vp.clientWidth / 2;
            const viewportCenterY = this.vp.clientHeight / 2;

            // è®¡ç®—ç›®æ ‡å¹³ç§»å€¼ï¼Œç¡®ä¿èŠ‚ç‚¹å±…ä¸­æ˜¾ç¤º
            const targetPanX = viewportCenterX - (nodeCenterX * this.zoom);
            const targetPanY = viewportCenterY - (nodeCenterY * this.zoom);

            // ç›´æ¥åœ¨å±å¹•ä¸­å¤®æ˜¾ç¤ºç‰¹æ•ˆ
            FXManager.spawn(viewportCenterX, viewportCenterY, '#00ff00'); // æ–°å»ºç‰¹æ•ˆ - å±å¹•ä¸­å¤®

            // ä½¿ç”¨å¹³æ»‘ç§»åŠ¨æ•ˆæœ
            this.smoothPanTo(targetPanX, targetPanY);
        } else {
            // éç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½¿ç”¨å½“å‰è§†å£ä½ç½®
            const s = this.toScreen(pos.x, pos.y);
            FXManager.spawn(s.x, s.y, '#00ff00'); // æ–°å»ºç‰¹æ•ˆ
        }

        this.save();
        this.markMinimapDirty(); // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
        this.updateMinimap();
        this.updateVisibleNodes(); // æ›´æ–°å¯è§èŠ‚ç‚¹
    },

    createNode(id, x, y, w, h, name, code, isInstance = false, originalId = null) {
        const node = { id, x, y, w, h, name, code, isInstance, originalId, isRendered: false };
        this.nodes.push(node);
        this.nodeMap.set(id, node); // æ·»åŠ åˆ°æ˜ å°„è¡¨
        this.quadTree.insert(node); // æ·»åŠ åˆ°å››å‰æ ‘
        
        // ä½¿ç”¨Canvasæ¸²æŸ“æ—¶ï¼Œæ ‡è®°Canvaséœ€è¦æ›´æ–°
        if (this.useCanvasRendering) {
            this.markCanvasDirty();
        } else {
            // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨å¯è§åŒºåŸŸå†…ï¼Œå¦‚æœæ˜¯åˆ™æ¸²æŸ“
            if (this.isNodeVisible(node)) {
                this.renderNode(node);
            }
        }
        return node;
    },

    // æ¸²æŸ“èŠ‚ç‚¹ï¼ˆåˆ›å»ºDOMå…ƒç´ ï¼‰
    renderNode(node) {
        if (!this.useCanvasRendering && !node.isRendered) {
            // èŠ‚ç‚¹å·²ç»åœ¨#containerå…ƒç´ å†…ï¼Œä¸éœ€è¦åº”ç”¨åæ ‡åç§»
            // #containerå…ƒç´ ä¼šè¢«å¹³ç§»å’Œç¼©æ”¾ï¼Œæ‰€ä»¥èŠ‚ç‚¹ä½ç½®ç›´æ¥ä½¿ç”¨åŸå§‹åæ ‡
            const div = document.createElement('div');
            div.className = `node ${node.isInstance ? 'node-instance' : ''}`; div.id = `n-${node.id}`;
            div.style.cssText = `width:${node.w}px; height:${node.h}px; left:${node.x}px; top:${node.y}px;`;
            // è·å–æœ¬ä½“èŠ‚ç‚¹çš„åºå·
            let originalNodeIndex = '';
            if (node.isInstance) {
                const originalNode = this.nodes.find(n => n.id === node.originalId);
                originalNodeIndex = originalNode ? ` (${this.nodes.indexOf(originalNode) + 1})` : '';
            }

            div.innerHTML = `
                <div class="node-header ${node.isInstance ? 'node-header-instance' : ''}">
                    <div class="node-title">${node.name} ${node.isInstance ? `${originalNodeIndex}` : ''}</div>
                    <div class="node-coords" style="font-size: 11px; color: #888; margin-left: 5px;">(${Math.round(node.x)}, ${Math.round(node.y)})</div>
                    <div class="tool-group">
                        ${node.isInstance ? `<span class="tool-icon" onclick="app.locateOriginalNode(${node.originalId})">ğŸ”</span>` : ''}
                        <span class="tool-icon" onclick="app.copyNode(${node.id})">å¤</span>
                        ${!node.isInstance ? `<span class="tool-icon" onclick="app.instantiateNode(${node.id})">å½±</span>` : ''}
                        <span class="tool-icon" onclick="app.resizeNode(${node.id},'min')">å°</span>
                        <span class="tool-icon" onclick="app.resizeNode(${node.id},'max')">å¤§</span>
                        <span class="tool-icon close" onclick="app.removeNode(${node.id})">å…³</span>
                    </div>
                </div>
                <div class="editor-wrapper">
                    <div class="line-numbers"></div>
                    <textarea class="code-input" spellcheck="false" ${node.isInstance ? 'readonly' : ''}>${node.code}</textarea>
                </div>
                <div class="port port-in"></div>
                <div class="port port-out" onmousedown="app.activeConn={from:${node.id}}; event.stopPropagation();"></div>
            `;
            const tx = div.querySelector('textarea'), ln = div.querySelector('.line-numbers');
            const updateUI = () => {
                // å¯¹äºè‡ªåŠ¨æ¢è¡Œçš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å®é™…æ˜¾ç¤ºçš„è¡Œæ•°
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œä½¿ç”¨æ¢è¡Œç¬¦æ•°é‡ä½œä¸ºè¡Œæ•°ï¼Œå› ä¸ºè‡ªåŠ¨æ¢è¡Œçš„è¡Œæ•°è®¡ç®—æ¯”è¾ƒå¤æ‚
                const lineCount = Math.max(tx.value.split('\n').length, 6);
                ln.innerHTML = Array.from({ length: lineCount }, (_, i) => i + 1).join('<br>');
            };
            if (!node.isInstance) {
                tx.oninput = () => {
                    node.code = tx.value;
                    updateUI();
                    this.save();
                    // æ›´æ–°æ‰€æœ‰å®ä¾‹åŒ–çš„èŠ‚ç‚¹
                    this.updateInstances(node.id);
                };

                // å¤„ç†æ»šåŠ¨äº‹ä»¶ï¼Œç¡®ä¿è¡Œå·ä¸æ–‡æœ¬è¡ŒåŒæ­¥
                tx.addEventListener('scroll', () => {
                    ln.scrollTop = tx.scrollTop;
                });

                // å¤„ç†Tabé”®ï¼Œæ’å…¥ç¼©è¿›è€Œä¸æ˜¯åˆ‡æ¢ç„¦ç‚¹
                tx.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„ç„¦ç‚¹åˆ‡æ¢è¡Œä¸º

                        // è·å–å½“å‰å…‰æ ‡ä½ç½®
                        const start = tx.selectionStart;
                        const end = tx.selectionEnd;

                        // æ’å…¥ç¼©è¿›ï¼ˆä¸¤ä¸ªç©ºæ ¼ï¼‰
                        const value = tx.value;
                        tx.value = value.substring(0, start) + '  ' + value.substring(end);

                        // æ›´æ–°å…‰æ ‡ä½ç½®
                        tx.selectionStart = tx.selectionEnd = start + 2;

                        // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°UIå’Œä¿å­˜
                        tx.dispatchEvent(new Event('input'));
                    }
                });

                // å¤„ç†ç²˜è´´äº‹ä»¶ï¼Œç¡®ä¿ç²˜è´´å†…å®¹æ­£ç¡®æ›´æ–°
                tx.addEventListener('paste', (e) => {
                    e.preventDefault();
                    
                    // è·å–ç²˜è´´çš„æ–‡æœ¬
                    const text = e.clipboardData.getData('text/plain');
                    
                    // è·å–å½“å‰å…‰æ ‡ä½ç½®
                    const start = tx.selectionStart;
                    const end = tx.selectionEnd;
                    
                    // è·å–å½“å‰æ–‡æœ¬å€¼
                    const value = tx.value;
                    
                    // æ’å…¥ç²˜è´´çš„æ–‡æœ¬
                    tx.value = value.substring(0, start) + text + value.substring(end);
                    
                    // æ›´æ–°å…‰æ ‡ä½ç½®åˆ°ç²˜è´´æ–‡æœ¬ä¹‹å
                    tx.selectionStart = tx.selectionEnd = start + text.length;
                    
                    // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°UIå’Œä¿å­˜
                    tx.dispatchEvent(new Event('input'));
                });

            }
            div.onmousedown = (e) => {
                e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                if (e.button === 0) {
                    // åªæœ‰ç‚¹å‡»èŠ‚ç‚¹æ ‡é¢˜æ æ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºå¹¶å…è®¸æ‹–åŠ¨
                    if (e.target.closest('.node-header')) {
                        e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢æ–‡æœ¬é€‰æ‹©
                        this.dragNode = node;
                    }
                    document.querySelectorAll('.node').forEach(n => n.classList.remove('active'));
                    div.classList.add('active');
                }
            };
            this.layer.appendChild(div); 
            updateUI();
            node.isRendered = true;
        }
    },

    // éšè—èŠ‚ç‚¹ï¼ˆç§»é™¤DOMå…ƒç´ ï¼‰
    hideNode(node) {
        if (!this.useCanvasRendering && node.isRendered) {
            const el = document.getElementById(`n-${node.id}`);
            if (el) {
                el.remove();
                node.isRendered = false;
            }
        }
    },

    resizeNode(id, mode) {
        const n = this.nodeMap.get(id); // ä½¿ç”¨æ˜ å°„è¡¨æŸ¥æ‰¾èŠ‚ç‚¹
        
        if (!this.useCanvasRendering) {
            const el = document.getElementById(`n-${id}`), tx = el.querySelector('textarea'), ln = el.querySelector('.line-numbers');
            const updateUI = () => {
                const lines = tx.value.split('\n');
                const lineCount = Math.max(lines.length, 6);
                ln.innerHTML = Array.from({ length: lineCount }, (_, i) => i + 1).join('<br>');
                // ç¡®ä¿è¡Œå·åŒºåŸŸçš„é«˜åº¦ä¸æ–‡æœ¬ç¼–è¾‘å™¨ä¸€è‡´
                ln.style.height = '100%';
            };
            
            if (mode === 'max') {
                // è®¡ç®—é«˜åº¦ï¼šæ ¹æ®ä»£ç å†…å®¹
                tx.style.height = 'auto';
                n.h = Math.max(180, tx.scrollHeight + 60);
                
                // ä½¿ç”¨DOMæµ‹é‡æ¥ç²¾ç¡®è®¡ç®—æ–‡æœ¬å®½åº¦
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å…ƒç´ æ¥æµ‹é‡æ–‡æœ¬å®½åº¦
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'pre';
                tempDiv.style.fontFamily = 'Consolas';
                tempDiv.style.fontSize = '13px';
                tempDiv.style.lineHeight = '1.6';
                tempDiv.style.padding = '12px';
                document.body.appendChild(tempDiv);
                
                // è®¡ç®—æœ€é•¿è¡Œçš„å®½åº¦
                const lines = tx.value.split('\n');
                let maxLineWidth = 0;
                
                for (const line of lines) {
                    tempDiv.textContent = line;
                    const lineWidth = tempDiv.offsetWidth;
                    if (lineWidth > maxLineWidth) {
                        maxLineWidth = lineWidth;
                    }
                }
                
                // æ¸…ç†ä¸´æ—¶å…ƒç´ 
                document.body.removeChild(tempDiv);
                
                // è®¡ç®—ä»£ç åŒºåŸŸçš„æ€»å®½åº¦ï¼šæœ€é•¿è¡Œå®½åº¦ + è¡Œå·åŒºåŸŸå®½åº¦ + è¾¹è·
                const codeWidth = maxLineWidth + 60; // 60åŒ…æ‹¬è¡Œå·åŒºåŸŸå’Œå†…è¾¹è·
                
                // è®¡ç®—æ ‡é¢˜å®½åº¦
                const titleElement = el.querySelector('.node-title');
                let titleWidth = 200; // é»˜è®¤æ ‡é¢˜å®½åº¦
                if (titleElement) {
                    // æµ‹é‡æ ‡é¢˜çš„å®é™…å®½åº¦
                    titleWidth = titleElement.offsetWidth + 150; // 150åŒ…æ‹¬å·¥å…·æŒ‰é’®ç»„
                }
                
                // å–æœ€å¤§å€¼ä½œä¸ºèŠ‚ç‚¹å®½åº¦
                n.w = Math.max(320, codeWidth, titleWidth);
                
                // é‡ç½®æ–‡æœ¬ç¼–è¾‘å™¨é«˜åº¦
                tx.style.height = '100%';
            } else { 
                n.w = 320; 
                n.h = 180; 
            }
            
            // è®¾ç½®èŠ‚ç‚¹å®½åº¦å’Œé«˜åº¦
            el.style.width = n.w + 'px';
            el.style.height = n.h + 'px';
            
            // ç¡®ä¿æ–‡æœ¬ç¼–è¾‘å™¨å’Œè¡Œå·åŒºåŸŸèƒ½æ­£ç¡®é€‚åº”å®½åº¦å˜åŒ–
            const editorWrapper = el.querySelector('.editor-wrapper');
            if (editorWrapper) {
                editorWrapper.style.width = '100%';
                editorWrapper.style.height = 'calc(100% - 38px)'; // å‡å»æ ‡é¢˜æ é«˜åº¦
            }
            
            // ç¡®ä¿è¡Œå·åŒºåŸŸçš„å®½åº¦å›ºå®šï¼Œæ–‡æœ¬ç¼–è¾‘å™¨å æ»¡å‰©ä½™ç©ºé—´
            ln.style.minWidth = '38px';
            ln.style.width = '38px';
            ln.style.height = '100%';
            tx.style.flex = '1';
            tx.style.height = '100%';
            
            // æ›´æ–°è¡Œå·
            updateUI();
        } else {
            // ä½¿ç”¨Canvasæ¸²æŸ“æ—¶ï¼Œç›´æ¥æ›´æ–°èŠ‚ç‚¹å¤§å°
            if (mode === 'max') {
                // å¯¹äºCanvasæ¸²æŸ“ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å›ºå®šçš„æœ€å¤§å¤§å°ï¼Œæˆ–è€…æ ¹æ®å†…å®¹è®¡ç®—
                // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„è®¡ç®—æ–¹å¼
                n.h = Math.max(180, 200); // å›ºå®šé«˜åº¦
                // è€ƒè™‘æ ‡é¢˜é•¿åº¦çš„å›ºå®šå®½åº¦
                n.w = Math.max(320, 400, (n.name.length + (n.isInstance ? 10 : 0)) * 8 + 150);
            } else { n.w = 320; n.h = 180; }
        }
        
        this.renderConns();
        this.save();
        this.markMinimapDirty(); // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
        this.markCanvasDirty(); // æ ‡è®°Canvaséœ€è¦æ›´æ–°
        this.updateMinimap();
    },

    removeNode(id) {
        AudioSystem.playDeleteSound();
        const n = this.nodeMap.get(id); // ä½¿ç”¨æ˜ å°„è¡¨æŸ¥æ‰¾èŠ‚ç‚¹
        if (n) { const s = this.toScreen(n.x + n.w / 2, n.y + n.h / 2); FXManager.spawn(s.x, s.y, '#ff0000', 30); } // åˆ é™¤ç‰¹æ•ˆ - çº¢è‰²

        // è·å–æ‰€æœ‰éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹IDï¼šåŒ…æ‹¬å½“å‰èŠ‚ç‚¹å’Œæ‰€æœ‰å®ä¾‹èŠ‚ç‚¹
        const nodesToDelete = [id];
        // æŸ¥æ‰¾æ‰€æœ‰æŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å®ä¾‹èŠ‚ç‚¹
        this.nodes.forEach(node => {
            if (node.isInstance && node.originalId === id) {
                nodesToDelete.push(node.id);
            }
        });

        // åˆ é™¤æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹
        nodesToDelete.forEach(deleteId => {
            this.nodes = this.nodes.filter(n => n.id !== deleteId);
            this.nodeMap.delete(deleteId); // ä»æ˜ å°„è¡¨ä¸­åˆ é™¤
            
            // ä»é‚»æ¥è¡¨ä¸­åˆ é™¤ç›¸å…³è¿æ¥
            // 1. åˆ é™¤ä»¥è¯¥èŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„è¿æ¥
            this.connMap.delete(deleteId);
            
            // 2. åˆ é™¤æ‰€æœ‰ä»¥è¯¥èŠ‚ç‚¹ä¸ºç»ˆç‚¹çš„è¿æ¥
            for (const [fromId, connections] of this.connMap.entries()) {
                const index = connections.indexOf(deleteId);
                if (index !== -1) {
                    connections.splice(index, 1);
                    if (connections.length === 0) {
                        this.connMap.delete(fromId);
                    }
                }
            }
            
            // æ›´æ–°è¿æ¥æ•°ç»„
            this.conns = this.conns.filter(c => c.from !== deleteId && c.to !== deleteId);
            
            const el = document.getElementById(`n-${deleteId}`);
            if (el) {
                // ä¸ºæ¯ä¸ªåˆ é™¤çš„å®ä¾‹èŠ‚ç‚¹æ·»åŠ ç‰¹æ•ˆ
                const node = this.nodeMap.get(deleteId);
                if (node) {
                    const s = this.toScreen(node.x + node.w / 2, node.y + node.h / 2);
                    FXManager.spawn(s.x, s.y, '#ff0000', 30); // åˆ é™¤ç‰¹æ•ˆ - çº¢è‰²
                }
                el.remove();
            }
        });

        // é‡å»ºå››å‰æ ‘
        this.quadTree.rebuild(this.nodes);
        
        this.renderConns();
        this.save();
        this.markMinimapDirty(); // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
        this.updateMinimap();
        this.updateVisibleNodes(); // æ›´æ–°å¯è§èŠ‚ç‚¹
    },

    // å¤åˆ¶èŠ‚ç‚¹ï¼šåˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œå†…å®¹å¯ç¼–è¾‘
    copyNode(id) {
        AudioSystem.playCreateSound();
        const original = this.nodes.find(n => n.id === id);
        if (!original) return;

        const w = Math.max(380, original.w), h = original.h;
        const pos = this.findNonOverlapPos(w, h);
        const newId = Date.now();
        const newName = `${this.nodes.length + 1}`;

        this.createNode(newId, pos.x, pos.y, w, h, newName, original.code);
        const screenPos = this.toScreen(pos.x + w / 2, pos.y + h / 2);
        FXManager.spawn(screenPos.x, screenPos.y, '#00ffff', 20); // å¤åˆ¶ç‰¹æ•ˆ - é’è‰²
        this.save(); 
        this.markMinimapDirty(); // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
        this.updateMinimap();
    },

    // å®ä¾‹åŒ–èŠ‚ç‚¹ï¼šåˆ›å»ºåªè¯»èŠ‚ç‚¹ï¼Œä¸åŸèŠ‚ç‚¹ä¿æŒåŒæ­¥
    instantiateNode(id) {
        AudioSystem.playCreateSound();
        const original = this.nodes.find(n => n.id === id);
        if (!original) return;

        const w = Math.max(380, original.w), h = original.h;
        const pos = this.findNonOverlapPos(w, h);
        const newId = Date.now();

        this.createNode(newId, pos.x, pos.y, w, h, `${this.nodes.length + 1}`, original.code, true, original.id);
        const screenPos = this.toScreen(pos.x + w / 2, pos.y + h / 2);
        FXManager.spawn(screenPos.x, screenPos.y, '#ff00ff', 20); // å®ä¾‹åŒ–ç‰¹æ•ˆ - ç´«è‰²
        this.save(); 
        this.markMinimapDirty(); // æ ‡è®°å°åœ°å›¾éœ€è¦æ›´æ–°
        this.updateMinimap();
    },

    // æ›´æ–°æ‰€æœ‰å®ä¾‹åŒ–çš„èŠ‚ç‚¹
    updateInstances(originalId) {
        const original = this.nodes.find(n => n.id === originalId);
        if (!original) return;

        this.nodes.forEach(node => {
            if (node.isInstance && node.originalId === originalId) {
                // æ›´æ–°å®ä¾‹èŠ‚ç‚¹çš„ä»£ç 
                node.code = original.code;
                // æ›´æ–°UI
                const el = document.getElementById(`n-${node.id}`);
                if (el) {
                    const tx = el.querySelector('textarea');
                    const ln = el.querySelector('.line-numbers');
                    tx.value = original.code;
                    ln.innerHTML = Array.from({ length: Math.max(tx.value.split('\n').length, 6) }, (_, i) => i + 1).join('<br>');
                }
            }
        });
    },

    //--------------------æ¸²æŸ“è¿æ¥
    renderConns(mousePos = null, targetNodeId = null) {
        // å¦‚æœæŒ‡å®šäº†ç›®æ ‡èŠ‚ç‚¹ï¼Œåªæ›´æ–°ä¸è¯¥èŠ‚ç‚¹ç›¸å…³çš„è¿æ¥çº¿
        if (targetNodeId && this.dragNode) {
            // å…ˆæ¸…é™¤ä¸è¯¥èŠ‚ç‚¹ç›¸å…³çš„æ—§è¿æ¥çº¿
            const relatedConnElements = [];
            this.svgGroup.querySelectorAll('path').forEach(path => {
                const fromId = parseInt(path.dataset.from);
                const toId = parseInt(path.dataset.to);
                if (fromId === targetNodeId || toId === targetNodeId) {
                    relatedConnElements.push(path);
                }
            });
            relatedConnElements.forEach(el => el.remove());
            
            // åªç»˜åˆ¶ä¸è¯¥èŠ‚ç‚¹ç›¸å…³çš„æ–°è¿æ¥çº¿
            const node = this.dragNode;
            this.conns.forEach(c => {
                if (c.from === targetNodeId || c.to === targetNodeId) {
                    const n1 = this.nodeMap.get(c.from), n2 = this.nodeMap.get(c.to);
                    if (n1 && n2) {
                        this.drawCurve(this.getOut(n1), this.getIn(n2), c.from, c.to);
                    }
                }
            });
        } else {
            // å¦åˆ™ï¼Œé‡æ–°ç»˜åˆ¶æ‰€æœ‰è¿æ¥çº¿
            this.svgGroup.innerHTML = '';
            
            // ç›´æ¥è®¡ç®—å½“å‰å¯è§åŒºåŸŸï¼Œä¸ä¾èµ–isVisibleå±æ€§ï¼Œç¡®ä¿è¿æ¥çº¿ç«‹å³æ¸²æŸ“
            const visibleBounds = this.getVisibleBounds();
            
            // åªæ¸²æŸ“å¯è§èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥
            this.conns.forEach(c => {
                const n1 = this.nodeMap.get(c.from), n2 = this.nodeMap.get(c.to); // ä½¿ç”¨æ˜ å°„è¡¨æŸ¥æ‰¾èŠ‚ç‚¹
                if (n1 && n2) {
                    // æ£€æŸ¥ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªåœ¨å¯è§åŒºåŸŸå†…
                    if (this.isNodeInBounds(n1, visibleBounds) || this.isNodeInBounds(n2, visibleBounds)) {
                        this.drawCurve(this.getOut(n1), this.getIn(n2), c.from, c.to);
                    }
                }
            });
        }
        
        // æ¸²æŸ“æ¿€æ´»çš„è¿æ¥ï¼ˆå¦‚æœæœ‰ï¼‰
        if (this.activeConn && mousePos) {
            const n1 = this.nodeMap.get(this.activeConn.from); // ä½¿ç”¨æ˜ å°„è¡¨æŸ¥æ‰¾èŠ‚ç‚¹
            if (n1) this.drawCurve(this.getOut(n1), mousePos);
        }
    },
    
    // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨æŒ‡å®šè¾¹ç•Œå†…
    isNodeInBounds(node, bounds) {
        return node.x < bounds.right && 
               node.x + node.w > bounds.left && 
               node.y < bounds.bottom && 
               node.y + node.h > bounds.top;
    },

    //--------------------ç»˜åˆ¶æ›²çº¿
    drawCurve(p1, p2, from = null, to = null) {
        // SVGç”»å¸ƒå·²ç»ä¸containerä¿æŒç›¸åŒçš„å˜æ¢ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹åæ ‡ç»˜åˆ¶è¿æ¥çº¿
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const cp = Math.abs(p1.x - p2.x) * 0.4;
        path.setAttribute("d", `M ${p1.x} ${p1.y} C ${p1.x + cp} ${p1.y}, ${p2.x - cp} ${p2.y}, ${p2.x} ${p2.y}`);
        path.setAttribute("class", "connection");
        // å­˜å‚¨è¿æ¥çº¿çš„èµ·å§‹å’Œç»“æŸèŠ‚ç‚¹IDï¼Œç”¨äºä¼˜åŒ–æ›´æ–°
        if (from !== null && to !== null) {
            path.dataset.from = from;
            path.dataset.to = to;
        }
        this.svgGroup.appendChild(path);
    },

    //--------------------è·å–èŠ‚ç‚¹è¾“å…¥è¾“å‡ºç‚¹
    getIn(n) { return { x: n.x, y: n.y + (n.h / 2) }; },
    getOut(n) { return { x: n.x + n.w, y: n.y + (n.h / 2) }; },

    //--------------------åŒæ­¥èŠ‚ç‚¹UI
    syncNodeUI(n) {
        // åªæœ‰å½“èŠ‚ç‚¹å·²ç»æ¸²æŸ“æ—¶æ‰æ›´æ–°UI
        if (!n.isRendered) return;
        
        // èŠ‚ç‚¹å·²ç»åœ¨#containerå…ƒç´ å†…ï¼Œä¸éœ€è¦åº”ç”¨åæ ‡åç§»
        // #containerå…ƒç´ ä¼šè¢«å¹³ç§»å’Œç¼©æ”¾ï¼Œæ‰€ä»¥èŠ‚ç‚¹ä½ç½®ç›´æ¥ä½¿ç”¨åŸå§‹åæ ‡
        const el = document.getElementById(`n-${n.id}`);
        if (el) {
            el.style.left = n.x + 'px';
            el.style.top = n.y + 'px';
            el.style.width = n.w + 'px';
            el.style.height = n.h + 'px';
            // æ›´æ–°åæ ‡æ˜¾ç¤º
            const coordsEl = el.querySelector('.node-coords');
            if (coordsEl) {
                coordsEl.textContent = `(${Math.round(n.x)}, ${Math.round(n.y)})`;
            }
        }
    },
    //--------------------æ›´æ–°å˜æ¢
    updateTransform() {
        // æ¢å¤å˜æ¢åŸç‚¹åˆ°å·¦ä¸Šè§’ï¼Œç¡®ä¿å¸ƒå±€æ­£å¸¸
        this.ct.style.transformOrigin = '0 0';
        this.ct.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
        
        // ç¡®ä¿SVGç”»å¸ƒçš„å˜æ¢ä¸containerä¿æŒä¸€è‡´ï¼Œè¿™æ ·è¿æ¥çº¿å°±èƒ½æ­£ç¡®æ˜¾ç¤º
        this.svgCanvas.style.transformOrigin = '0 0';
        this.svgCanvas.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
        
        this.updateMinimap();
    },

    // è®¡ç®—å¯è§åŒºåŸŸè¾¹ç•Œï¼ˆä¸–ç•Œåæ ‡ï¼‰
    getVisibleBounds() {
        // è®¡ç®—å½“å‰ç›¸æœºè§†é‡çš„è¾¹ç•Œ
        const viewLeft = (-this.panX) / this.zoom;
        const viewTop = (-this.panY) / this.zoom;
        const viewRight = viewLeft + (this.vp.clientWidth / this.zoom);
        const viewBottom = viewTop + (this.vp.clientHeight / this.zoom);
        
        // æ·»åŠ ä¸€äº›ç¼“å†²åŒºï¼Œæå‰åŠ è½½å³å°†è¿›å…¥è§†é‡çš„èŠ‚ç‚¹
        const buffer = 200;
        return {
            left: viewLeft - buffer,
            top: viewTop - buffer,
            right: viewRight + buffer,
            bottom: viewBottom + buffer
        };
    },

    // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨å¯è§åŒºåŸŸå†…
    isNodeVisible(node) {
        const bounds = this.getVisibleBounds();
        return node.x < bounds.right && 
               node.x + node.w > bounds.left && 
               node.y < bounds.bottom && 
               node.y + node.h > bounds.top;
    },

    // æ·»åŠ è¿æ¥
    addConnection(from, to) {
        // æ·»åŠ åˆ°è¿æ¥æ•°ç»„
        this.conns.push({ from, to });
        
        // æ·»åŠ åˆ°é‚»æ¥è¡¨
        if (!this.connMap.has(from)) {
            this.connMap.set(from, []);
        }
        this.connMap.get(from).push(to);
    },
    
    // åˆ é™¤è¿æ¥
    removeConnection(from, to) {
        // ä»è¿æ¥æ•°ç»„ä¸­åˆ é™¤
        this.conns = this.conns.filter(c => !(c.from === from && c.to === to));
        
        // ä»é‚»æ¥è¡¨ä¸­åˆ é™¤
        if (this.connMap.has(from)) {
            const connections = this.connMap.get(from);
            const index = connections.indexOf(to);
            if (index !== -1) {
                connections.splice(index, 1);
                // å¦‚æœè¯¥èŠ‚ç‚¹æ²¡æœ‰æ›´å¤šè¿æ¥ï¼Œä»é‚»æ¥è¡¨ä¸­ç§»é™¤
                if (connections.length === 0) {
                    this.connMap.delete(from);
                }
            }
        }
    },
    
    // æ›´æ–°å¯è§èŠ‚ç‚¹åˆ—è¡¨å¹¶æ¸²æŸ“/éšè—èŠ‚ç‚¹
    updateVisibleNodes() {
        // ä½¿ç”¨requestAnimationFrameæ‰¹é‡å¤„ç†ï¼Œé¿å…é¢‘ç¹DOMæ“ä½œ
        if (!this.visibleNodesUpdateRequested) {
            this.visibleNodesUpdateRequested = true;
            requestAnimationFrame(() => {
                const visibleBounds = this.getVisibleBounds();
                
                // ä½¿ç”¨å››å‰æ ‘å¿«é€ŸæŸ¥æ‰¾å¯è§åŒºåŸŸå†…çš„èŠ‚ç‚¹
                const visibleNodes = this.quadTree.query(visibleBounds);
                const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
                
                // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çš„å¯è§æ€§çŠ¶æ€
                for (const node of this.nodes) {
                    const wasVisible = node.isVisible;
                    node.isVisible = visibleNodeIds.has(node.id);
                    
                    // æ ¹æ®å¯è§æ€§çŠ¶æ€æ›´æ–°DOMæˆ–Canvas
                    if (this.useCanvasRendering) {
                        // ä½¿ç”¨Canvasæ¸²æŸ“ï¼Œåªéœ€è¦æ ‡è®°Canvaséœ€è¦æ›´æ–°
                        this.markCanvasDirty();
                    } else {
                        // ä½¿ç”¨DOMæ¸²æŸ“ï¼Œæ ¹æ®å¯è§æ€§çŠ¶æ€æ›´æ–°DOM
                        if (node.isVisible && !node.isRendered) {
                            // èŠ‚ç‚¹è¿›å…¥å¯è§åŒºåŸŸï¼Œæ¸²æŸ“å®ƒ
                            this.renderNode(node);
                        } else if (!node.isVisible && node.isRendered) {
                            // èŠ‚ç‚¹ç¦»å¼€å¯è§åŒºåŸŸï¼Œéšè—å®ƒ
                            this.hideNode(node);
                        }
                    }
                }
                
                this.visibleNodesUpdateRequested = false;
            });
        }
    },




    // å®šä½åˆ°å®ä¾‹åŒ–çš„æœ¬ä½“èŠ‚ç‚¹
    locateOriginalNode(originalId) {
        const originalNode = this.nodes.find(n => n.id === originalId);
        if (originalNode) {
            // è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ‡
            const nodeCenterX = originalNode.x + originalNode.w / 2;
            const nodeCenterY = originalNode.y + originalNode.h / 2;

            // è®¡ç®—è§†å›¾ä¸­å¿ƒç‚¹åœ¨å±å¹•ä¸Šçš„åæ ‡
            const viewportCenterX = this.vp.clientWidth / 2;
            const viewportCenterY = this.vp.clientHeight / 2;

            // è®¡ç®—ç›®æ ‡å¹³ç§»å€¼ï¼Œç¡®ä¿èŠ‚ç‚¹å±…ä¸­æ˜¾ç¤º
            const targetPanX = viewportCenterX - (nodeCenterX * this.zoom);
            const targetPanY = viewportCenterY - (nodeCenterY * this.zoom);

            // ä½¿ç”¨å¹³æ»‘ç§»åŠ¨æ•ˆæœ
            this.smoothPanTo(targetPanX, targetPanY);

            // é«˜äº®æœ¬ä½“èŠ‚ç‚¹
            document.querySelectorAll('.node').forEach(n => n.classList.remove('active'));
            const originalEl = document.getElementById(`n-${originalId}`);
            if (originalEl) {
                originalEl.classList.add('active');
            }
        }
    },

    // å¹³æ»‘ç§»åŠ¨é•œå¤´åˆ°ç›®æ ‡ä½ç½®
    smoothPanTo(targetPanX, targetPanY, duration = 500) {
        const startPanX = this.panX;
        const startPanY = this.panY;
        const startTime = Date.now();

        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°å®ç°å¹³æ»‘æ•ˆæœ
            const easedProgress = 1 - Math.pow(1 - progress, 3);

            // æ›´æ–°å¹³ç§»å€¼
            this.panX = startPanX + (targetPanX - startPanX) * easedProgress;
            this.panY = startPanY + (targetPanY - startPanY) * easedProgress;

            // æ›´æ–°è§†å›¾å’Œå°åœ°å›¾
            this.updateTransform();
            this.updateMinimap();

            // å¦‚æœåŠ¨ç”»æœªå®Œæˆï¼Œç»§ç»­æ‰§è¡Œ
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        animate();
    },

    // æ£€æŸ¥ä¸¤ä¸ªçŸ©å½¢æ˜¯å¦é‡å 
    isOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return !(x1 + w1 <= x2 || x1 >= x2 + w2 || y1 + h1 <= y2 || y1 >= y2 + h2);
    },

    // æ‰¾åˆ°ä¸é‡å çš„ä½ç½® - ä¾æ®å½“å‰è§†çª—å®½åº¦ä¸ºè¾¹ç•Œï¼Œåˆ°è¾¾è¾¹ç•Œæ¢è¡Œ
    findNonOverlapPos(w, h) {
        let offset = 40;

        // å¦‚æœæ²¡æœ‰èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹åˆ›å»ºä½ç½®ä¸º(0, 0)
        if (this.nodes.length === 0) {
            return {
                x: 0,
                y: 0
            };
        }

        // è·å–å½“å‰è§†çª—å¯è§åŒºåŸŸçš„å·¦å³è¾¹ç•Œï¼ˆè½¬æ¢ä¸ºä¸–ç•Œåæ ‡ï¼‰
        const viewLeft = (-this.panX) / this.zoom;
        const viewRight = viewLeft + (this.vp.clientWidth / this.zoom);

        // è·å–æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®
        const lastNode = this.nodes[this.nodes.length - 1];

        // è®¡ç®—ä¸‹ä¸€ä¸ªä½ç½®ï¼šåœ¨å½“å‰è¡Œç»§ç»­æ¨ªå‘æ’åˆ—
        let x = lastNode.x + lastNode.w + offset;
        let y = lastNode.y;

        // æ£€æŸ¥æ˜¯å¦é‡å æˆ–è¶…å‡ºå½“å‰è§†çª—å³è¾¹ç•Œ
        let overlap = false;
        for (const node of this.nodes) {
            if (this.isOverlap(x, y, w, h, node.x, node.y, node.w, node.h)) {
                overlap = true;
                break;
            }
        }

        // å¦‚æœé‡å æˆ–è¶…å‡ºè§†çª—å³è¾¹ç•Œï¼Œæ¢è¡Œåˆ°ä¸‹ä¸€è¡Œ
        if (overlap || x + w > viewRight) {
            // æ¢è¡Œï¼Œå›åˆ°è§†çª—å·¦è¾¹ç•Œå¼€å§‹
            x = viewLeft;
            y = lastNode.y + lastNode.h + offset;

            // ç¡®ä¿æ–°ä½ç½®ä¸ä¸ä»»ä½•èŠ‚ç‚¹é‡å 
            let found = false;
            let attempts = 0;
            const maxAttempts = 100; // é™åˆ¶å°è¯•æ¬¡æ•°ï¼Œé¿å…æ— é™å¾ªç¯
            
            while (attempts < maxAttempts) {
                overlap = false;
                for (const node of this.nodes) {
                    if (this.isOverlap(x, y, w, h, node.x, node.y, node.w, node.h)) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    found = true;
                    break;
                }
                // å¦‚æœå½“å‰ä½ç½®é‡å ï¼Œå‘ä¸‹ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹é«˜åº¦
                y += h + offset;
                attempts++;
            }

            // å¦‚æœæ‰¾åˆ°åˆé€‚ä½ç½®ï¼Œè¿”å›è¯¥ä½ç½®
            if (found) {
                return {
                    x: x,
                    y: y
                };
            }

            // å¦‚æœæ¢è¡Œåæ‰¾ä¸åˆ°åˆé€‚ä½ç½®ï¼Œå°è¯•åœ¨ç°æœ‰èŠ‚ç‚¹ä¸‹æ–¹å¯»æ‰¾åˆé€‚ä½ç½®
            // ä»æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸‹æ–¹å¼€å§‹æŸ¥æ‰¾
            x = lastNode.x;
            y = lastNode.y + lastNode.h + offset;
            attempts = 0;
            
            while (attempts < maxAttempts) {
                overlap = false;
                for (const node of this.nodes) {
                    if (this.isOverlap(x, y, w, h, node.x, node.y, node.w, node.h)) {
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    return {
                        x: x,
                        y: y
                    };
                }
                y += h + offset;
                attempts++;
            }

            // å¦‚æœæ‰€æœ‰ä½ç½®éƒ½è¢«å ç”¨ï¼Œè¿”å›é»˜è®¤ä½ç½®
            return {
                x: lastNode.x + offset,
                y: lastNode.y + offset
            };
        }

        // å¦‚æœå½“å‰ä½ç½®åˆé€‚ï¼Œç›´æ¥è¿”å›
        return {
            x: x,
            y: y
        };
    },

    //--------------------å¯¼å‡ºä»£ç 
    exportCode() {
        // 1. æ£€æŸ¥æ˜¯å¦æœ‰èŠ‚ç‚¹
        if (this.nodes.length === 0) {
            alert('æ²¡æœ‰èŠ‚ç‚¹å¯å¯¼å‡ºï¼');
            AudioSystem.playErrorSound();
            FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ff0000', 50); // å¯¼å‡ºå¤±è´¥ç‰¹æ•ˆ - çº¢è‰²
            return;
        }

        // 2. æ„å»ºé‚»æ¥è¡¨ï¼šè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹
        const adj = new Map();
        this.nodes.forEach(n => {
            adj.set(n.id, []);
        });
        this.conns.forEach(c => {
            adj.get(c.from).push(c.to);
        });

        // 3. ä½¿ç”¨ BFS ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹éå†ï¼Œè·å–æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹
        const firstNodeId = this.nodes[0].id;
        const visited = new Set();
        const queue = [firstNodeId];
        visited.add(firstNodeId);

        while (queue.length > 0) {
            const currentId = queue.shift();
            const neighbors = adj.get(currentId) || [];

            for (const neighborId of neighbors) {
                if (!visited.has(neighborId)) {
                    visited.add(neighborId);
                    queue.push(neighborId);
                }
            }
        }

        // 4. æŒ‰ç…§è¿æ¥é¡ºåºç”Ÿæˆæœ€ç»ˆä»£ç 
        // ä½¿ç”¨ BFS é¡ºåºä½œä¸ºåˆæˆé¡ºåº
        const bfsOrder = [];
        const visitedForBFS = new Set();
        const bfsQueue = [firstNodeId];
        visitedForBFS.add(firstNodeId);

        while (bfsQueue.length > 0) {
            const currentId = bfsQueue.shift();
            bfsOrder.push(currentId);

            const neighbors = adj.get(currentId) || [];
            for (const neighborId of neighbors) {
                if (visited.has(neighborId) && !visitedForBFS.has(neighborId)) {
                    visitedForBFS.add(neighborId);
                    bfsQueue.push(neighborId);
                }
            }
        }

        // 5. ç”Ÿæˆæœ€ç»ˆä»£ç 
        const finalCode = bfsOrder.map(id => {
            const n = this.nodeMap.get(id); // ä½¿ç”¨nodeMapä¼˜åŒ–æŸ¥æ‰¾ï¼ŒO(1)æ—¶é—´å¤æ‚åº¦
            return n.code.trim();
        }).join('\n\n');

        AudioSystem.playButtonSound();;
        FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ffff00', 50); // å¯¼å‡ºæˆåŠŸç‰¹æ•ˆ - é»„è‰²

        // 6. æ˜¾ç¤ºå¯¼å‡ºçš„ä»£ç 
        const modalContent = document.getElementById('modal-content');
        modalContent.innerText = finalCode;

        // ç›´æ¥è·å–HTMLä¸­å·²æ·»åŠ çš„å¤åˆ¶æŒ‰é’®
        const copyBtn = document.getElementById('modal-copy-btn');
        copyBtn.onclick = () => {
            // ä½¿ç”¨æ›´å¯é çš„å¤åˆ¶æ–¹æ³•
            const textarea = document.createElement('textarea');
            textarea.value = finalCode;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'å·²å¤åˆ¶!';
                copyBtn.style.background = '#007acc';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 1500);
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            } finally {
                document.body.removeChild(textarea);
            }
        };

        document.getElementById('modal-code').style.display = 'flex';

        // ç¡®ä¿å¤åˆ¶æŒ‰é’®åœ¨æ¯æ¬¡æ‰“å¼€æ¨¡æ€æ¡†æ—¶éƒ½æ˜¾ç¤ºä¸º"å¤åˆ¶ä»£ç "
        copyBtn.textContent = 'å¤åˆ¶ä»£ç ';
        copyBtn.style.background = '';
    },

    //--------------------å…³é—­æ‰€æœ‰æ¨¡æ€æ¡†
    closeModals() { document.querySelectorAll('.modal-mask, .modal-panel').forEach(m => m.style.display = 'none'); },


    
    //---------------------------
    // ä¿å­˜çŠ¶æ€ï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    save() {
        StorageSystem.save();
    },

    load() {
        // è¿™ä¸ªæ–¹æ³•åœ¨åˆå§‹åŒ–æ—¶å·²è°ƒç”¨
    },

    // æ¸…ç©ºæ‰€æœ‰ï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    clearAll() {
        StorageSystem.clearAll();
    },

    // å¯¼å‡ºJSONï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    exportJson() {
        StorageSystem.exportJson();
    },

    // å¯¼å…¥JSONï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    importJson() {
        StorageSystem.importJson();
    },

    // å¤„ç†æ–‡ä»¶å¯¼å…¥ï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    handleFileImport(event) {
        StorageSystem.handleFileImport(event);
    },

    // ä»JSONæ•°æ®åŠ è½½ç”»å¸ƒå†…å®¹ï¼ˆè°ƒç”¨å­˜å‚¨ç³»ç»Ÿï¼‰
    loadFromJson(data) {
        StorageSystem.loadFromJson(data);
    }
};
window.onload = () => app.init();


// help.js - ç‹¬ç«‹çš„å¸®åŠ©ç³»ç»Ÿæ¨¡å—
const HelpSystem = {
    // è®¾ç½®é¢æ¿å†…å®¹
    fallbackHelp: `
        <div class="help-container">
            <h1 class="help-title">åˆ†é•œå¼ç¼–è¾‘å™¨ - è®¾ç½®</h1>
            
            <!-- è®¾ç½®é€‰é¡¹ -->
            <div class="help-section">
                <h2>åŸºæœ¬è®¾ç½®</h2>
                
                <!-- éŸ³ä¹è®¾ç½® -->
                <div class="setting-item">
                    <label for="music-toggle-setting">éŸ³ä¹</label>
                    <button id="music-toggle-setting" class="setting-btn btn-green" onclick="AudioSystem.toggleMusic()">å¼€å¯</button>
                </div>
                
                <!-- èƒŒæ™¯è°ƒè‰²è®¾ç½® -->
                <div class="setting-item">
                    <label for="background-color">èƒŒæ™¯é¢œè‰²</label>
                    <div class="color-controls">
                        <input type="color" id="background-color" value="#1a1a1a" onchange="HelpSystem.changeBackgroundColor(this.value)">
                        <button class="setting-btn" onclick="HelpSystem.resetBackgroundColor()">æ¢å¤åˆå§‹é¢œè‰²</button>
                    </div>
                </div>
                
                <!-- è§†é¢‘å¤šæ’­æ”¾è®¾ç½® -->
                <div class="setting-item">
                    <label for="video-multiple-playback">è§†é¢‘å¤šæ’­æ”¾</label>
                    <button id="video-multiple-playback" class="setting-btn btn-gray" onclick="HelpSystem.toggleVideoMultiplePlayback()">å…³é—­</button>
                </div>
            </div>
            
            <!-- åŠŸèƒ½åˆ—è¡¨ -->
            <div class="help-section">
                <h2>åŠŸèƒ½åˆ—è¡¨</h2>
                <div class="feature-grid">
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ“‹</span>
                        <div class="feature-title">èŠ‚ç‚¹ç¼–è¾‘å™¨</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ–Œï¸</span>
                        <div class="feature-title">ç»˜ç”»æ ‡æ³¨</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ§®</span>
                        <div class="feature-title">æ•°å­¦è®¡ç®—</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ–¼ï¸</span>
                        <div class="feature-title">å›¾ç‰‡ç¼–è¾‘</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ“¤</span>
                        <div class="feature-title">ä»£ç åˆæˆ</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ–±ï¸</span>
                        <div class="feature-title">å›¾ç‰‡æ‹–æ‹½</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸ¬</span>
                        <div class="feature-title">è§†é¢‘æ’­æ”¾</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">ğŸµ</span>
                        <div class="feature-title">éŸ³é¢‘æ’­æ”¾</div>
                    </div>
                    
                    <div class="feature-panel">
                        <span class="feature-icon">âœ‚ï¸</span>
                        <div class="feature-title">å›¾ç‰‡åˆ†å‰²</div>
                    </div>
                     <div class="feature-panel">
                        <span class="feature-icon">ğŸ‘Œ</span>
                        <div class="feature-title">ç”»ä¸­ç”»</div>
                    </div>
                </div>
            </div>
            
            <style>
                .help-container {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    line-height: 1.6;
                    color: #9cdcfe;
                    padding: 0 10px;
                }
                
                .help-title {
                    text-align: center;
                    color: #569cd6;
                    margin-bottom: 30px;
                    font-size: 24px;
                }
                
                .help-section {
                    margin-bottom: 30px;
                    padding: 15px;
                    background: rgba(30, 41, 59, 0.8);
                    border-radius: 8px;
                    border: 1px solid #264f78;
                }
                
                .help-section h2 {
                    color: #4ec9b0;
                    margin: 0 0 15px 0;
                    font-size: 20px;
                    border-bottom: 1px solid #264f78;
                    padding-bottom: 8px;
                }
                
                /* è®¾ç½®é¡¹æ ·å¼ */
                .setting-item {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    margin-bottom: 20px;
                    padding: 15px;
                    background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(20, 21, 30, 0.8));
                    border-radius: 10px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    transition: all 0.3s ease;
                }
                
                .setting-item:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
                    border-color: rgba(33, 150, 243, 0.3);
                }
                
                .setting-item label {
                    font-weight: bold;
                    color: #9cdcfe;
                    font-size: 16px;
                    flex: 1;
                }
                
                /* ç¾åŒ–å¼€å…³æŒ‰é’® */
                .setting-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 25px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: bold;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                    min-width: 100px;
                    text-align: center;
                }
                
                .setting-btn.btn-green {
                    background: linear-gradient(135deg, #4caf50, #45a049);
                    color: white;
                    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
                }
                
                .setting-btn.btn-green:hover {
                    background: linear-gradient(135deg, #45a049, #3d8b40);
                    transform: translateY(-1px);
                    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.5);
                }
                
                .setting-btn.btn-gray {
                    background: linear-gradient(135deg, #666, #555);
                    color: #ccc;
                    box-shadow: 0 2px 8px rgba(102, 102, 102, 0.3);
                }
                
                .setting-btn.btn-gray:hover {
                    background: linear-gradient(135deg, #555, #444);
                    transform: translateY(-1px);
                    box-shadow: 0 4px 12px rgba(102, 102, 102, 0.4);
                }
                
                /* é¢œè‰²æ§åˆ¶å®¹å™¨ */
                .color-controls {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }
                
                /* ç¾åŒ–é¢œè‰²é€‰æ‹©å™¨ */
                input[type="color"] {
                    width: 60px;
                    height: 40px;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    background: transparent;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                    transition: all 0.3s ease;
                }
                
                input[type="color"]:hover {
                    transform: scale(1.05);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                }
                
                input[type="color"]::-webkit-color-swatch-wrapper {
                    padding: 0;
                    border-radius: 8px;
                }
                
                input[type="color"]::-webkit-color-swatch {
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 6px;
                }
                
                /* åŠŸèƒ½ç½‘æ ¼å¸ƒå±€ */
                .feature-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                    gap: 15px;
                    margin-top: 20px;
                }
                
                /* åŠŸèƒ½é¢æ¿ */
                .feature-panel {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(20, 21, 30, 0.8));
                    border-radius: 10px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    transition: all 0.3s ease;
                    text-align: center;
                }
                
                .feature-panel:hover {
                    transform: translateY(-3px);
                    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
                    border-color: rgba(33, 150, 243, 0.3);
                }
                
                .feature-icon {
                    font-size: 32px;
                    color: #4ec9b0;
                    margin-bottom: 10px;
                }
                
                .feature-title {
                    font-size: 14px;
                    font-weight: bold;
                    color: #9cdcfe;
                    text-align: center;
                }
            </style>
        </div>
        `,

    // æ˜¾ç¤ºè®¾ç½®é¢æ¿
    showHelp() {
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }

        const helpContentDiv = document.getElementById('help-content');
        if (helpContentDiv) {
            helpContentDiv.innerHTML = this.fallbackHelp;
            // æ›´æ–°éŸ³ä¹æŒ‰é’®çŠ¶æ€
            this.updateMusicButtonState();
            // æ›´æ–°èƒŒæ™¯é¢œè‰²é€‰æ‹©å™¨çš„å€¼
            this.updateColorPickerValue();
            // æ›´æ–°è§†é¢‘å¤šæ’­æ”¾æŒ‰é’®çŠ¶æ€
            this.updateVideoMultiplePlaybackButtonState();
        }
        const helpModal = document.getElementById('modal-help');
        if (helpModal) {
            helpModal.style.display = 'flex';
        }
    },
    
    // åˆ‡æ¢è§†é¢‘å¤šæ’­æ”¾çŠ¶æ€
    toggleVideoMultiplePlayback() {
        if (window.VideoSystem) {
            const newState = VideoSystem.toggleMultiplePlayback();
            this.updateVideoMultiplePlaybackButtonState();
            // å¦‚æœå…³é—­å¤šè§†é¢‘æ’­æ”¾ï¼Œæš‚åœæ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„è§†é¢‘
            if (!newState) {
                VideoSystem.pauseAllVideos();
            }
        }
    },
    
    // æ›´æ–°è§†é¢‘å¤šæ’­æ”¾æŒ‰é’®çŠ¶æ€
    updateVideoMultiplePlaybackButtonState() {
        const button = document.getElementById('video-multiple-playback');
        if (button && window.VideoSystem) {
            const isEnabled = VideoSystem.getAllowMultiplePlayback();
            if (isEnabled) {
                button.className = 'setting-btn btn-green';
                button.textContent = 'å¼€å¯';
            } else {
                button.className = 'setting-btn btn-gray';
                button.textContent = 'å…³é—­';
            }
        }
    },
    
    // æ›´æ–°èƒŒæ™¯é¢œè‰²é€‰æ‹©å™¨çš„å€¼
    updateColorPickerValue() {
        const colorInput = document.getElementById('background-color');
        if (colorInput) {
            const savedColor = localStorage.getItem('editorBackgroundColor');
            if (savedColor) {
                colorInput.value = savedColor;
            }
        }
    },
    
    // æ›´æ–°éŸ³ä¹æŒ‰é’®çŠ¶æ€
    updateMusicButtonState() {
        const button = document.getElementById('music-toggle-setting');
        if (button && window.AudioSystem) {
            if (AudioSystem.enabled) {
                button.className = 'setting-btn btn-green';
                button.textContent = 'å¼€å¯';
            } else {
                button.className = 'setting-btn btn-gray';
                button.textContent = 'å…³é—­';
            }
        }
    },
    
    // æ”¹å˜èƒŒæ™¯é¢œè‰²
    changeBackgroundColor(color) {
        const viewport = document.getElementById('viewport');
        if (viewport) {
            viewport.style.backgroundColor = color;
        }
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('editorBackgroundColor', color);
    },
    
    // æ¢å¤åˆå§‹é¢œè‰²
    resetBackgroundColor() {
        // Comfy UIé£æ ¼çš„æ·±ç°è‰²èƒŒæ™¯
        const initialColor = '#1a1a1a';
        this.changeBackgroundColor(initialColor);
        // æ›´æ–°é¢œè‰²é€‰æ‹©å™¨çš„å€¼
        const colorInput = document.getElementById('background-color');
        if (colorInput) {
            colorInput.value = initialColor;
        }
    }
};

// åˆå§‹åŒ–è®¾ç½®
HelpSystem.init = function() {
    // åŠ è½½ä¿å­˜çš„èƒŒæ™¯é¢œè‰²
    const savedColor = localStorage.getItem('editorBackgroundColor');
    if (savedColor) {
        this.changeBackgroundColor(savedColor);
    }
};

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
window.addEventListener('load', function() {
    HelpSystem.init();
});

// å°†æ¨¡å—æš´éœ²ç»™å…¨å±€
window.HelpSystem = HelpSystem;

class InfiniteCanvas {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.camera = {
            x: 0,
            y: 0,
            scale: 1
        };
        this.strokes = [];
        this.currentStroke = null;
        this.drawing = false;
        this.panning = false;
        this.lastX = 0;
        this.lastY = 0;
        this.isActive = false;
        this.animationId = null;
    }

    init() {
        this.canvas = document.getElementById('infinite-canvas');
        if (!this.canvas) {
            console.error('Infinite canvas element not found');
            return false;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
        
        return true;
    }

    resize() {
        if (this.canvas) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }
    }

    screenToWorld(x, y) {
        return {
            x: x / this.camera.scale + this.camera.x,
            y: y / this.camera.scale + this.camera.y
        };
    }

    startStroke(x, y) {
        const brushColor = window.DrawingManager ? DrawingManager.brushColor : '#000000';
        const brushSize = window.DrawingManager ? DrawingManager.brushSize : 3;
        
        this.currentStroke = {
            points: [{ x, y }],
            width: brushSize,
            color: brushColor
        };
        this.strokes.push(this.currentStroke);
    }

    addPoint(x, y) {
        const last = this.currentStroke.points.at(-1);
        const dx = x - last.x;
        const dy = y - last.y;

        if (dx * dx + dy * dy > 0.5) {
            this.currentStroke.points.push({ x, y });
        }
    }

    endStroke() {
        this.currentStroke = null;
    }

    render() {
        if (!this.ctx || !this.isActive) return;

        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.setTransform(
            this.camera.scale,
            0,
            0,
            this.camera.scale,
            -this.camera.x * this.camera.scale,
            -this.camera.y * this.camera.scale
        );

        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        for (const stroke of this.strokes) {
            this.ctx.beginPath();
            this.ctx.lineWidth = stroke.width / this.camera.scale;
            this.ctx.strokeStyle = stroke.color;

            stroke.points.forEach((p, i) => {
                if (i === 0) this.ctx.moveTo(p.x, p.y);
                else this.ctx.lineTo(p.x, p.y);
            });

            this.ctx.stroke();
        }

        this.animationId = requestAnimationFrame(() => this.render());
    }

    eraseAt(x, y) {
        const brushSize = window.DrawingManager ? DrawingManager.brushSize : 3;
        const eraseRadius = brushSize * 2;
        const newStrokes = [];

        for (const stroke of this.strokes) {
            let isStrokeErased = false;
            const newPoints = [];

            for (let i = 0; i < stroke.points.length; i++) {
                const p = stroke.points[i];
                const dx = x - p.x;
                const dy = y - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > eraseRadius) {
                    newPoints.push(p);
                } else {
                    isStrokeErased = true;
                }
            }

            if (newPoints.length > 1) {
                newStrokes.push({
                    points: newPoints,
                    width: stroke.width,
                    color: stroke.color
                });
            }
        }

        this.strokes = newStrokes;
    }

    activate() {
        if (this.isActive) return;
        
        if (!this.init()) return false;
        
        this.isActive = true;
        this.canvas.style.display = 'block';
        
        // è‡ªåŠ¨æ¿€æ´»ç¬”åˆ·å·¥å…·
        if (window.DrawingManager) {
            DrawingManager.currentTool = 'brush';
            // æ›´æ–°åº•éƒ¨å·¥å…·æ æŒ‰é’®çŠ¶æ€
            const brushBtn = document.querySelector('[data-tool="brush"]');
            if (brushBtn) {
                document.querySelectorAll('.tool-btn').forEach(b => {
                    b.classList.remove('active');
                });
                brushBtn.classList.add('active');
            }
            // æš‚æ—¶ç¦ç”¨DrawingManagerçš„ç»˜ç”»åŠŸèƒ½
            if (typeof DrawingManager.isInfiniteCanvasMode === 'undefined') {
                DrawingManager.isInfiniteCanvasMode = true;
            } else {
                DrawingManager.isInfiniteCanvasMode = true;
            }
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        this.updateButtonState();
        
        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        window.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
        
        // æ·»åŠ æ¸…é™¤æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        const clearBtn = document.getElementById('clear-drawing-btn');
        if (clearBtn) {
            this.clearBtnHandler = (e) => {
                console.log('Clear button clicked in infinite canvas mode');
                e.stopPropagation();
                e.preventDefault();
                if (confirm('ç¡®å®šè¦æ¸…ç©ºæ— é™ç”»å¸ƒå—ï¼Ÿ')) {
                    this.clear();
                }
            };
            clearBtn.addEventListener('click', this.clearBtnHandler, true);
        }
        
        this.render();
        console.log('Infinite canvas activated, isActive:', this.isActive, 'global active:', window.isInfiniteCanvasActive());
        return true;
    }

    deactivate() {
        if (!this.isActive) return;
        
        this.isActive = false;
        this.canvas.style.display = 'none';
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        this.updateButtonState();
        
        // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
        this.canvas.removeEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.removeEventListener('mousemove', this.handleMouseMove.bind(this));
        window.removeEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.removeEventListener('contextmenu', this.handleContextMenu.bind(this));
        this.canvas.removeEventListener('wheel', this.handleWheel.bind(this));
        this.canvas.removeEventListener('wheel', this.handleWheel.bind(this), { passive: false });
        
        // ç§»é™¤æ¸…é™¤æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        const clearBtn = document.getElementById('clear-drawing-btn');
        if (clearBtn && this.clearBtnHandler) {
            clearBtn.removeEventListener('click', this.clearBtnHandler, true);
            this.clearBtnHandler = null;
        }
        
        // é‡æ–°å¯ç”¨DrawingManagerçš„ç»˜ç”»åŠŸèƒ½
        if (window.DrawingManager) {
            DrawingManager.isInfiniteCanvasMode = false;
        }
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        console.log('Infinite canvas deactivated, isActive:', this.isActive, 'global active:', window.isInfiniteCanvasActive());
    }

    updateButtonState() {
        const btn = document.getElementById('infinite-canvas-btn');
        if (btn) {
            if (this.isActive) {
                btn.classList.add('active');
                btn.style.backgroundColor = '#4CAF50';
                btn.style.color = 'white';
            } else {
                btn.classList.remove('active');
                btn.style.backgroundColor = '';
                btn.style.color = '';
            }
        }
    }

    handleMouseDown(e) {
        e.stopPropagation();
        if (e.button === 0) {
            this.drawing = true;
            const p = this.screenToWorld(e.clientX, e.clientY);
            
            if (window.DrawingManager) {
                console.log('Current tool:', DrawingManager.currentTool);
                if (DrawingManager.currentTool === 'brush') {
                    this.startStroke(p.x, p.y);
                } else if (DrawingManager.currentTool === 'eraser') {
                    this.eraseAt(p.x, p.y);
                }
            } else {
                // fallback if DrawingManager is not available
                this.startStroke(p.x, p.y);
            }
        } else if (e.button === 2) {
            this.panning = true;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
        }
    }

    handleMouseMove(e) {
        e.stopPropagation();
        if (this.drawing) {
            const p = this.screenToWorld(e.clientX, e.clientY);
            
            if (window.DrawingManager) {
                if (DrawingManager.currentTool === 'brush') {
                    this.addPoint(p.x, p.y);
                } else if (DrawingManager.currentTool === 'eraser') {
                    this.eraseAt(p.x, p.y);
                }
            } else {
                // fallback if DrawingManager is not available
                this.addPoint(p.x, p.y);
            }
        } else if (this.panning) {
            const dx = (e.clientX - this.lastX) / this.camera.scale;
            const dy = (e.clientY - this.lastY) / this.camera.scale;

            this.camera.x -= dx;
            this.camera.y -= dy;

            this.lastX = e.clientX;
            this.lastY = e.clientY;
        }
    }

    handleMouseUp(e) {
        if (e) {
            e.stopPropagation();
        }
        this.drawing = false;
        this.panning = false;
        this.endStroke();
    }

    handleContextMenu(e) {
        e.preventDefault();
    }

    handleWheel(e) {
        e.preventDefault();

        const mouseX = e.clientX;
        const mouseY = e.clientY;

        const oldScale = this.camera.scale;
        const zoom = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = oldScale * zoom;

        const worldX = mouseX / oldScale + this.camera.x;
        const worldY = mouseY / oldScale + this.camera.y;

        this.camera.scale = newScale;

        this.camera.x = worldX - mouseX / newScale;
        this.camera.y = worldY - mouseY / newScale;
    }

    clear() {
        this.strokes = [];
        this.currentStroke = null;
    }
}

const infiniteCanvas = new InfiniteCanvas();
// å…¨å±€å‡½æ•°ï¼Œç”¨äºæ£€æŸ¥æ— é™ç”»å¸ƒæ˜¯å¦æ¿€æ´»
window.isInfiniteCanvasActive = function() {
    return infiniteCanvas && infiniteCanvas.isActive;
};


// drawing.js
const DrawingManager = {
    // ç»˜ç”»åŠŸèƒ½çš„çŠ¶æ€
    isDrawing: false,
    isErasing: false,
    currentTool: null,
    brushColor: '#000000',
    brushSize: 3,
    paths: [],
    currentPath: null,
    drawingGroup: null,
    vp: null,
    app: null,
    
    // EmojiåŠŸèƒ½çš„çŠ¶æ€
    isEmojiMode: false,
    selectedEmoji: null,
    emojiMenu: null,
    emojiGrid: null,
    isDraggingEmoji: false,
    emojis: [],

    // --- ç»˜ç”»åŠŸèƒ½ç›¸å…³æ–¹æ³• ---
    initDrawing(vp, app) {
        this.vp = vp;
        this.app = app;

        // åˆ›å»ºç»˜ç”»ç»„
        const svgCanvas = document.getElementById('svg-canvas');
        this.drawingGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.drawingGroup.id = 'drawing-group';
        svgCanvas.appendChild(this.drawingGroup);

        // è®¾ç½®ç»˜ç”»ç»„çš„z-indexï¼Œç¡®ä¿åœ¨èŠ‚ç‚¹å’Œè¿æ¥çº¿ä¹‹ä¸Š
        this.drawingGroup.style.zIndex = '15';

        // åˆå§‹åŒ–å·¥å…·æ äº‹ä»¶
        this.setupDrawingToolbarEvents();
        
        // åˆå§‹åŒ–Emojièœå•
        this.setupEmojiMenu();
    },

    // è®¾ç½®ç»˜ç”»å·¥å…·æ äº‹ä»¶
    // drawing.js - ä¿®å¤åçš„ setupDrawingToolbarEvents æ–¹æ³•
    setupDrawingToolbarEvents() {
        // å·¥å…·æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                AudioSystem.playButtonSound();
                const tool = e.target.dataset.tool;

                // ç‰¹æ®Šå¤„ç†æ¸…ç©ºå·¥å…·
        if (tool === 'clear') {
            console.log('Clear button clicked, infiniteCanvas:', window.infiniteCanvas);
            const isInfiniteActive = typeof window.isInfiniteCanvasActive === 'function' && window.isInfiniteCanvasActive();
            console.log('Global infinite canvas active:', isInfiniteActive);
            if (isInfiniteActive) {
                // å¦‚æœæ— é™ç”»å¸ƒæ¿€æ´»ï¼Œåªæ¸…ç©ºæ— é™ç”»å¸ƒ
                console.log('Clearing infinite canvas');
                window.infiniteCanvas.clear();
            } else {
                // å¦åˆ™æ¸…ç©ºæ™®é€šç”»å¸ƒ
                console.log('Clearing regular canvas');
                this.clearDrawing();
            }
            return;
        }

                // åˆ‡æ¢ç”»ç¬”/æ©¡çš®æ“¦å·¥å…·çš„æ¿€æ´»çŠ¶æ€
                if (tool === 'brush' || tool === 'eraser') {
                    // æ£€æŸ¥å½“å‰æ˜¯å¦å·²æ¿€æ´»è¯¥å·¥å…·
                    const isActive = e.target.classList.contains('active');

                    // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeç±»
                    document.querySelectorAll('.tool-btn').forEach(b => {
                        b.classList.remove('active');
                    });

                    if (!isActive) {
                        // æ¿€æ´»å½“å‰å·¥å…·
                        e.target.classList.add('active');
                        this.currentTool = tool;
                        // æ›´æ”¹é¼ æ ‡å›¾æ ‡å’Œç”»å¸ƒçŠ¶æ€
                        if (this.vp) {
                            this.vp.style.cursor = tool === 'brush' ? 'crosshair' : 'pointer';
                            if (tool === 'brush') {
                                this.vp.classList.add('drawing-active');
                                this.vp.classList.remove('erasing-active');
                            } else if (tool === 'eraser') {
                                this.vp.classList.add('erasing-active');
                                this.vp.classList.remove('drawing-active');
                            }
                        }
                    } else {
                        // å–æ¶ˆæ¿€æ´»ï¼Œæ¢å¤é»˜è®¤å·¥å…·
                        this.currentTool = null;
                        // æ¢å¤é»˜è®¤é¼ æ ‡å›¾æ ‡å’Œç”»å¸ƒçŠ¶æ€
                        if (this.vp) {
                            this.vp.style.cursor = 'grab';
                            this.vp.classList.remove('drawing-active', 'erasing-active');
                        }
                    }
                } else if (tool === 'emoji') {
                    // å¤„ç†emojiå·¥å…·
                    this.toggleEmojiMenu(e.target);
                } else {
                    // å…¶ä»–å·¥å…·å¤„ç†
                    document.querySelectorAll('.tool-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    e.target.classList.add('active');
                    this.currentTool = tool;
                    // æ¢å¤é»˜è®¤é¼ æ ‡å›¾æ ‡å’Œç”»å¸ƒçŠ¶æ€
                    if (this.vp) {
                        this.vp.style.cursor = 'grab';
                        this.vp.classList.remove('drawing-active', 'erasing-active');
                    }
                }
            });
        });

        // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
        const colorPicker = document.getElementById('brush-color');
        const colorValue = document.querySelector('.color-value');

        // åˆå§‹åŒ–é¢œè‰²å€¼
        this.brushColor = colorPicker.value;
        if (colorValue) {
            colorValue.textContent = colorPicker.value;
        }

        colorPicker.addEventListener('input', (e) => {
            this.brushColor = e.target.value;
            if (colorValue) {
                colorValue.textContent = e.target.value;
            }
        });

        // ç²—ç»†æ»‘å—äº‹ä»¶
        const sizeSlider = document.getElementById('brush-size');
        const sizeValue = document.querySelector('.size-value');
        sizeSlider.addEventListener('input', (e) => {
            this.brushSize = parseInt(e.target.value);
            if (sizeValue) {
                sizeValue.textContent = `${e.target.value}px`;
            }
        });

        // æ³¨æ„ï¼šè¿™é‡Œä¸è¦æ·»åŠ å…¨å±€ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨ï¼
        // å®ƒä¼šå¹²æ‰°ç»˜ç”»åŠŸèƒ½çš„æ­£å¸¸å·¥ä½œ
    },

    // å¼€å§‹ç»˜ç”»
    startDrawing(x, y) {
        // å¦‚æœæ˜¯æ— é™ç”»å¸ƒæ¨¡å¼ï¼Œä¸å¤„ç†
        if (this.isInfiniteCanvasMode) return;
        
        if (this.currentTool === 'brush') {
            this.isDrawing = true;
            this.currentPath = {
                id: Date.now(),
                color: this.brushColor,
                size: this.brushSize,
                points: [{ x, y }]
            };
        } else if (this.currentTool === 'eraser') {
            // æ©¡çš®æ“¦å·¥å…·å¼€å§‹æ“¦é™¤
            this.erase(x, y);
            // è®¾ç½®æ“¦é™¤çŠ¶æ€ï¼Œç”¨äºè¿ç»­æ“¦é™¤
            this.isErasing = true;
        }
    },

    // ç»˜åˆ¶è¿‡ç¨‹
    draw(x, y) {
        // å¦‚æœæ˜¯æ— é™ç”»å¸ƒæ¨¡å¼ï¼Œä¸å¤„ç†
        if (this.isInfiniteCanvasMode) return;
        
        if (this.currentTool === 'brush' && this.isDrawing) {
            // ç”»ç¬”ç»˜åˆ¶
            this.currentPath.points.push({ x, y });
            this.renderCurrentPath();
        } else if (this.currentTool === 'eraser' && this.isErasing) {
            // æ©¡çš®æ“¦è¿ç»­æ“¦é™¤
            this.erase(x, y);
        }
    },

    // ç»“æŸç»˜ç”»
    endDrawing() {
        // å¦‚æœæ˜¯æ— é™ç”»å¸ƒæ¨¡å¼ï¼Œä¸å¤„ç†
        if (this.isInfiniteCanvasMode) return;
        
        if (this.isDrawing && this.currentPath) {
            // ç¡®ä¿è·¯å¾„æœ‰è¶³å¤Ÿçš„ç‚¹
            if (this.currentPath.points.length > 1) {
                this.paths.push(this.currentPath);
                this.renderPath(this.currentPath);
            } else {
                // æ¸…é™¤ä¸´æ—¶è·¯å¾„ï¼Œé¿å…è§†è§‰æ®‹ç•™
                const tempPath = document.getElementById('temp-drawing-path');
                if (tempPath) {
                    tempPath.remove();
                }
            }
            this.currentPath = null;
            this.isDrawing = false;
            if (this.app && this.app.save) {
                this.app.save();
            }
        }

        // ç»“æŸæ“¦é™¤çŠ¶æ€
        this.isErasing = false;
    },

    // æ¸²æŸ“å½“å‰æ­£åœ¨ç»˜åˆ¶çš„è·¯å¾„
    renderCurrentPath() {
        // æ¸…é™¤ä¹‹å‰çš„ä¸´æ—¶è·¯å¾„
        const tempPath = document.getElementById('temp-drawing-path');
        if (tempPath) {
            tempPath.remove();
        }

        // åˆ›å»ºä¸´æ—¶è·¯å¾„
        const path = this.createPathElement(this.currentPath);
        path.id = 'temp-drawing-path';
        if (this.drawingGroup) {
            this.drawingGroup.appendChild(path);
        }
    },

    // æ¸²æŸ“å•ä¸ªè·¯å¾„
    renderPath(pathData) {
        // æ¸…é™¤ä¸´æ—¶è·¯å¾„ï¼Œé¿å…è§†è§‰æ®‹ç•™
        const tempPath = document.getElementById('temp-drawing-path');
        if (tempPath) {
            tempPath.remove();
        }

        const path = this.createPathElement(pathData);
        path.id = `drawing-path-${pathData.id}`;
        if (this.drawingGroup) {
            this.drawingGroup.appendChild(path);
        }
    },

    // åˆ›å»ºè·¯å¾„å…ƒç´ 
    createPathElement(pathData) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = this.generatePathD(pathData.points);
        path.setAttribute('d', d);
        path.setAttribute('class', 'drawing-path');
        path.setAttribute('stroke', pathData.color);
        path.setAttribute('stroke-width', pathData.size);
        path.setAttribute('fill', 'none');
        return path;
    },

    // ç”Ÿæˆè·¯å¾„çš„då±æ€§
    generatePathD(points) {
        if (points.length < 2) return '';

        let d = `M ${points[0].x} ${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
            d += ` L ${points[i].x} ${points[i].y}`;
        }
        return d;
    },

    // æ“¦é™¤åŠŸèƒ½
    erase(x, y) {
        // å¦‚æœæ˜¯æ— é™ç”»å¸ƒæ¨¡å¼ï¼Œä¸å¤„ç†
        if (this.isInfiniteCanvasMode) return;
        
        let hasErased = false;

        // 1. æ£€æŸ¥å¹¶å¤„ç†å·²ä¿å­˜çš„è·¯å¾„
        for (let i = this.paths.length - 1; i >= 0; i--) {
            const path = this.paths[i];
            if (this.isPointNearPath(x, y, path)) {
                // ç§»é™¤è·¯å¾„
                this.paths.splice(i, 1);
                // ç§»é™¤å¯¹åº”çš„SVGå…ƒç´ 
                const pathElement = document.getElementById(`drawing-path-${path.id}`);
                if (pathElement) {
                    pathElement.remove();
                }
                hasErased = true;
            }
        }

        // 2. æ£€æŸ¥å¹¶å¤„ç†å½“å‰æ­£åœ¨ç»˜åˆ¶çš„ä¸´æ—¶è·¯å¾„
        if (this.currentPath && this.isPointNearPath(x, y, this.currentPath)) {
            // å¦‚æœä¸´æ—¶è·¯å¾„è¢«æ“¦é™¤ï¼Œç»“æŸå½“å‰ç»˜åˆ¶
            this.currentPath = null;
            this.isDrawing = false;
            // ç§»é™¤ä¸´æ—¶è·¯å¾„çš„SVGå…ƒç´ 
            const tempPath = document.getElementById('temp-drawing-path');
            if (tempPath) {
                tempPath.remove();
            }
            hasErased = true;
        }
        
        // 3. æ£€æŸ¥å¹¶å¤„ç†emojiå…ƒç´ 
        for (let i = this.emojis.length - 1; i >= 0; i--) {
            const emoji = this.emojis[i];
            if (this.isPointNearEmoji(x, y, emoji)) {
                // ç§»é™¤emojiå…ƒç´ 
                if (emoji.element && emoji.element.parentNode) {
                    emoji.element.parentNode.removeChild(emoji.element);
                }
                // ä»emojisæ•°ç»„ä¸­ç§»é™¤
                this.emojis.splice(i, 1);
                hasErased = true;
            }
        }

        // 4. ç«‹å³é‡ç»˜æ‰€æœ‰è·¯å¾„ï¼Œç¡®ä¿è§†è§‰æ›´æ–°
        this.renderAllDrawingPaths();

        // 5. å¦‚æœæœ‰æ“¦é™¤æ“ä½œï¼Œä¿å­˜å¹¶æ›´æ–°
        if (hasErased && this.app && this.app.save) {
            this.app.save();
        }
    },
    
    // æ£€æŸ¥ç‚¹æ˜¯å¦é è¿‘emoji
    isPointNearEmoji(x, y, emoji) {
        const threshold = 50; // æ“¦é™¤é˜ˆå€¼ï¼Œå•ä½åƒç´ 
        const emojiX = emoji.x + 25; // emojiä¸­å¿ƒxåæ ‡
        const emojiY = emoji.y + 25; // emojiä¸­å¿ƒyåæ ‡
        
        // è®¡ç®—ç‚¹åˆ°emojiä¸­å¿ƒçš„è·ç¦»
        const dx = x - emojiX;
        const dy = y - emojiY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        return distance <= threshold;
    },

    // æ£€æŸ¥ç‚¹æ˜¯å¦é è¿‘è·¯å¾„
    isPointNearPath(x, y, path) {
        const points = path.points;
        const threshold = this.brushSize + 10; // å¤§å¹…å¢åŠ é˜ˆå€¼ï¼Œä½¿æ©¡çš®æ“¦æ›´å®¹æ˜“æ“¦åˆ°

        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];

            // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
            const distance = this.getDistanceToLine(x, y, p1, p2);
            if (distance <= threshold) {
                return true;
            }
        }
        return false;
    },

    // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
    getDistanceToLine(px, py, p1, p2) {
        const A = px - p1.x;
        const B = py - p1.y;
        const C = p2.x - p1.x;
        const D = p2.y - p1.y;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let xx, yy;

        if (param < 0) {
            xx = p1.x;
            yy = p1.y;
        } else if (param > 1) {
            xx = p2.x;
            yy = p2.y;
        } else {
            xx = p1.x + param * C;
            yy = p1.y + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    },

    // æ¸…ç©ºç»˜ç”»
    clearDrawing() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç»˜ç”»å—ï¼Ÿ')) {
            AudioSystem.playButtonSound();
            // æ¸…ç©ºè·¯å¾„æ•°ç»„
            this.paths = [];
            // æ¸…ç©ºSVGä¸­çš„æ‰€æœ‰è·¯å¾„
            if (this.drawingGroup) {
                this.drawingGroup.innerHTML = '';
            }
            
            // æ¸…ç©ºemojiæ•°ç»„å’Œç”»å¸ƒä¸­çš„æ‰€æœ‰emojiå…ƒç´ 
            this.emojis.forEach(emoji => {
                if (emoji.element && emoji.element.parentNode) {
                    emoji.element.parentNode.removeChild(emoji.element);
                }
            });
            this.emojis = [];
            
            if (this.app && this.app.save) {
                this.app.save();
            }
        }
    },

    // æ¸²æŸ“æ‰€æœ‰ç»˜ç”»è·¯å¾„
    renderAllDrawingPaths() {
        if (!this.drawingGroup) return;

        // æ¸…ç©ºç°æœ‰è·¯å¾„
        this.drawingGroup.innerHTML = '';

        // æ¸²æŸ“æ‰€æœ‰è·¯å¾„
        this.paths.forEach(path => {
            this.renderPath(path);
        });
    },

    isDrawingMode() {
        // å¦‚æœå½“å‰å·¥å…·æ˜¯ç”»ç¬”æˆ–æ©¡çš®æ“¦ï¼Œå°±è®¤ä¸ºæ˜¯ç»˜ç”»æ¨¡å¼
        return this.currentTool === 'brush' || this.currentTool === 'eraser';
    },
    // è¿˜å¯ä»¥æ·»åŠ ä¸€ä¸ªæ–¹æ³•æ¥æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç»˜ç”»ä¸­
    isInDrawing() {
        return this.isDrawing || this.isErasing;
    },
    
    // --- EmojiåŠŸèƒ½ç›¸å…³æ–¹æ³• --- 
    setupEmojiMenu() {
        this.emojiMenu = document.getElementById('emoji-menu');
        this.emojiGrid = this.emojiMenu.querySelector('.emoji-grid');
        
        // åˆ†ç±»emojiåˆ—è¡¨
        const emojis = [
            // ä¸­åŒ»ä¸ƒæƒ… - å–œï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ™‚', 'ğŸ˜Š', 'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ¤£',
            // ä¸­åŒ»ä¸ƒæƒ… - æ€’ï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ˜’', 'ğŸ˜ ', 'ğŸ˜¡', 'ğŸ˜¤', 'ğŸ¤¬', 'ğŸ¤¯', 'ğŸ˜ˆ', 'ğŸ‘¿',
            // ä¸­åŒ»ä¸ƒæƒ… - å¿§ï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ™', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜', 'ğŸ˜£', 'ğŸ˜–', 'ğŸ˜«', 'ğŸ˜©',
            // ä¸­åŒ»ä¸ƒæƒ… - æ€ï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ¤”', 'ğŸ§', 'ğŸ˜Œ', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¬', 'ğŸ¤',
            // ä¸­åŒ»ä¸ƒæƒ… - æ‚²ï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'â˜¹ï¸', 'ğŸ˜•', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ¥º', 'ğŸ˜ª', 'ğŸ˜“', 'ğŸ˜¥',
            // ä¸­åŒ»ä¸ƒæƒ… - æï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ˜±', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜³', 'ğŸ˜§', 'ğŸ˜¦', 'ğŸ˜®', 'ğŸ˜²',
            // ä¸­åŒ»ä¸ƒæƒ… - æƒŠï¼ˆä»è½»å¾®åˆ°é‡åº¦ï¼‰
            'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ˜±', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ¥µ', 'ğŸ¥¶',
            
            // æˆ˜æ——ç³»åˆ— - å†›äº‹ç›¸å…³
            'ğŸ´', 'ğŸ³ï¸', 'ğŸ', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸš€',
            'âœˆï¸', 'ğŸš›', 'ğŸšœ', 'ğŸ’£', 'ğŸ¯', 'ğŸ”«',
            'ğŸ¹', 'âš™ï¸', 'â›“ï¸', 'âš ï¸',
            'ğŸ°', 'ğŸ®', 'ğŸª', 'ğŸ­', 'ğŸ¨', 'ğŸ¬',
            
            // å¤©æ°”
            'â˜€ï¸', 'ğŸŒ¤ï¸', 'â›…', 'ğŸŒ¥ï¸', 'â˜ï¸', 'ğŸŒ¦ï¸', 'ğŸŒ§ï¸', 'â›ˆï¸',
            'ğŸŒ©ï¸', 'âš¡', 'ğŸŒªï¸', 'ğŸŒ«ï¸', 'ğŸŒ¬ï¸', 'â„ï¸', 'â˜ƒï¸',
            'â›„', 'ğŸŒ¨ï¸', 'ğŸŒŠ', 'â˜”', 'ğŸŒˆ', 'ğŸŒ‚',
            'ğŸŒ', 'ğŸŒ', 'ğŸŒ›', 'ğŸŒœ', 'ğŸŒš', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—',
            
            // è‡ªç„¶å±±å·
            'ğŸ”ï¸', 'â›°ï¸', 'ğŸŒ‹', 'ğŸŒ„', 'ğŸŒ…', 'ğŸŒ†',
            'ğŸŒ‡', 'ğŸŒ‰', 'ğŸŒŒ', 'ğŸŒ ', 'ğŸ•ï¸', 'â›º',
            'ğŸ–ï¸', 'ğŸï¸', 'ğŸœï¸', 'ğŸï¸', 'ğŸŸï¸', 'ğŸ¢', 'ğŸ ',
            
            // åŠ¨ç‰©
            'ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼',
            'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ½', 'ğŸ¸', 'ğŸµ',
            'ğŸ™ˆ', 'ğŸ™‰', 'ğŸ™Š', 'ğŸ’', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¤',
            'ğŸ£', 'ğŸ¥', 'ğŸ¦†', 'ğŸ¦…', 'ğŸ¦‰', 'ğŸ¦‡', 'ğŸº', 'ğŸ—',
            'ğŸ´', 'ğŸ¦„', 'ğŸ', 'ğŸª±', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ',
            'ğŸœ', 'ğŸ¦Ÿ', 'ğŸ¦—', 'ğŸ•·ï¸', 'ğŸ•¸ï¸', 'ğŸ¦‚', 'ğŸ¢', 'ğŸ',
            'ğŸ¦', 'ğŸ¦–', 'ğŸ¦•', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦', 'ğŸ¦', 'ğŸ¦€',
            'ğŸ¡', 'ğŸ ', 'ğŸŸ', 'ğŸ¬', 'ğŸ³', 'ğŸ‹', 'ğŸ¦ˆ', 'ğŸŠ',
            
            // äººç‰©
            'ğŸ‘¶', 'ğŸ‘§', 'ğŸ§’', 'ğŸ‘¦', 'ğŸ‘©', 'ğŸ§‘', 'ğŸ‘¨',
            'ğŸ§“', 'ğŸ‘´', 'ğŸ‘±', 'ğŸ‘©â€ğŸ¦°', 'ğŸ‘¨â€ğŸ¦°', 'ğŸ‘©â€ğŸ¦±',
            'ğŸ‘±â€â™€ï¸', 'ğŸ‘±â€â™‚ï¸',
            'ğŸ‘®â€â™‚ï¸', 'ğŸ‘·', 'ğŸ‘·â€â™€ï¸',
            'ğŸ‘©â€âš•ï¸', 'ğŸ‘©â€ğŸ“', 'ğŸ‘¨â€ğŸ«',
            'ğŸ‘¨â€ğŸ’»', 'ğŸ‘©â€ğŸ’¼', 'ğŸ‘¨â€ğŸ’¼', 'ğŸ‘©â€ğŸ”§',
            'ğŸ‘¨â€ğŸ”§', 'ğŸ‘©â€ğŸ¤', 'ğŸ‘¨â€ğŸ¤', 'ğŸ‘©â€ğŸ¨', 'ğŸ‘¨â€ğŸ¨', 'ğŸ‘©â€âœˆï¸',
            'ğŸ‘¨â€âœˆï¸', 'ğŸ‘©â€ğŸš€', 'ğŸ‘¸', 'ğŸ‘³',
            
            // æˆ¿å­
            'ğŸ ', 'ğŸ¡', 'ğŸ¢', 'ğŸ£', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦', 'ğŸ¨',
            'ğŸ©', 'ğŸª', 'ğŸ«', 'ğŸ¬', 'ğŸ­', 'ğŸ¯', 'ğŸ°', 'ğŸ’’',
            'ğŸ—½', 'ğŸŒ', 'ğŸŒƒ', 'ğŸŒ„', 'ğŸŒ…', 'ğŸŒ†',
            'ğŸŒ‡', 'ğŸŒ‰', 'ğŸŒŒ', 'ğŸŒ ', 'ğŸï¸', 'ğŸœï¸', 'ğŸ–ï¸'
        ];
        
        // å¡«å……emojiç½‘æ ¼
        emojis.forEach(emoji => {
            const emojiBtn = document.createElement('button');
            emojiBtn.textContent = emoji;
            emojiBtn.style.fontSize = '24px';
            emojiBtn.style.width = '40px';
            emojiBtn.style.height = '40px';
            emojiBtn.style.border = 'none';
            emojiBtn.style.borderRadius = '8px';
            emojiBtn.style.background = 'rgba(68, 68, 68, 0.8)';
            emojiBtn.style.cursor = 'pointer';
            emojiBtn.style.transition = 'all 0.2s ease';
            emojiBtn.addEventListener('mouseenter', () => {
                emojiBtn.style.transform = 'scale(1.2)';
                emojiBtn.style.background = 'rgba(33, 150, 243, 0.5)';
            });
            emojiBtn.addEventListener('mouseleave', () => {
                emojiBtn.style.transform = 'scale(1)';
                emojiBtn.style.background = 'rgba(68, 68, 68, 0.8)';
            });
            emojiBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.selectEmoji(emoji);
            });
            this.emojiGrid.appendChild(emojiBtn);
        });
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­emojièœå•
        document.addEventListener('click', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ç”»å¸ƒä¸”emojiæ¨¡å¼æ¿€æ´»ï¼Œåˆ™ä¸å…³é—­èœå•
            if (this.isEmojiMode && e.target.closest('#viewport, #container')) {
                return;
            }
            
            // å…¶ä»–æƒ…å†µï¼Œç‚¹å‡»å¤–éƒ¨å…³é—­èœå•
            if (!this.emojiMenu.contains(e.target) && !e.target.closest('[data-tool="emoji"]')) {
                this.hideEmojiMenu();
            }
        });
        
            // æ·»åŠ ç”»å¸ƒç‚¹å‡»äº‹ä»¶ï¼Œç”¨äºæ·»åŠ emoji
        this.vp.addEventListener('click', (e) => {
            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ‹–æ‹½emoji
            if (this.isDraggingEmoji) {
                return; // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œä¸ç”Ÿæˆæ–°çš„
            }
            
            // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦åœ¨ç°æœ‰emojiä¸Š
            if (e.target.classList.contains('emoji-item') || e.target.closest('.emoji-item')) {
                return; // å¦‚æœç‚¹å‡»çš„æ˜¯emojiï¼Œä¸ç”Ÿæˆæ–°çš„
            }
            
            if (this.selectedEmoji) {
                this.addEmojiToCanvas(e);
            }
        });
    },
    
    toggleEmojiMenu(btn) {
        // æ£€æŸ¥å½“å‰æ˜¯å¦å·²æ¿€æ´»è¯¥å·¥å…·
        const isActive = btn.classList.contains('active');
        
        // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeç±»
        document.querySelectorAll('.tool-btn').forEach(b => {
            b.classList.remove('active');
        });
        
        if (!isActive) {
            // æ¿€æ´»å½“å‰å·¥å…·
            btn.classList.add('active');
            this.isEmojiMode = true;
            this.currentTool = 'emoji';
            
            // æ˜¾ç¤ºemojièœå•
            this.showEmojiMenu(btn);
        } else {
            // å–æ¶ˆæ¿€æ´»
            this.isEmojiMode = false;
            this.currentTool = null;
            this.selectedEmoji = null;
            this.hideEmojiMenu();
            
            // æ¢å¤é»˜è®¤é¼ æ ‡å›¾æ ‡
            if (this.vp) {
                this.vp.style.cursor = 'grab';
            }
        }
    },
    
    showEmojiMenu(btn) {
        const rect = btn.getBoundingClientRect();
        this.emojiMenu.style.display = 'block';
        this.emojiMenu.style.left = `${rect.left + window.scrollX}px`;
        this.emojiMenu.style.top = `${rect.top + window.scrollY - this.emojiMenu.offsetHeight - 10}px`;
    },
    
    hideEmojiMenu() {
        this.emojiMenu.style.display = 'none';
        this.isEmojiMode = false;
        this.selectedEmoji = null;
        
        // ç§»é™¤emojiæŒ‰é’®çš„activeçŠ¶æ€
        const emojiBtn = document.querySelector('[data-tool="emoji"]');
        if (emojiBtn) {
            emojiBtn.classList.remove('active');
        }
        
        // æ¢å¤é»˜è®¤é¼ æ ‡å›¾æ ‡
        if (this.vp) {
            this.vp.style.cursor = 'grab';
        }
    },
    
    selectEmoji(emoji) {
        this.selectedEmoji = emoji;
        
        // ä¸è¦éšè—é¢æ¿ï¼Œå…è®¸è¿ç»­æ·»åŠ ç›¸åŒçš„emoji
        // this.hideEmojiMenu();
        
        // æ›´æ”¹é¼ æ ‡å›¾æ ‡ä¸ºåå­—å‡†æ˜Ÿ
        if (this.vp) {
            this.vp.style.cursor = 'crosshair';
        }
        
        // æ’­æ”¾æŒ‰é’®éŸ³æ•ˆ
        AudioSystem.playButtonSound();
    },
    
    addEmojiToCanvas(e) {
        // æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ‹–æ‹½emoji
        if (this.isDraggingEmoji) {
            return; // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œä¸ç”Ÿæˆæ–°çš„
        }
        
        // è·å–ç‚¹å‡»ä½ç½®ç›¸å¯¹äºç”»å¸ƒçš„åæ ‡
        const container = document.getElementById('container');
        const rect = container.getBoundingClientRect();
        
        // è·å–å®¹å™¨çš„transformæ ·å¼ï¼Œæå–ç¼©æ”¾æ¯”ä¾‹
        let scale = 1;
        const transform = container.style.transform;
        if (transform && transform.includes('scale')) {
            const scaleMatch = transform.match(/scale\(([^)]+)\)/);
            if (scaleMatch && scaleMatch[1]) {
                scale = parseFloat(scaleMatch[1]);
            }
        }
        
        // è®¡ç®—ç›¸å¯¹äºå®¹å™¨çš„åæ ‡
        const x = (e.clientX - rect.left) / scale;
        const y = (e.clientY - rect.top) / scale;
        
        // åˆ›å»ºemojiå…ƒç´ 
        const emojiElement = document.createElement('div');
        emojiElement.textContent = this.selectedEmoji;
        emojiElement.style.position = 'absolute';
        emojiElement.style.left = `${x - 25}px`;
        emojiElement.style.top = `${y - 25}px`;
        emojiElement.style.fontSize = '50px';
        emojiElement.style.cursor = 'move';
        emojiElement.style.zIndex = '20';
        emojiElement.style.userSelect = 'none';
        emojiElement.className = 'emoji-item';
        
        // ç”Ÿæˆå”¯ä¸€ID
        emojiElement.dataset.emojiId = Date.now() + Math.random().toString(36).substr(2, 9);
        
        // æ·»åŠ åˆ°ç”»å¸ƒ
        container.appendChild(emojiElement);
        
        // æ·»åŠ åˆ°emojisæ•°ç»„
        this.emojis.push({
            id: emojiElement.dataset.emojiId,
            element: emojiElement,
            x: parseFloat(emojiElement.style.left),
            y: parseFloat(emojiElement.style.top),
            emoji: this.selectedEmoji
        });
        
        // ä¸ºemojiå…ƒç´ æ·»åŠ æ‹–æ‹½ã€æ—‹è½¬ã€ç¼©æ”¾åŠŸèƒ½
        this.makeEmojiInteractive(emojiElement);
        
        // æ’­æ”¾éŸ³æ•ˆ
        AudioSystem.playButtonSound();
        
        // ä¿å­˜çŠ¶æ€
        if (this.app && this.app.save) {
            this.app.save();
        }
    },
    
    makeEmojiInteractive(element) {
        // æ‹–æ‹½åŠŸèƒ½
        let isDragging = false;
        let offsetX, offsetY;
        
        const handleMouseMove = (e) => {
            if (isDragging) {
                const container = document.getElementById('container');
                const containerRect = container.getBoundingClientRect();
                const scale = parseFloat(container.style.transform?.split('scale(')[1]?.split(')')[0] || 1);
                const newLeft = `${(e.clientX - containerRect.left - offsetX) / scale}px`;
                const newTop = `${(e.clientY - containerRect.top - offsetY) / scale}px`;
                
                // æ›´æ–°å…ƒç´ ä½ç½®
                element.style.left = newLeft;
                element.style.top = newTop;
                
                // æ›´æ–°emojisæ•°ç»„ä¸­çš„ä½ç½®ä¿¡æ¯
                const emojiId = element.dataset.emojiId;
                const emojiIndex = this.emojis.findIndex(emoji => emoji.id === emojiId);
                if (emojiIndex !== -1) {
                    this.emojis[emojiIndex].x = parseFloat(newLeft);
                    this.emojis[emojiIndex].y = parseFloat(newTop);
                }
            }
        };
        
        const handleMouseUp = () => {
            if (isDragging) {
                isDragging = false;
                this.isDraggingEmoji = false;
                // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬å™¨
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        };
        
        element.addEventListener('mousedown', (e) => {
            isDragging = true;
            this.isDraggingEmoji = true;
            const rect = element.getBoundingClientRect();
            const containerRect = document.getElementById('container').getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            
            // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            e.stopPropagation();
        });
        
        // å–æ¶ˆæ—‹è½¬å’Œç¼©æ”¾åŠŸèƒ½ï¼Œç§»é™¤æ»šè½®äº‹ä»¶ç›‘å¬å™¨
    }
};
window.DrawingManager = DrawingManager;

// fx.js
const FXManager = {
    particles: [],
    fxCanvas: null,
    fxCtx: null,
    app: null,
    
    // åˆå§‹åŒ–ç‰¹æ•ˆç³»ç»Ÿ
    init(app) {
        this.app = app;
        
        // åˆ›å»ºç‰¹æ•ˆç”»å¸ƒ
        this.fxCanvas = document.createElement('canvas');
        this.fxCanvas.style.cssText = 'position:fixed; top:0; left:0; pointer-events:none; z-index:10000;';
        document.body.appendChild(this.fxCanvas);
        this.fxCtx = this.fxCanvas.getContext('2d');
        
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        const resize = () => { 
            this.fxCanvas.width = window.innerWidth; 
            this.fxCanvas.height = window.innerHeight; 
        };
        window.addEventListener('resize', resize);
        resize();
        
        // å¯åŠ¨åŠ¨ç”»å¾ªç¯
        this.animate();
    },
    
    // åŠ¨ç”»å¾ªç¯
    animate() {
        this.fxCtx.clearRect(0, 0, this.fxCanvas.width, this.fxCanvas.height);
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx; 
            p.y += p.vy; 
            p.life -= 0.02;
            
            if (p.life <= 0) { 
                this.particles.splice(i, 1); 
                continue; 
            }
            
            this.fxCtx.fillStyle = p.color;
            this.fxCtx.globalAlpha = p.life;
            
            // ç»˜åˆ¶ä¸åŒå½¢çŠ¶çš„ç²’å­
            this.drawParticle(p);
        }
        
        requestAnimationFrame(() => this.animate());
    },
    
    // ç»˜åˆ¶ç²’å­ï¼ˆå¯ä»¥æ‰©å±•ä¸åŒçš„ç²’å­æ•ˆæœï¼‰
    drawParticle(p) {
        // ç®€å•çš„æ–¹å—ç²’å­
        this.fxCtx.fillRect(p.x, p.y, p.size, p.size);
        
        // å¯ä»¥æ‰©å±•å…¶ä»–å½¢çŠ¶ï¼š
        // this.fxCtx.beginPath();
        // this.fxCtx.arc(p.x, p.y, p.size/2, 0, Math.PI * 2);
        // this.fxCtx.fill();
    },
    
    // ç”Ÿæˆç²’å­ç‰¹æ•ˆ
    spawn(x, y, color, count = 15, particleType = 'square') {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                size: Math.random() * 5 + 2,
                life: 1.0,
                color: color,
                type: particleType
            });
        }
    },
    
    // ç”Ÿæˆçˆ†ç‚¸ç‰¹æ•ˆ
    spawnExplosion(x, y, color = '#ff6600', count = 30) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 6 + 2;
            
            this.particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * 6 + 3,
                life: 1.0,
                color: color,
                type: 'circle'
            });
        }
    },
    
    // ç”ŸæˆæµåŠ¨ç‰¹æ•ˆ
    spawnFlow(x, y, direction = 'up', color = '#00ffff', count = 10) {
        for (let i = 0; i < count; i++) {
            let vx = 0, vy = 0;
            
            switch(direction) {
                case 'up': vy = -(Math.random() * 3 + 1); break;
                case 'down': vy = Math.random() * 3 + 1; break;
                case 'left': vx = -(Math.random() * 3 + 1); break;
                case 'right': vx = Math.random() * 3 + 1; break;
            }
            
            this.particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx, vy,
                size: Math.random() * 4 + 1,
                life: 0.8,
                color: color,
                type: 'circle'
            });
        }
    },
    
    // ç”Ÿæˆè¿æ¥ç‰¹æ•ˆ
    spawnConnection(x1, y1, x2, y2, color = '#00ff00', particleCount = 10) {
        for (let i = 0; i <= particleCount; i++) {
            const t = i / particleCount;
            const x = x1 + (x2 - x1) * t;
            const y = y1 + (y2 - y1) * t;
            
            this.spawn(x, y, color, 2);
        }
    },
    
    // æ¸…é™¤æ‰€æœ‰ç²’å­
    clearAll() {
        this.particles = [];
    },
    
    // è·å–ç²’å­æ•°é‡
    getParticleCount() {
        return this.particles.length;
    }
};

window.FXManager = FXManager;

/**
 * ç‰¹æ•ˆç³»ç»Ÿæ¨¡å— - æå–è‡ªåŸ script.js
 * è´Ÿè´£ Canvas ç²’å­åŠ¨ç”»ã€èŠ‚ç‚¹ç”Ÿæˆ/åˆ é™¤çš„è§†è§‰åé¦ˆ
 */

// 1. ç²’å­ç±»å®šä¹‰ (ä»åŸ script.js å®Œæ•´æå–) - å¯¼å‡ºåˆ°å…¨å±€
window.Particle = class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        // éšæœºé€Ÿåº¦
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        // éšæœºå¯¿å‘½
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.015;
        // éšæœºå¤§å°
        this.size = Math.random() * 3 + 2;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95; // æ‘©æ“¦åŠ›
        this.vy *= 0.95;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
};

// 2. å…¨å±€ç‰¹æ•ˆç®¡ç†å¯¹è±¡
window.MathFX = {
    particles: [],
    canvas: null,
    ctx: null,

    /**
     * äº§ç”Ÿç²’å­ç‰¹æ•ˆ
     * @param {number} x - å±å¹•æ¨ªåæ ‡
     * @param {number} y - å±å¹•çºµåæ ‡
     * @param {string} color - é¢œè‰²åå…­è¿›åˆ¶
     * @param {number} count - æ•°é‡
     */
    spawn: function(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    /**
     * åˆå§‹åŒ–ç‰¹æ•ˆç”»å¸ƒå¹¶å¯åŠ¨åŠ¨ç”»å¾ªç¯
     */
    initFX: function() {
        const canvas = document.getElementById('fx-canvas') || this.createCanvas();
        if (!canvas) return;
        
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // è‡ªåŠ¨è°ƒæ•´ Canvas å¤§å°
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // åŠ¨ç”»ä¸»å¾ªç¯ (ä»åŸ script.js è¿ç§»)
        const animate = () => {
            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.update();
                p.draw(this.ctx);
                
                // ç§»é™¤æ­»äº¡ç²’å­
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
            
            requestAnimationFrame(animate);
        };
        
        requestAnimationFrame(animate);
        console.log("ç‰¹æ•ˆç³»ç»Ÿï¼šåŠ¨ç”»å¾ªç¯å·²å¯åŠ¨");
    },

    /**
     * åˆ›å»ºç‰¹æ•ˆç”»å¸ƒ
     */
    createCanvas: function() {
        const canvas = document.createElement('canvas');
        canvas.id = 'fx-canvas';
        canvas.style.cssText = 'position:fixed; top:0; left:0; pointer-events:none; z-index:10000;';
        document.body.appendChild(canvas);
        return canvas;
    },

    /**
     * ä¸ºäº†ä¿æŒå…¼å®¹æ€§ï¼Œå¦‚æœåœ¨ script.js é€»è¾‘ä¸­ç›´æ¥è°ƒç”¨äº† spawnParticlesï¼Œåœ¨æ­¤åšä¸ªæ˜ å°„
     */
    spawnParticles: function(x, y, color, count) {
        this.spawn(x, y, color, count);
    }
};

// 3. ä¿æŒå‘åå…¼å®¹ - æŒ‚è½½åˆ°appå¯¹è±¡
if (typeof app !== 'undefined') {
    app.particles = window.MathFX.particles;
    app.spawn = window.MathFX.spawn.bind(window.MathFX);
    app.initFX = window.MathFX.initFX.bind(window.MathFX);
    app.spawnParticles = window.MathFX.spawnParticles.bind(window.MathFX);
}

// é«˜çº§èŠ‚ç‚¹å¼è®¡ç®—å™¨åŠŸèƒ½å®ç°
// åŸºäºç”¨æˆ·éœ€æ±‚æ•´ç†ï¼šæ”¯æŒè¿ç»­è¿ç®—ã€æ‹¬å·ä¼˜å…ˆçº§ã€ç§‘å­¦è¿ç®—ã€é«˜ç²¾åº¦è®¡ç®—ã€ä¸­æ–‡æç¤ºã€ç‚¹å‡»å¤åˆ¶ç­‰åŠŸèƒ½

const advancedCalculator = {
    // æ•°å­¦å¸¸æ•°å®šä¹‰
    constants: {
        'e': Math.E.toString(),  // è‡ªç„¶å¸¸æ•°
        'Ï€': Math.PI.toString()  // åœ†å‘¨ç‡
    },
    
    // é«˜ç²¾åº¦åŠ æ³•
    add(a, b) {
        // å¤„ç†å°æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•°åŠ æ³•
        let scale = 0;
        let numA = a;
        let numB = b;
        
        // ç¡®å®šå°æ•°ä½æ•°
        if (numA.includes('.')) {
            const decimalPart = numA.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        if (numB.includes('.')) {
            const decimalPart = numB.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        // è½¬æ¢ä¸ºæ•´æ•°
        const intA = numA.replace('.', '') + '0'.repeat(scale - (numA.includes('.') ? numA.split('.')[1].length : 0));
        const intB = numB.replace('.', '') + '0'.repeat(scale - (numB.includes('.') ? numB.split('.')[1].length : 0));
        
        // æ‰§è¡Œæ•´æ•°åŠ æ³•
        const maxLength = Math.max(intA.length, intB.length);
        const paddedA = intA.padStart(maxLength, '0');
        const paddedB = intB.padStart(maxLength, '0');
        
        let result = '';
        let carry = 0;
        
        for (let i = maxLength - 1; i >= 0; i--) {
            const sum = parseInt(paddedA[i]) + parseInt(paddedB[i]) + carry;
            result = (sum % 10) + result;
            carry = Math.floor(sum / 10);
        }
        
        if (carry > 0) {
            result = carry + result;
        }
        
        // è½¬æ¢å›å°æ•°
        if (scale > 0) {
            result = result.slice(0, -scale) + '.' + result.slice(-scale);
        }
        
        // æ ¼å¼åŒ–ç»“æœï¼šç§»é™¤å‰å¯¼é›¶å’Œæœ«å°¾å¤šä½™çš„é›¶
        result = result.replace(/^0+/, '') || '0';
        // åªæœ‰å½“ç»“æœä¸æ˜¯ '0' æ—¶æ‰ç§»é™¤æœ«å°¾çš„é›¶
        if (result !== '0') {
            result = result.replace(/\.?0+$/, '');
            result = result.replace(/\.$/, '');
        }
        
        return result;
    },
    
    // é«˜ç²¾åº¦å‡æ³•
    subtract(a, b) {
        // å¤„ç†è´Ÿæ•°æƒ…å†µ
        const isNegative = this.compare(a, b) < 0;
        if (isNegative) {
            return '-' + this.subtract(b, a);
        }
        
        // å¤„ç†å°æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•°å‡æ³•
        let scale = 0;
        let numA = a;
        let numB = b;
        
        // ç¡®å®šå°æ•°ä½æ•°
        if (numA.includes('.')) {
            const decimalPart = numA.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        if (numB.includes('.')) {
            const decimalPart = numB.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        // è½¬æ¢ä¸ºæ•´æ•°
        const intA = numA.replace('.', '') + '0'.repeat(scale - (numA.includes('.') ? numA.split('.')[1].length : 0));
        const intB = numB.replace('.', '') + '0'.repeat(scale - (numB.includes('.') ? numB.split('.')[1].length : 0));
        
        // æ‰§è¡Œæ•´æ•°å‡æ³•
        const maxLength = Math.max(intA.length, intB.length);
        const paddedA = intA.padStart(maxLength, '0');
        const paddedB = intB.padStart(maxLength, '0');
        
        let result = '';
        let borrow = 0;
        
        for (let i = maxLength - 1; i >= 0; i--) {
            let digitA = parseInt(paddedA[i]) - borrow;
            const digitB = parseInt(paddedB[i]);
            
            if (digitA < digitB) {
                digitA += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            
            result = (digitA - digitB) + result;
        }
        
        // è½¬æ¢å›å°æ•°
        if (scale > 0) {
            result = result.slice(0, -scale) + '.' + result.slice(-scale);
        }
        
        // æ ¼å¼åŒ–ç»“æœï¼šç§»é™¤å‰å¯¼é›¶å’Œæœ«å°¾å¤šä½™çš„é›¶
        result = result.replace(/^0+/, '') || '0';
        // åªæœ‰å½“ç»“æœä¸æ˜¯ '0' æ—¶æ‰ç§»é™¤æœ«å°¾çš„é›¶
        if (result !== '0') {
            result = result.replace(/\.?0+$/, '');
            result = result.replace(/\.$/, '');
        }
        
        return result;
    },
    
    // é«˜ç²¾åº¦ä¹˜æ³•
    multiply(a, b) {
        if (a === '0' || b === '0') return '0';
        
        // å¤„ç†å°æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•°ä¹˜æ³•
        let scale = 0;
        let numA = a;
        let numB = b;
        
        // ç¡®å®šå°æ•°ä½æ•°
        if (numA.includes('.')) {
            const decimalPart = numA.split('.')[1];
            scale += decimalPart.length;
            numA = numA.replace('.', '');
        }
        
        if (numB.includes('.')) {
            const decimalPart = numB.split('.')[1];
            scale += decimalPart.length;
            numB = numB.replace('.', '');
        }
        
        // è½¬æ¢ä¸ºæ•°å­—æ•°ç»„ï¼Œæ–¹ä¾¿è®¡ç®—
        const arrA = numA.split('').reverse().map(Number);
        const arrB = numB.split('').reverse().map(Number);
        const result = new Array(arrA.length + arrB.length).fill(0);
        
        // æ‰§è¡Œä¹˜æ³•
        for (let i = 0; i < arrA.length; i++) {
            for (let j = 0; j < arrB.length; j++) {
                const product = arrA[i] * arrB[j] + result[i + j];
                result[i + j] = product % 10;
                result[i + j + 1] += Math.floor(product / 10);
            }
        }
        
        // è½¬æ¢å›å­—ç¬¦ä¸²
        let resultStr = result.reverse().join('');
        
        // æ·»åŠ å°æ•°ç‚¹
        if (scale > 0) {
            if (resultStr.length <= scale) {
                resultStr = '0'.repeat(scale - resultStr.length + 1) + resultStr;
            }
            resultStr = resultStr.slice(0, -scale) + '.' + resultStr.slice(-scale);
        }
        
        // æ ¼å¼åŒ–ç»“æœï¼šç§»é™¤å‰å¯¼é›¶å’Œæœ«å°¾å¤šä½™çš„é›¶
        resultStr = resultStr.replace(/^0+/, '') || '0';
        resultStr = resultStr.replace(/\.?0+$/, '');
        resultStr = resultStr.replace(/\.$/, '');
        
        return resultStr;
    },
    
    // é«˜ç²¾åº¦é™¤æ³•ï¼ˆæ”¯æŒä¿ç•™å¤šä½å°æ•°ï¼‰
    divide(a, b) {
        if (b === '0') return 'é”™è¯¯ï¼šé™¤ä»¥é›¶';
        if (a === '0') return '0';
        
        // ç§»é™¤å‰å¯¼é›¶
        const cleanA = a.replace(/^0+/, '') || '0';
        const cleanB = b.replace(/^0+/, '') || '0';
        
        // å¤„ç†å°æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•°é™¤æ³•
        let scale = 0;
        let numerator = cleanA;
        let denominator = cleanB;
        
        // ç§»é™¤åˆ†å­å’Œåˆ†æ¯ä¸­çš„å°æ•°ç‚¹
        if (numerator.includes('.')) {
            const decimalPart = numerator.split('.')[1];
            scale += decimalPart.length;
            numerator = numerator.replace('.', '');
        }
        
        if (denominator.includes('.')) {
            const decimalPart = denominator.split('.')[1];
            scale -= decimalPart.length;
            denominator = denominator.replace('.', '');
        }
        
        // è°ƒæ•´åˆ†å­ï¼Œä½¿scaleä¸ºæ­£
        if (scale > 0) {
            numerator += '0'.repeat(scale);
        } else if (scale < 0) {
            denominator += '0'.repeat(Math.abs(scale));
            scale = 0;
        }
        
        // æ‰§è¡Œæ•´æ•°é™¤æ³•ï¼Œä¿ç•™100ä½å°æ•°
        let quotient = '';
        let remainder = numerator;
        let decimalCount = 0;
        const maxDecimals = 10000;
        const seenRemainders = new Map(); // ç”¨äºæ£€æµ‹å¾ªç¯å°æ•°
        
        while (remainder !== '0' && decimalCount <= maxDecimals) {
            // æ£€æŸ¥æ˜¯å¦å‡ºç°å¾ªç¯
            if (seenRemainders.has(remainder)) {
                // æ‰¾åˆ°å¾ªç¯èŠ‚èµ·å§‹ä½ç½®
                const startIndex = seenRemainders.get(remainder);
                // æ ‡è®°å¾ªç¯èŠ‚
                quotient = quotient.slice(0, startIndex) + '(' + quotient.slice(startIndex) + ')';
                break;
            }
            
            seenRemainders.set(remainder, quotient.length);
            
            let count = 0;
            while (this.compare(remainder, denominator) >= 0) {
                remainder = this.subtract(remainder, denominator);
                count++;
            }
            quotient += count;
            
            if (decimalCount === 0 && remainder !== '0') {
                quotient += '.';
            }
            
            decimalCount++;
            remainder += '0';
        }
        
        // æ ¼å¼åŒ–ç»“æœï¼šç§»é™¤æœ«å°¾å¤šä½™çš„é›¶å’Œå°æ•°ç‚¹
        quotient = quotient.replace(/\.?0+$/, '');
        quotient = quotient.replace(/\.$/, '');
        
        return quotient;
    },
    
    // é«˜ç²¾åº¦æ±‚ä½™è¿ç®—
    mod(a, b) {
        if (b === '0') return 'é”™è¯¯ï¼šé™¤ä»¥é›¶';
        if (a === '0') return '0';
        
        // ç§»é™¤å‰å¯¼é›¶
        const cleanA = a.replace(/^0+/, '') || '0';
        const cleanB = b.replace(/^0+/, '') || '0';
        
        // å¤„ç†å°æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•°
        let scale = 0;
        let numA = cleanA;
        let numB = cleanB;
        
        // ç¡®å®šå°æ•°ä½æ•°
        if (numA.includes('.')) {
            const decimalPart = numA.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        if (numB.includes('.')) {
            const decimalPart = numB.split('.')[1];
            scale = Math.max(scale, decimalPart.length);
        }
        
        // è½¬æ¢ä¸ºæ•´æ•°
        const intA = numA.replace('.', '') + '0'.repeat(scale - (numA.includes('.') ? numA.split('.')[1].length : 0));
        const intB = numB.replace('.', '') + '0'.repeat(scale - (numB.includes('.') ? numB.split('.')[1].length : 0));
        
        // æ‰§è¡Œæ±‚ä½™è¿ç®—
        let remainder = intA;
        while (this.compare(remainder, intB) >= 0) {
            remainder = this.subtract(remainder, intB);
        }
        
        // è½¬æ¢å›å°æ•°
        if (scale > 0) {
            if (remainder.length <= scale) {
                remainder = '0'.repeat(scale - remainder.length + 1) + remainder;
            }
            remainder = remainder.slice(0, -scale) + '.' + remainder.slice(-scale);
        }
        
        // æ ¼å¼åŒ–ç»“æœ
        remainder = remainder.replace(/^0+/, '') || '0';
        remainder = remainder.replace(/\.?0+$/, '');
        remainder = remainder.replace(/\.$/, '');
        
        return remainder;
    },
    
    // æ¯”è¾ƒä¸¤ä¸ªæ•°å­—å­—ç¬¦ä¸²çš„å¤§å°ï¼ˆä¼˜åŒ–ç‰ˆï¼šå¯¹é½å°æ•°ä½æ•°ï¼‰
    compare(a, b) {
        // å¤„ç†è´Ÿæ•°
        const isNegativeA = a.startsWith('-');
        const isNegativeB = b.startsWith('-');
        
        if (isNegativeA && !isNegativeB) return -1;
        if (!isNegativeA && isNegativeB) return 1;
        
        // ç§»é™¤è´Ÿå·
        let absA = isNegativeA ? a.slice(1) : a;
        let absB = isNegativeB ? b.slice(1) : b;
        
        // å¤„ç†å¸¸æ•°
        absA = this.constants[absA] || absA;
        absB = this.constants[absB] || absB;
        
        // ç§»é™¤å‰å¯¼é›¶
        absA = absA.replace(/^0+/, '') || '0';
        absB = absB.replace(/^0+/, '') || '0';
        
        // å¤„ç†å°æ•°æ¯”è¾ƒ - å¯¹é½å°æ•°ä½æ•°
        let [intA, decA = ''] = absA.split('.');
        let [intB, decB = ''] = absB.split('.');
        
        // å¯¹é½å°æ•°ä½æ•°
        const maxDec = Math.max(decA.length, decB.length);
        decA = decA.padEnd(maxDec, '0');
        decB = decB.padEnd(maxDec, '0');
        
        // åˆå¹¶æ•´æ•°å’Œå°æ•°éƒ¨åˆ†ï¼Œè¿›è¡Œå­—ç¬¦ä¸²æ¯”è¾ƒ
        const fullA = intA + decA;
        const fullB = intB + decB;
        
        // æ¯”è¾ƒé•¿åº¦
        if (fullA.length !== fullB.length) {
            return isNegativeA ? fullB.length - fullA.length : fullA.length - fullB.length;
        }
        
        // é€ä½æ¯”è¾ƒ
        for (let i = 0; i < fullA.length; i++) {
            if (fullA[i] !== fullB[i]) {
                const diff = parseInt(fullA[i]) - parseInt(fullB[i]);
                return isNegativeA ? -diff : diff;
            }
        }
        
        // æ‰€æœ‰ä½æ•°éƒ½ç›¸åŒ
        return 0;
    },
    
    // å­—ç¬¦ä¸²è½¬æ•°å­—ï¼ˆç”¨äºç§‘å­¦è®¡ç®—ï¼‰
    strToNum(str) {
        // å¤„ç†å¸¸æ•°
        if (this.constants[str]) {
            return parseFloat(this.constants[str]);
        }
        
        const num = parseFloat(str);
        return isNaN(num) ? 0 : num;
    },
    
    // æ•°å­—è½¬å­—ç¬¦ä¸²ï¼ˆç”¨äºç§‘å­¦è®¡ç®—ç»“æœï¼‰
    numToStr(num) {
        // å¤„ç†NaNå’ŒInfinity
        if (isNaN(num) || !isFinite(num)) {
            return 'é”™è¯¯';
        }
        
        // å¤„ç†å¤§æ•°ï¼Œä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•
        if (Math.abs(num) > 1e15 || (Math.abs(num) < 1e-10 && num !== 0)) {
            return num.toExponential(10);
        }
        
        // å¤„ç†å°æ•°ï¼Œç§»é™¤æœ«å°¾çš„é›¶
        return num.toString().replace(/\.?0+$/, '');
    },
    
    // å¹‚è¿ç®—
    power(base, exponent) {
        const baseNum = this.strToNum(base);
        const expNum = this.strToNum(exponent);
        const result = Math.pow(baseNum, expNum);
        return this.numToStr(result);
    },
    
    // næ¬¡æ ¹å·
    nthRoot(base, root) {
        const baseNum = this.strToNum(base);
        const rootNum = this.strToNum(root);
        
        if (baseNum < 0 && rootNum % 2 === 0) {
            return 'é”™è¯¯ï¼šè´Ÿæ•°ä¸èƒ½å¼€å¶æ¬¡æ–¹';
        }
        
        const result = Math.pow(baseNum, 1 / rootNum);
        return this.numToStr(result);
    },
    
    // å¹³æ–¹æ ¹
    sqrt(num) {
        return this.nthRoot(num, '2');
    },
    
    // ç»å¯¹å€¼
    abs(num) {
        if (num.startsWith('-')) {
            return num.slice(1);
        }
        return num;
    },
    
    // é˜¶ä¹˜
    factorial(num) {
        const numVal = parseInt(num);
        if (isNaN(numVal) || numVal < 0 || !Number.isInteger(numVal)) {
            return 'é”™è¯¯ï¼šé˜¶ä¹˜ä»…æ”¯æŒéè´Ÿæ•´æ•°';
        }
        
        let result = 1;
        for (let i = 2; i <= numVal; i++) {
            result *= i;
        }
        
        return result.toString();
    },
    
    // å¯¹æ•°å‡½æ•°ï¼ˆé»˜è®¤åº•æ•°10ï¼‰
    log(num, base = '10') {
        const numVal = this.strToNum(num);
        const baseVal = this.strToNum(base);
        
        if (numVal <= 0 || baseVal <= 0 || baseVal === 1) {
            return 'é”™è¯¯ï¼šå¯¹æ•°å‚æ•°æ— æ•ˆ';
        }
        
        const result = Math.log(numVal) / Math.log(baseVal);
        return this.numToStr(result);
    },
    
    // è‡ªç„¶å¯¹æ•°
    ln(num) {
        return this.log(num, this.constants.e);
    },
    
    // æ­£å¼¦å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    sin(angle) {
        const angleRad = this.strToNum(angle) * Math.PI / 180;
        const result = Math.sin(angleRad);
        return this.numToStr(result);
    },
    
    // ä½™å¼¦å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    cos(angle) {
        const angleRad = this.strToNum(angle) * Math.PI / 180;
        const result = Math.cos(angleRad);
        return this.numToStr(result);
    },
    
    // æ­£åˆ‡å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    tan(angle) {
        const angleRad = this.strToNum(angle) * Math.PI / 180;
        const result = Math.tan(angleRad);
        return this.numToStr(result);
    },
    
    // ä½™å‰²å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    csc(angle) {
        const sinVal = this.strToNum(this.sin(angle));
        if (sinVal === 0) {
            return 'é”™è¯¯ï¼šä½™å‰²å‡½æ•°æ— æ•ˆ';
        }
        const result = 1 / sinVal;
        return this.numToStr(result);
    },
    
    // æ­£å‰²å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    sec(angle) {
        const cosVal = this.strToNum(this.cos(angle));
        if (cosVal === 0) {
            return 'é”™è¯¯ï¼šæ­£å‰²å‡½æ•°æ— æ•ˆ';
        }
        const result = 1 / cosVal;
        return this.numToStr(result);
    },
    
    // ä½™åˆ‡å‡½æ•°ï¼ˆè§’åº¦åˆ¶ï¼‰
    cot(angle) {
        const tanVal = this.strToNum(this.tan(angle));
        if (tanVal === 0) {
            return 'é”™è¯¯ï¼šä½™åˆ‡å‡½æ•°æ— æ•ˆ';
        }
        const result = 1 / tanVal;
        return this.numToStr(result);
    },
    
    // é€’å½’ä¸‹é™è§£æå™¨ - è¯æ³•åˆ†æ
    tokenize(expression) {
        const tokens = [];
        // æ”¯æŒçš„ç¬¦å·ï¼šæ•°å­—ã€è¿ç®—ç¬¦ã€æ‹¬å·ã€å‡½æ•°ã€å¸¸æ•°ã€æ¯”è¾ƒæ“ä½œç¬¦
        // ç¡®ä¿æ¯”è¾ƒæ“ä½œç¬¦çš„é¡ºåºæ­£ç¡®ï¼Œé•¿æ“ä½œç¬¦ä¼˜å…ˆåŒ¹é…
        const regex = /(\d+\.?\d*)|(==|!=|>=|<=|>|<)|([+\-*/^!%])|(\()|(\))|(\[)|(\])|(\{|\})|(sin|cos|tan|csc|sec|cot|sqrt|abs|log|ln|factorial)|(e|Ï€)/gi;
        let match;
        
        while ((match = regex.exec(expression)) !== null) {
            if (match[1]) {
                tokens.push({ type: 'number', value: match[1] });
            } else if (match[2]) {
                tokens.push({ type: 'comparison', value: match[2] });
            } else if (match[3]) {
                tokens.push({ type: 'operator', value: match[3] });
            } else if (match[4]) {
                tokens.push({ type: 'paren', value: '(' });
            } else if (match[5]) {
                tokens.push({ type: 'paren', value: ')' });
            } else if (match[6]) {
                tokens.push({ type: 'paren', value: '[' });
            } else if (match[7]) {
                tokens.push({ type: 'paren', value: ']' });
            } else if (match[8]) {
                tokens.push({ type: 'paren', value: match[8] });
            } else if (match[9]) {
                tokens.push({ type: 'function', value: match[9] });
            } else if (match[10]) {
                tokens.push({ type: 'constant', value: match[10] });
            }
        }
        
        return tokens;
    },
    
    // é€’å½’ä¸‹é™è§£æå™¨ - è¯­æ³•åˆ†æå’Œè®¡ç®—
    parseExpression(tokens) {
        let index = 0;
        const self = this;
        
        // è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰token
        const peek = () => tokens[index];
        const consume = () => tokens[index++];
        
        // è§£ææ•°å­—ã€å¸¸æ•°ã€æ‹¬å·æˆ–å‡½æ•°
        function parsePrimary() {
            const token = peek();
            
            if (token.type === 'number') {
                return consume().value;
            }
            
            if (token.type === 'constant') {
                const constant = consume().value;
                return self.constants[constant] || constant;
            }
            
            if (token.type === 'function') {
                const func = consume().value;
                consume(); // è·³è¿‡ '('
                
                // å¤„ç†é˜¶ä¹˜ï¼ˆä¸€å…ƒåç¼€æ“ä½œç¬¦ï¼‰
                if (func === 'factorial') {
                    const arg = parseComparison();
                    consume(); // è·³è¿‡ ')'
                    return self.factorial(arg);
                }
                
                // å¤„ç†nthRootï¼ˆäºŒå…ƒå‡½æ•°ï¼‰
                if (func === 'nthRoot') {
                    const base = parseComparison();
                    if (peek() && peek().value === ',') {
                        consume(); // è·³è¿‡ ','
                        const root = parseComparison();
                        consume(); // è·³è¿‡ ')'
                        return self.nthRoot(base, root);
                    } else {
                        consume(); // è·³è¿‡ ')'
                        return self.sqrt(base); // é»˜è®¤å¹³æ–¹æ ¹
                    }
                }
                
                // å¤„ç†logï¼ˆæ”¯æŒå¯é€‰åº•æ•°ï¼‰
                if (func === 'log') {
                    const num = parseComparison();
                    if (peek() && peek().value === ',') {
                        consume(); // è·³è¿‡ ','
                        const base = parseComparison();
                        consume(); // è·³è¿‡ ')'
                        return self.log(num, base);
                    } else {
                        consume(); // è·³è¿‡ ')'
                        return self.log(num); // é»˜è®¤åº•æ•°10
                    }
                }
                
                // å¤„ç†å…¶ä»–ä¸€å…ƒå‡½æ•°
                const arg = parseComparison();
                consume(); // è·³è¿‡ ')'
                
                switch (func) {
                    case 'sin': return self.sin(arg);
                    case 'cos': return self.cos(arg);
                    case 'tan': return self.tan(arg);
                    case 'csc': return self.csc(arg);
                    case 'sec': return self.sec(arg);
                    case 'cot': return self.cot(arg);
                    case 'sqrt': return self.sqrt(arg);
                    case 'abs': return self.abs(arg);
                    case 'ln': return self.ln(arg);
                    default: return 'é”™è¯¯ï¼šæœªçŸ¥å‡½æ•°';
                }
            }
            
            if (token.value === '(' || token.value === '[' || token.value === '{') {
                const openParen = consume().value;
                const expr = parseComparison();
                
                // åŒ¹é…å¯¹åº”çš„é—­æ‹¬å·
                const closeParen = {
                    '(': ')',
                    '[': ']',
                    '{': '}'
                }[openParen];
                
                if (peek() && peek().value === closeParen) {
                    consume(); // è·³è¿‡å¯¹åº”çš„é—­æ‹¬å·
                } else {
                    return 'é”™è¯¯ï¼šæ‹¬å·ä¸åŒ¹é…';
                }
                
                return expr;
            }
            
            return 'é”™è¯¯';
        }
        
        // è§£æé˜¶ä¹˜ï¼ˆä¸€å…ƒåç¼€æ“ä½œç¬¦ï¼‰
        function parseFactorial() {
            let left = parsePrimary();
            
            while (peek() && peek().value === '!') {
                consume(); // è·³è¿‡ '!'
                left = self.factorial(left);
            }
            
            return left;
        }
        
        // è§£æå¹‚è¿ç®—
        function parsePower() {
            let left = parseFactorial();
            
            while (peek() && peek().value === '^') {
                const op = consume().value;
                const right = parsePower(); // å¹‚è¿ç®—å³ç»“åˆ
                left = self.power(left, right);
            }
            
            return left;
        }
        
        // è§£æä¹˜é™¤æ±‚ä½™è¿ç®—
        function parseTerm() {
            let left = parsePower();
            
            while (peek() && (peek().value === '*' || peek().value === '/' || peek().value === '%')) {
                const op = consume().value;
                const right = parsePower();
                
                switch (op) {
                    case '*': left = self.multiply(left, right); break;
                    case '/': left = self.divide(left, right); break;
                    case '%': left = self.mod(left, right); break;
                }
            }
            
            return left;
        }
        
        // è§£æåŠ å‡è¿ç®—
        function parseAdditive() {
            let left = parseTerm();
            
            while (peek() && (peek().value === '+' || peek().value === '-')) {
                const op = consume().value;
                const right = parseTerm();
                
                switch (op) {
                    case '+': left = self.add(left, right); break;
                    case '-': left = self.subtract(left, right); break;
                }
            }
            
            return left;
        }
        
        // è§£ææ¯”è¾ƒæ“ä½œ
        function parseComparison() {
            let left = parseAdditive();
            
            while (peek() && peek().type === 'comparison') {
                const op = consume().value;
                const right = parseAdditive();
                
                // ä½¿ç”¨ä¼˜åŒ–çš„æ¯”è¾ƒå‡½æ•°ï¼Œè‡ªåŠ¨å¯¹é½å°æ•°ä½æ•°
                const comparisonResult = self.compare(left, right);
                let result = false;
                
                switch (op) {
                    case '>': result = comparisonResult > 0; break;
                    case '<': result = comparisonResult < 0; break;
                    case '>=': result = comparisonResult >= 0; break;
                    case '<=': result = comparisonResult <= 0; break;
                    case '==': result = comparisonResult === 0; break;
                    case '!=': result = comparisonResult !== 0; break;
                }
                
                // è¿”å›å¸ƒå°”ç»“æœ
                left = result ? 'çœŸ' : 'å‡';
            }
            
            return left;
        }
        
        return parseComparison();
    },
    
    // è®¡ç®—è¡¨è¾¾å¼ç»“æœ
    calculateExpression(expression) {
        try {
            // æ¸…ç†è¡¨è¾¾å¼
            const trimmed = expression.trim();
            if (!trimmed) return null;
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«éæ•°å­¦å­—ç¬¦ï¼Œæ·»åŠ å¯¹æ¯”è¾ƒæ“ä½œç¬¦çš„æ”¯æŒ
            const mathCharsRegex = /^[\d+\-*/^!()\[\]{}<>.,=\sabcdefghijklmnopqrstuvwxyzÏ€e]+$/i;
            if (!mathCharsRegex.test(trimmed)) {
                return null;
            }
            
            // ç§»é™¤ç­‰å·ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œåªä¿ç•™æ¯”è¾ƒæ“ä½œç¬¦ä¸­çš„ç­‰å·
            let cleaned = trimmed;
            // å¤„ç†æ¯”è¾ƒæ“ä½œç¬¦ï¼Œå°†å®ƒä»¬æ›¿æ¢ä¸ºç‰¹æ®Šæ ‡è®°ï¼Œé¿å…è¢«è¯¯å¤„ç†
            const opMap = {
                '==': '__EQ__',
                '!=': '__NE__',
                '>=': '__GE__',
                '<=': '__LE__',
                '>': '__GT__',
                '<': '__LT__'
            };
            
            // æ›¿æ¢æ¯”è¾ƒæ“ä½œç¬¦ä¸ºç‰¹æ®Šæ ‡è®°
            for (const [op, marker] of Object.entries(opMap)) {
                cleaned = cleaned.replace(new RegExp(op, 'g'), marker);
            }
            
            // ç§»é™¤æ‰€æœ‰å‰©ä½™çš„ç­‰å·
            cleaned = cleaned.replace(/=/g, '');
            
            // æ¢å¤æ¯”è¾ƒæ“ä½œç¬¦
            for (const [op, marker] of Object.entries(opMap)) {
                cleaned = cleaned.replace(new RegExp(marker, 'g'), op);
            }
            
            // ç§»é™¤æ‰€æœ‰ç©ºæ ¼
            cleaned = cleaned.replace(/\s+/g, '');
            if (!cleaned) return null;
            
            // è¯æ³•åˆ†æ
            const tokens = this.tokenize(cleaned);
            if (tokens.length === 0) return null;
            
            // è¯­æ³•åˆ†æå’Œè®¡ç®—
            const result = this.parseExpression(tokens);
            return result;
        } catch (error) {
            console.error('è®¡ç®—é”™è¯¯:', error);
            return 'é”™è¯¯';
        }
    },
    
    // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åŒ…å«å¯è®¡ç®—çš„è¡¨è¾¾å¼
    isExpressionNode(node) {
        const content = node.code.trim();
        if (content.length === 0) {
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦åªæ˜¯çº¯æ•°å­—æˆ–å¸¸æ•°
        const isPureNumber = /^\d+(\.\d+)?$/.test(content);
        const isConstant = /^(e|Ï€)$/.test(content);
        if (isPureNumber || isConstant) {
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«éæ•°å­¦å­—ç¬¦ï¼Œæ·»åŠ å¯¹æ¯”è¾ƒæ“ä½œç¬¦çš„æ”¯æŒ
        const mathCharsRegex = /^[\d+\-*/^!()\[\]{}<>.,=\sabcdefghijklmnopqrstuvwxyzÏ€e]+$/i;
        if (!mathCharsRegex.test(content)) {
            return false;
        }
        
        return true;
    },
    
    // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¡¨è¾¾å¼
    calculateAllExpressions(nodes) {
        nodes.forEach(node => {
            if (this.isExpressionNode(node)) {
                const result = this.calculateExpression(node.code);
                node.expressionResult = result;
            } else {
                node.expressionResult = null;
            }
        });
        return nodes;
    },
    
    // åˆ›å»ºå¸®åŠ©å¯¹è¯æ¡†
    createHelpDialog() {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å¸®åŠ©å¯¹è¯æ¡†
        if (document.getElementById('calculator-help-dialog')) {
            return;
        }
        
        const helpDialog = document.createElement('div');
        helpDialog.id = 'calculator-help-dialog';
        helpDialog.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2c2c2c;
            border: 2px solid hsl(210, 100%, 50%);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: Arial, sans-serif;
        `;
        
        helpDialog.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: hsl(210, 100%, 50%);">è®¡ç®—å¸®åŠ©</h2>
                <button id="close-help-dialog" style="background: hsl(0, 100%, 60%); color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer;">
                    å…³é—­
                </button>
            </div>
            
            <div style="color: #e0e0e0;">
                <h3 style="color: hsl(210, 100%, 50%); margin-top: 0;">åŸºæœ¬è¿ç®—ç¬¦</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div><strong>+</strong>: åŠ æ³• (å¦‚: 1+2)</div>
                    <div><strong>-</strong>: å‡æ³• (å¦‚: 3-1)</div>
                    <div><strong>*</strong>: ä¹˜æ³• (å¦‚: 2*3)</div>
                    <div><strong>/</strong>: é™¤æ³• (å¦‚: 6/2)</div>
                    <div><strong>^</strong>: å¹‚è¿ç®— (å¦‚: 2^3 = 8)</div>
                    <div><strong>%</strong>: æ±‚ä½™è¿ç®— (å¦‚: 7%3 = 1)</div>
                    <div><strong>!</strong>: é˜¶ä¹˜ (å¦‚: 5! = 120 æˆ– factorial(5))</div>
                </div>
                
                <h3 style="color: hsl(210, 100%, 50%);">æ¯”è¾ƒè¿ç®—ç¬¦</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div><strong>==</strong>: ç­‰äº (å¦‚: 2+2==4 è¿”å› "çœŸ")</div>
                    <div><strong>!=</strong>: ä¸ç­‰äº (å¦‚: 2+2!=5 è¿”å› "çœŸ")</div>
                    <div><strong>></strong>: å¤§äº (å¦‚: 5>3 è¿”å› "çœŸ")</div>
                    <div><strong><</strong>: å°äº (å¦‚: 3<5 è¿”å› "çœŸ")</div>
                    <div><strong>>=</strong>: å¤§äºç­‰äº (å¦‚: 5>=5 è¿”å› "çœŸ")</div>
                    <div><strong><=</strong>: å°äºç­‰äº (å¦‚: 3<=5 è¿”å› "çœŸ")</div>
                </div>
                
                <h3 style="color: hsl(210, 100%, 50%);">æ•°å­¦å‡½æ•°</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div><strong>sin(x)</strong>: æ­£å¼¦å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>cos(x)</strong>: ä½™å¼¦å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>tan(x)</strong>: æ­£åˆ‡å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>csc(x)</strong>: ä½™å‰²å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>sec(x)</strong>: æ­£å‰²å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>cot(x)</strong>: ä½™åˆ‡å‡½æ•° (è§’åº¦åˆ¶)</div>
                    <div><strong>sqrt(x)</strong>: å¹³æ–¹æ ¹ (å¦‚: sqrt(9) = 3)</div>
                    <div><strong>abs(x)</strong>: ç»å¯¹å€¼ (å¦‚: abs(-5) = 5)</div>
                    <div><strong>log(x, base)</strong>: å¯¹æ•° (é»˜è®¤åº•æ•°10)</div>
                    <div><strong>ln(x)</strong>: è‡ªç„¶å¯¹æ•° (ä»¥eä¸ºåº•)</div>
                    <div><strong>nthRoot(x, n)</strong>: næ¬¡æ ¹å· (å¦‚: nthRoot(8, 3) = 2)</div>
                </div>
                
                <h3 style="color: hsl(210, 100%, 50%);">æ•°å­¦å¸¸æ•°</h3>
                <div style="margin-bottom: 20px;">
                    <div><strong>e</strong>: è‡ªç„¶å¸¸æ•° (çº¦2.71828)</div>
                    <div><strong>Ï€</strong>: åœ†å‘¨ç‡ (çº¦3.14159)</div>
                </div>
                
                <h3 style="color: hsl(210, 100%, 50%);">ä½¿ç”¨ç¤ºä¾‹</h3>
                <div style="background: #404040; padding: 10px; border-radius: 4px; margin-bottom: 20px;">
                    <div><strong>1+2*3</strong> = 7 (ä¹˜æ³•ä¼˜å…ˆçº§é«˜äºåŠ æ³•)</div>
                    <div><strong>(1+2)*3</strong> = 9 (æ‹¬å·æ”¹å˜ä¼˜å…ˆçº§)</div>
                    <div><strong>sin(30)</strong> = 0.5 (30åº¦çš„æ­£å¼¦å€¼)</div>
                    <div><strong>2^3+4</strong> = 12 (å¹‚è¿ç®—)</div>
                    <div><strong>5!-10</strong> = 110 (é˜¶ä¹˜è¿ç®—)</div>
                </div>
            </div>
        `;
        
        document.body.appendChild(helpDialog);
        
        // æ·»åŠ å…³é—­äº‹ä»¶
        document.getElementById('close-help-dialog').addEventListener('click', () => {
            helpDialog.remove();
        });
        
        // ç‚¹å‡»å¯¹è¯æ¡†å¤–éƒ¨å…³é—­
        helpDialog.addEventListener('click', (e) => {
            if (e.target === helpDialog) {
                helpDialog.remove();
            }
        });
    },
    
    // æ›´æ–°èŠ‚ç‚¹æ˜¾ç¤ºï¼Œæ·»åŠ è®¡ç®—ç»“æœæç¤ºå’Œå¸®åŠ©æŒ‰é’®
    updateNodeDisplays(nodes) {
        nodes.forEach(node => {
            const nodeElement = document.getElementById(`n-${node.id}`);
            if (!nodeElement) return;
            
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç»“æœæç¤ºå…ƒç´ 
            let resultHintElement = nodeElement.querySelector('.expression-result-hint');
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è¡¨è¾¾å¼èŠ‚ç‚¹
            const isExprNode = this.isExpressionNode(node);
            
            // æ£€æŸ¥ç»“æœæ˜¯å¦æœ‰æ•ˆ
            const isValidResult = node.expressionResult !== null && 
                                node.expressionResult !== 'Error' && 
                                node.expressionResult !== 'é”™è¯¯' && 
                                node.expressionResult !== 'NaN' && 
                                node.expressionResult !== 'Infinity' && 
                                node.expressionResult !== '-Infinity' &&
                                typeof node.expressionResult === 'string'; // å…è®¸å­—ç¬¦ä¸²ç»“æœï¼Œå¦‚"çœŸ"å’Œ"å‡"
            
            if (isValidResult) {
                // æ·»åŠ æˆ–æ›´æ–°ç»“æœæç¤º
                if (!resultHintElement) {
                    resultHintElement = document.createElement('div');
                    resultHintElement.className = 'expression-result-hint';
                    resultHintElement.style.cssText = `
                        position: absolute;
                        top: -25px;
                        right: 0;
                        background: hsl(120, 100%, 30%);
                        color: white;
                        padding: 3px 8px;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: bold;
                        z-index: 100;
                        max-width: 200px;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;
                        cursor: pointer;
                        user-select: none;
                        transition: all 0.2s ease;
                    `;
                    
                    // æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
                    resultHintElement.addEventListener('click', function() {
                        const result = this.textContent.replace('= ', '');
                        navigator.clipboard.writeText(result).then(() => {
                            // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                            const originalBg = this.style.background;
                            this.style.background = 'hsl(210, 100%, 50%)';
                            this.textContent = 'å·²å¤åˆ¶!';
                            
                            setTimeout(() => {
                                this.style.background = originalBg;
                                this.textContent = `= ${result}`;
                            }, 1000);
                        }).catch(err => {
                            console.error('å¤åˆ¶å¤±è´¥:', err);
                        });
                    });
                    
                    nodeElement.appendChild(resultHintElement);
                }
                resultHintElement.textContent = `= ${node.expressionResult}`;
            } else {
                // ç§»é™¤ç»“æœæç¤º
                if (resultHintElement) {
                    resultHintElement.remove();
                }
            }
            
            // å¤„ç†å¸®åŠ©æŒ‰é’®
            const headerElement = nodeElement.querySelector('.node-header');
            let helpButton = nodeElement.querySelector('.help-button');
            
            if (isExprNode) {
                // æ·»åŠ æˆ–æ›´æ–°å¸®åŠ©æŒ‰é’®
                if (!helpButton) {
                    helpButton = document.createElement('span');
                    helpButton.className = 'help-button tool-icon';
                    helpButton.innerHTML = '?';
                    helpButton.style.cssText = `
                        background: hsla(108, 95%, 30%, 1.00);
                        color: white;
                        border-radius: 50%;
                        padding: 2px 6px;
                        font-size: 12px;
                        cursor: pointer;
                        margin-left: 5px;
                        transition: all 0.2s ease;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                    helpButton.addEventListener('click', () => {
                        advancedCalculator.createHelpDialog();
                    });
                    
                    // å°†å¸®åŠ©æŒ‰é’®æ·»åŠ åˆ°æ ‡é¢˜æ çš„tool-groupä¸­
                    const toolGroup = headerElement.querySelector('.tool-group');
                    if (toolGroup) {
                        toolGroup.insertBefore(helpButton, toolGroup.firstChild);
                    }
                }
            } else {
                // ç§»é™¤å¸®åŠ©æŒ‰é’®
                if (helpButton) {
                    helpButton.remove();
                }
            }
        });
    },
    
    // é›†æˆåˆ°ä¸»åº”ç”¨çš„åŠŸèƒ½
    integrateWithApp(app) {
        // ä¿å­˜åŸå§‹çš„saveæ–¹æ³•
        const originalSave = app.save;
        
        // é‡å†™saveæ–¹æ³•ï¼Œæ·»åŠ è®¡ç®—é€»è¾‘
        app.save = function() {
            // æ‰§è¡ŒåŸå§‹ä¿å­˜
            originalSave.call(this);
            
            // æ‰§è¡Œè®¡ç®—
            advancedCalculator.calculateAllExpressions(this.nodes);
            
            // æ›´æ–°æ˜¾ç¤º
            advancedCalculator.updateNodeDisplays(this.nodes);
        };
        
        // ç›‘å¬è¿æ¥å˜åŒ–
        // ç§»é™¤renderConnsä¸­çš„è®¡ç®—é€»è¾‘ï¼Œé¿å…è¿æ¥çº¿æ¸²æŸ“å»¶è¿Ÿ
        // è¿æ¥å˜åŒ–æ—¶ä¸éœ€è¦é‡æ–°è®¡ç®—æ‰€æœ‰è¡¨è¾¾å¼ï¼Œåªåœ¨èŠ‚ç‚¹å†…å®¹å˜åŒ–æ—¶è®¡ç®—
        /*
        const originalRenderConns = app.renderConns;
        app.renderConns = function(mousePos) {
            originalRenderConns.call(this, mousePos);
            advancedCalculator.calculateAllExpressions(this.nodes);
            advancedCalculator.updateNodeDisplays(this.nodes);
        };
        */
        
        // ç›‘å¬èŠ‚ç‚¹æ·»åŠ 
        const originalAddNewNode = app.addNewNode;
        app.addNewNode = function() {
            originalAddNewNode.call(this);
            advancedCalculator.calculateAllExpressions(this.nodes);
            advancedCalculator.updateNodeDisplays(this.nodes);
        };
        
        // ç›‘å¬èŠ‚ç‚¹åˆ é™¤
        const originalRemoveNode = app.removeNode;
        app.removeNode = function(id) {
            originalRemoveNode.call(this, id);
            advancedCalculator.calculateAllExpressions(this.nodes);
            advancedCalculator.updateNodeDisplays(this.nodes);
        };
        
        // ç›‘å¬èŠ‚ç‚¹å†…å®¹å˜åŒ–
        const originalCreateNode = app.createNode;
        app.createNode = function(id, x, y, w, h, name, code, isInstance = false, originalId = null) {
            const node = originalCreateNode.call(this, id, x, y, w, h, name, code, isInstance, originalId);
            
            // æ·»åŠ å†…å®¹å˜åŒ–ç›‘å¬
            const nodeElement = document.getElementById(`n-${id}`);
            if (nodeElement) {
                const textarea = nodeElement.querySelector('.code-input');
                if (textarea && !isInstance) {
                    // ä¿å­˜åŸå§‹inputäº‹ä»¶å¤„ç†å‡½æ•°
                    const originalInput = textarea.oninput;
                    
                    textarea.oninput = function() {
                        // æ‰§è¡ŒåŸå§‹inputå¤„ç†
                        originalInput.call(this);
                        
                        // æ‰§è¡Œè®¡ç®—
                        advancedCalculator.calculateAllExpressions(app.nodes);
                        advancedCalculator.updateNodeDisplays(app.nodes);
                    };
                }
            }
            
            return node;
        };
    }
};

// é¡µé¢åŠ è½½å®Œæˆåé›†æˆåˆ°ä¸»åº”ç”¨
document.addEventListener('DOMContentLoaded', function() {
    // ç­‰å¾…ä¸»åº”ç”¨åˆå§‹åŒ–
    setTimeout(() => {
        if (typeof app !== 'undefined') {
            advancedCalculator.integrateWithApp(app);
            console.log('é«˜çº§èŠ‚ç‚¹å¼è®¡ç®—å™¨åŠŸèƒ½å·²é›†æˆ');
        }
    }, 100);
});


// å›¾ç‰‡å¤„ç†æ¨¡å— - ä»…ä¿ç•™æ‹–æ‹½åŠŸèƒ½
const imageHandler = window.imageHandler = {
    images: [],
    // è·Ÿè¸ªå½“å‰é¼ æ ‡ä½ç½®
    mousePos: { x: 0, y: 0 },
    // è·Ÿè¸ªå½“å‰é€‰ä¸­çš„å›¾ç‰‡
    currentSelectedImage: null,

    // æ‹–åŠ¨ç›¸å…³å˜é‡
    isDragging: false,
    currentDragImageId: null,
    startDragX: 0,
    startDragY: 0,
    startDragImageX: 0,
    startDragImageY: 0,
    

    // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
    // æ·»åŠ ç¼ºå°‘çš„æ–¹æ³•
    isDrawingMode() {
        // å¦‚æœå½“å‰å·¥å…·æ˜¯ç”»ç¬”æˆ–æ©¡çš®æ“¦ï¼Œå°±è®¤ä¸ºæ˜¯ç»˜ç”»æ¨¡å¼
        return this.currentTool === 'brush' || this.currentTool === 'eraser';
    },

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç»˜ç”»ä¸­
    isInDrawing() {
        return this.isDrawing || this.isErasing;
    },

    // åˆå§‹åŒ–å›¾ç‰‡å¤„ç†åŠŸèƒ½
    init() {
        this.setupDragAndDrop();
        this.setupCopyPaste();
        this.setupMouseTracking();
        this.setupImageEditorEvents();
        this.setupResizeEvents();
    },

    // è®¾ç½®è°ƒæ•´å¤§å°äº‹ä»¶
    setupResizeEvents() {
        // æ·»åŠ å…¨å±€é¼ æ ‡ç§»åŠ¨å’Œé‡Šæ”¾äº‹ä»¶
        document.addEventListener('mousemove', (e) => {
            // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
            if (this.isDrawingMode()) {
                // ç»˜ç”»æ¨¡å¼ä¸‹ï¼Œåœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„æ‹–æ‹½
                if (this.isDragging) {
                    this.stopDragging();
                }
                return;
            }

            if (this.isDragging) {
                this.drag(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', () => {
            if (this.isDragging) {
                this.stopDragging();
            }
        });
    },

    // è®¾ç½®å›¾ç‰‡ç¼–è¾‘é¢æ¿äº‹ä»¶
    setupImageEditorEvents() {
        // ä½ç½®è¾“å…¥äº‹ä»¶
        document.getElementById('image-x').addEventListener('input', (e) => {
            e.preventDefault();
            this.updateImagePosition(parseInt(e.target.value), this.currentSelectedImage.y);
        });

        document.getElementById('image-y').addEventListener('input', (e) => {
            e.preventDefault();
            this.updateImagePosition(this.currentSelectedImage.x, parseInt(e.target.value));
        });

        // æ—‹è½¬æ»‘å—äº‹ä»¶
        document.getElementById('image-rotation').addEventListener('input', (e) => {
            e.preventDefault();
            this.updateImageRotation(parseInt(e.target.value));
        });

        // æ—‹è½¬æŒ‰é’®äº‹ä»¶ï¼ˆç®€åŒ–ä¸ºä¸€ä¸ªæŒ‰é’®ï¼Œæ¯æ¬¡æ—‹è½¬90åº¦ï¼‰
        document.querySelector('.rotation-btn').addEventListener('click', (e) => {
            e.preventDefault();
            this.rotateImageByAngle(90);
        });

        // ç¿»è½¬å¤é€‰æ¡†äº‹ä»¶
        document.getElementById('flip-horizontal').addEventListener('change', (e) => {
            e.preventDefault();
            const isChecked = e.target.checked;
            this.setFlipImage('horizontal', isChecked);
        });

        document.getElementById('flip-vertical').addEventListener('change', (e) => {
            e.preventDefault();
            const isChecked = e.target.checked;
            this.setFlipImage('vertical', isChecked);
        });

        // ç¼©æ”¾æ»‘æ†äº‹ä»¶
        document.getElementById('image-scale').addEventListener('input', (e) => {
            e.preventDefault();
            this.updateImageScale(parseFloat(e.target.value));
        });

        // é‡ç½®ç¼©æ”¾æŒ‰é’®äº‹ä»¶
        document.getElementById('reset-scale-btn').addEventListener('click', (e) => {
            e.preventDefault();
            this.resetImageScale();
        });

        // ç§»åŠ¨åˆ°ä¸­å¿ƒä½ç½®æŒ‰é’®äº‹ä»¶
        document.getElementById('move-to-center-btn').addEventListener('click', (e) => {
            e.preventDefault();
            this.moveImageToPosition(2500, 2500);
        });

        // é‡ç½®ç¿»è½¬æŒ‰é’®äº‹ä»¶
        document.getElementById('reset-flip-btn').addEventListener('click', (e) => {
            e.preventDefault();
            this.resetFlipImage();
        });

        // è£å‰ªå›¾ç‰‡æŒ‰é’®äº‹ä»¶
        document.getElementById('crop-image-btn').addEventListener('click', (e) => {
            e.preventDefault();
            if (this.currentSelectedImage) {
                // æ˜¾ç¤ºè£å‰ªå™¨
                imageCropper.show();
                // åŠ è½½å½“å‰é€‰ä¸­çš„å›¾ç‰‡åˆ°è£å‰ªå™¨ï¼Œä½¿ç”¨åŸå§‹å›¾ç‰‡æ•°æ®
                const img = new Image();
                img.onload = () => {
                    imageCropper.loadImage(img);
                };
                img.src = this.currentSelectedImage.originalSrc;
            }
        });

        // è°ƒè‰²åŠŸèƒ½æŒ‰é’®äº‹ä»¶
        document.getElementById('color-adjust-btn').addEventListener('click', (e) => {
            e.preventDefault();
            if (this.currentSelectedImage) {
                // æ˜¾ç¤ºè°ƒè‰²é¢æ¿
                imageColorAdjuster.loadImage(this.currentSelectedImage);
                imageColorAdjuster.show();
            }
        });

        // ä¿å­˜å›¾ç‰‡åŠŸèƒ½æŒ‰é’®äº‹ä»¶
        document.getElementById('save-image-btn').addEventListener('click', (e) => {
            e.preventDefault();
            if (this.currentSelectedImage) {
                this.saveImage(this.currentSelectedImage);
            }
        });

        // ç‚¹å‡»ç”»å¸ƒéšè—å±æ€§æ 
        const container = document.getElementById('container');
        container.addEventListener('click', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯å®¹å™¨æœ¬èº«æˆ–SVGç”»å¸ƒï¼Œéšè—å±æ€§æ 
            if (e.target === container || e.target === document.getElementById('svg-canvas')) {
                this.hideImageEditorPanel();
            }
        });

        // ç‚¹å‡»viewportéšè—å±æ€§æ ï¼ˆé˜²æ­¢ç‚¹å‡»ç©ºç™½åŒºåŸŸæ— æ³•éšè—ï¼‰
        const viewport = document.getElementById('viewport');
        viewport.addEventListener('click', (e) => {
            // ç¡®ä¿ç‚¹å‡»çš„ä¸æ˜¯å›¾ç‰‡ã€æ§åˆ¶é¢æ¿æˆ–å…¶ä»–äº¤äº’å…ƒç´ 
            if (!e.target.closest('.image-item') && !e.target.closest('#image-editor-panel') && !e.target.closest('.floating-header')) {
                this.hideImageEditorPanel();
            }
        });
    },

    // è·Ÿè¸ªé¼ æ ‡ä½ç½®
    setupMouseTracking() {
        document.addEventListener('mousemove', (e) => {
            this.mousePos.x = e.clientX;
            this.mousePos.y = e.clientY;
        });
    },

    // è®¾ç½®å¤åˆ¶ç²˜è´´åŠŸèƒ½
    setupCopyPaste() {
        document.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData || window.clipboardData;
            const items = clipboardData.items;
            let isImagePaste = false;

            // æ£€æŸ¥ç›´æ¥çš„å›¾ç‰‡æ–‡ä»¶
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    this.handlePastedImage(file);
                    isImagePaste = true;
                    break;
                }
            }

            // æ£€æŸ¥DataTransferItemListä¸­æ˜¯å¦æœ‰å›¾ç‰‡URL
            if (!isImagePaste) {
                const html = clipboardData.getData('text/html');
                if (html) {
                    const imgMatch = html.match(/<img[^>]+src="([^"]+)"[^>]*>/);
                    if (imgMatch && imgMatch[1]) {
                        this.handlePastedImageUrl(imgMatch[1]);
                        isImagePaste = true;
                    }
                }
            }

            // æ£€æŸ¥ç›´æ¥çš„å›¾ç‰‡URL
            if (!isImagePaste) {
                const url = clipboardData.getData('text/plain');
                if (url && (url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/i) || url.startsWith('data:image/'))) {
                    this.handlePastedImageUrl(url);
                    isImagePaste = true;
                }
            }

            // åªæœ‰å½“æ£€æµ‹åˆ°å›¾ç‰‡ç²˜è´´æ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
            if (isImagePaste) {
                e.preventDefault();
            }
        });
    },

    // è®¾ç½®æ‹–æ‹½åŠŸèƒ½
    setupDragAndDrop() {
        const viewport = document.getElementById('viewport');

        // æ‹–æ‹½è¿›å…¥äº‹ä»¶
        viewport.addEventListener('dragover', (e) => {
            e.preventDefault();
            viewport.classList.add('drag-over');
        });

        // æ‹–æ‹½ç¦»å¼€äº‹ä»¶
        viewport.addEventListener('dragleave', () => {
            viewport.classList.remove('drag-over');
        });

        // æ‹–æ‹½é‡Šæ”¾äº‹ä»¶
        viewport.addEventListener('drop', (e) => {
            e.preventDefault();
            viewport.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('image/') || file.name.toLowerCase().match(/\.(png|jpg|jpeg|gif|webp|svg)$/i)) {
                    this.handleImageFile(file, e);
                }
            }
        });
    },

    // å¤„ç†ç²˜è´´çš„å›¾ç‰‡æ–‡ä»¶
    handlePastedImage(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const imageData = event.target.result;
            this.addImageAtCurrentPosition(imageData);
        };
        reader.readAsDataURL(file);
    },

    // å¤„ç†ç²˜è´´çš„å›¾ç‰‡URL
    handlePastedImageUrl(url) {
        // å¦‚æœæ˜¯data URLï¼Œç›´æ¥ä½¿ç”¨
        if (url.startsWith('data:image/')) {
            this.addImageAtCurrentPosition(url);
            return;
        }

        // å¦‚æœæ˜¯å¤–éƒ¨URLï¼Œå…ˆä¸‹è½½
        fetch(url)
            .then(response => response.blob())
            .then(blob => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    this.addImageAtCurrentPosition(event.target.result);
                };
                reader.readAsDataURL(blob);
            })
            .catch(error => {
                console.error('æ— æ³•åŠ è½½ç²˜è´´çš„å›¾ç‰‡URL:', error);
            });
    },

    // åœ¨å½“å‰é¼ æ ‡ä½ç½®æ·»åŠ å›¾ç‰‡
    addImageAtCurrentPosition(imageData) {
        const rect = document.getElementById('container').getBoundingClientRect();
        const x = (this.mousePos.x - rect.left) / app.zoom;
        const y = (this.mousePos.y - rect.top) / app.zoom;

        this.addImage(imageData, x, y);
    },

    // å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼ˆæ‹–æ‹½ç”¨ï¼‰
    handleImageFile(file, e) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const imageData = event.target.result;
            const rect = document.getElementById('container').getBoundingClientRect();
            const x = (e.clientX - rect.left) / app.zoom;
            const y = (e.clientY - rect.top) / app.zoom;

            this.addImage(imageData, x, y);
        };
        reader.readAsDataURL(file);
    },

    // æ·»åŠ å›¾ç‰‡åˆ°ç”»å¸ƒ
    addImage(src, x, y) {
        // åˆ›å»ºå›¾ç‰‡ID
        const imageId = Date.now();
        
        // åˆ›å»ºä¸´æ—¶å›¾ç‰‡å¯¹è±¡è·å–å®é™…å°ºå¯¸
        const tempImg = new Image();
        tempImg.onload = () => {
            // ä½¿ç”¨å›¾ç‰‡å®é™…å°ºå¯¸ï¼Œæˆ–è€…è®¾ç½®æœ€å¤§å°ºå¯¸
            const maxWidth = 300;
            const maxHeight = 300;
            let width = tempImg.width;
            let height = tempImg.height;

            // æŒ‰æ¯”ä¾‹ç¼©å°åˆ°å¤§å°ºå¯¸
            if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width = Math.round(width * ratio);
                height = Math.round(height * ratio);
            }

            const image = {
                id: imageId,
                src: src,
                originalSrc: src, // ä¿å­˜åŸå§‹å›¾ç‰‡æ•°æ®
                x: x,
                y: y,
                width: width,
                height: height,
                originalWidth: width, // è®°å½•åŸå§‹å®½åº¦
                originalHeight: height, // è®°å½•åŸå§‹é«˜åº¦
                rotation: 0, // æ·»åŠ æ—‹è½¬å±æ€§
                flipHorizontal: false, // æ°´å¹³ç¿»è½¬çŠ¶æ€
                flipVertical: false, // å‚ç›´ç¿»è½¬çŠ¶æ€
                // è°ƒè‰²å‚æ•°ï¼Œé»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100
                colorParams: {
                    vividness: 0,      // é²œæ˜åº¦
                    exposure: 0,       // æ›å…‰
                    highlight: 0,      // é«˜å…‰
                    shadow: 0,         // é˜´å½±
                    brightness: 0,     // äº®åº¦
                    contrast: 0,       // å¯¹æ¯”åº¦
                    blackPoint: 0      // é»‘ç‚¹
                },
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            this.images.push(image);
            this.renderImage(image);
            this.saveImages();
            
            // æ’­æ”¾åˆ›å»ºå›¾ç‰‡éŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playCreateSound) {
                AudioSystem.playCreateSound();
            }
            
            // åœ¨å›¾ç‰‡ä½ç½®ç”Ÿæˆåˆ›å»ºç‰¹æ•ˆ
            if (window.FXManager && FXManager.spawn) {
                const screenPos = app.toScreen(x + width/2, y + height/2);
                FXManager.spawn(screenPos.x, screenPos.y, '#00ffff', 20); // é’è‰²ç‰¹æ•ˆ
                FXManager.spawnExplosion(screenPos.x, screenPos.y, '#00ffff', 10); // çˆ†ç‚¸ç‰¹æ•ˆ
            }
        };
        tempImg.src = src;
        
        // è¿”å›å›¾ç‰‡ID
        return imageId;
    },

    saveImages() {
        // å¦‚æœæœ‰å­˜å‚¨ç³»ç»Ÿï¼Œä½¿ç”¨å­˜å‚¨ç³»ç»Ÿä¿å­˜
        if (window.StorageSystem && StorageSystem.app) {
            // å­˜å‚¨ç³»ç»Ÿä¼šå¤„ç†å›¾ç‰‡æ•°æ®çš„ä¿å­˜
            StorageSystem.save();
        } else {
            // å›é€€åˆ°åŸæ¥çš„localStorageä¿å­˜
            try {
                const data = {
                    images: this.images,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('editorImages', JSON.stringify(data));
            } catch (error) {
                console.error('ä¿å­˜å›¾ç‰‡æ•°æ®å¤±è´¥:', error);
            }
        }
    },

    // åœ¨ loadImages æ–¹æ³•ä¸­ä¿®æ”¹ï¼š
    loadImages() {
        // ä¼˜å…ˆä½¿ç”¨å­˜å‚¨ç³»ç»ŸåŠ è½½
        if (window.StorageSystem && StorageSystem.app && StorageSystem.imageHandler) {
            // å­˜å‚¨ç³»ç»Ÿå·²åŠ è½½å›¾ç‰‡æ•°æ®ï¼Œä¸éœ€è¦é¢å¤–å¤„ç†
            return;
        }

        // å›é€€åˆ°åŸæ¥çš„localStorageåŠ è½½
        try {
            const savedData = localStorage.getItem('editorImages');
            if (savedData) {
                const data = JSON.parse(savedData);
                this.images = data.images || [];
                // ä¸ºæ—§æ•°æ®æ·»åŠ å±æ€§
                this.images.forEach(image => {
                    if (!image.originalWidth || !image.originalHeight) {
                        image.originalWidth = image.width;
                        image.originalHeight = image.height;
                    }
                    if (image.flipHorizontal === undefined) {
                        image.flipHorizontal = false;
                    }
                    if (image.flipVertical === undefined) {
                        image.flipVertical = false;
                    }
                    // æ·»åŠ åŸå§‹å›¾ç‰‡æ•°æ®å±æ€§
                    if (!image.originalSrc) {
                        image.originalSrc = image.src;
                    }
                });
                // åªåœ¨StorageSystemæœªåˆå§‹åŒ–æ—¶æ‰æ¸²æŸ“å›¾ç‰‡
                if (!window.StorageSystem || !StorageSystem.app) {
                    this.images.forEach(image => {
                        this.renderImage(image);
                    });
                }
            }
        } catch (error) {
            console.error('åŠ è½½å›¾ç‰‡æ•°æ®å¤±è´¥:', error);
        }
    },

    // æ¸²æŸ“å›¾ç‰‡
    renderImage(image) {
        const imgElement = document.createElement('div');
        imgElement.className = 'image-item';
        imgElement.id = `image-${image.id}`;
        imgElement.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            width: ${image.width}px;
            height: ${image.height}px;
            cursor: move;
            user-select: none;
            z-index: 1003; /* æé«˜å›¾ç‰‡z-indexï¼Œç¡®ä¿å›¾ç‰‡æ˜¾ç¤ºåœ¨æ–‡ä»¶å¤¹é¢æ¿ä¸Šé¢ */
            transition: all 0.1s ease;
            transform: translate(${image.x}px, ${image.y}px) rotate(${image.rotation}deg);
            transform-origin: center center;
            box-sizing: border-box;
        `;

        imgElement.innerHTML = `
            <img src="${image.src}" style="width: 100%; height: 100%; object-fit: contain;">
        `;

        // ç§»é™¤contextmenuäº‹ä»¶å¤„ç†ï¼Œä½¿ç”¨é»˜è®¤è¡Œä¸º
        // ç§»é™¤å³é”®ç‚¹å‡»ç›´æ¥åˆ é™¤å›¾ç‰‡çš„åŠŸèƒ½ï¼Œæ”¹ä¸ºé€šè¿‡æ¿€å…‰åˆ‡å‰²åˆ é™¤
        imgElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // ç§»é™¤mousedownäº‹ä»¶å¤„ç†ï¼Œè®©äº‹ä»¶ä¼ æ’­åˆ°viewportï¼Œç”±appçš„setupEventså¤„ç†
        // è¿™æ ·å³é”®æŒ‰ä¸‹æ—¶ï¼Œappä¼šè®¾ç½®isCutting = true
        imgElement.addEventListener('mousedown', (e) => {
            // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
            if (this.isDrawingMode()) {
                // ç»˜ç”»æ¨¡å¼ä¸‹ï¼Œå®Œå…¨é˜»æ­¢äº‹ä»¶ä¼ æ’­å’Œé»˜è®¤è¡Œä¸º
                e.stopPropagation();
                return;
            }

            if (e.button === 0) { // åªå¤„ç†å·¦é”®ç‚¹å‡»
                // ç¡®ä¿ä¸æ˜¯ç‚¹å‡»è°ƒæ•´æ‰‹æŸ„
                if (!e.target.closest('.resize-handle')) {
                    e.preventDefault();
                    this.selectImage(image.id);
                    this.startDragging(image.id, e.clientX, e.clientY);
                    
                    // æ’­æ”¾é€‰ä¸­éŸ³æ•ˆ
                    if (window.AudioSystem && AudioSystem.playButtonSound) {
                        AudioSystem.playButtonSound();
                    }
                    
                    // åœ¨å›¾ç‰‡ä½ç½®ç”Ÿæˆé€‰ä¸­ç‰¹æ•ˆ
                    if (window.FXManager && FXManager.spawn) {
                        const rect = imgElement.getBoundingClientRect();
                        const centerX = rect.left + rect.width/2;
                        const centerY = rect.top + rect.height/2;
                        FXManager.spawn(centerX, centerY, '#ffff00', 10); // é»„è‰²é€‰ä¸­ç‰¹æ•ˆ
                    }
                }
            }
            // å³é”®ç‚¹å‡»ä¸å¤„ç†ï¼Œè®©äº‹ä»¶ä¼ æ’­åˆ°viewport
        });

        // ç§»é™¤é¼ æ ‡ç§»åŠ¨å’Œé‡Šæ”¾äº‹ä»¶å¤„ç†ï¼Œè®©äº‹ä»¶ä¼ æ’­åˆ°windowï¼Œç”±appçš„onmousemoveå’Œonmouseupå¤„ç†
        // è¿™æ ·å½“isCuttingä¸ºtrueæ—¶ï¼Œappä¼šè°ƒç”¨drawLaserå‡½æ•°
        imgElement.addEventListener('mousemove', (e) => {
            // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
            if (this.isDrawingMode()) {
                e.stopPropagation();
            }
            // å…¶ä»–æƒ…å†µä¸é˜»æ­¢äº‹ä»¶ä¼ æ’­ï¼Œè®©äº‹ä»¶ä¼ æ’­åˆ°window
        });

        imgElement.addEventListener('mouseup', (e) => {
            // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
            if (this.isDrawingMode()) {
                e.stopPropagation();
            }
            // å…¶ä»–æƒ…å†µä¸é˜»æ­¢äº‹ä»¶ä¼ æ’­ï¼Œè®©äº‹ä»¶ä¼ æ’­åˆ°window
        });



        // æ·»åŠ åˆ°å›¾ç‰‡å±‚æˆ–å®¹å™¨
        // å¦‚æœæœ‰å›¾ç‰‡å±‚ï¼Œæ·»åŠ åˆ°å›¾ç‰‡å±‚ï¼Œå¦åˆ™æ·»åŠ åˆ°å®¹å™¨
        const nodesLayer = document.getElementById('nodes-layer');
        if (nodesLayer) {
            nodesLayer.appendChild(imgElement);
        } else {
            const container = document.getElementById('container');
            container.appendChild(imgElement);
        }
    },

    // é€‰ä¸­å›¾ç‰‡
    selectImage(imageId) {
        // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
        if (this.isDrawingMode()) {
            // ç»˜ç”»æ¨¡å¼ä¸‹ï¼Œä¸å¤„ç†å›¾ç‰‡é€‰ä¸­
            return;
        }

        // å–æ¶ˆä¹‹å‰é€‰ä¸­çš„å›¾ç‰‡
        if (this.currentSelectedImage) {
            const prevElement = document.getElementById(`image-${this.currentSelectedImage.id}`);
            if (prevElement) {
                prevElement.style.border = '';
            }
        }

        // æ‰¾åˆ°å¹¶è®¾ç½®å½“å‰é€‰ä¸­çš„å›¾ç‰‡
        const image = this.images.find(img => img.id === imageId);
        if (image) {
            this.currentSelectedImage = image;

            // é«˜äº®æ˜¾ç¤ºé€‰ä¸­çš„å›¾ç‰‡
            const imgElement = document.getElementById(`image-${imageId}`);
            if (imgElement) {
                // ç¡®ä¿è¾¹æ¡†ä¸ä¼šæ”¹å˜å®¹å™¨å°ºå¯¸
                imgElement.style.border = '2px solid #2196F3';
                imgElement.style.boxSizing = 'border-box';
            }

            // æ›´æ–°å¹¶æ˜¾ç¤ºç¼–è¾‘é¢æ¿
            this.updateImageEditorPanel();
            this.showImageEditorPanel();
        }
    },

    // æ›´æ–°å›¾ç‰‡ç¼–è¾‘é¢æ¿
    updateImageEditorPanel() {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // æ›´æ–°ä½ç½®ä¿¡æ¯
        document.getElementById('image-x').value = Math.round(image.x);
        document.getElementById('image-y').value = Math.round(image.y);
        // æ›´æ–°æ—‹è½¬ä¿¡æ¯
        document.getElementById('image-rotation').value = image.rotation;
        document.getElementById('rotation-value').textContent = `${image.rotation}Â°`;
        // æ›´æ–°ç¼©æ”¾ä¿¡æ¯
        const scale = Math.round((image.width / image.originalWidth) * 10) / 10;
        document.getElementById('image-scale').value = scale;
        document.getElementById('scale-value').textContent = `${scale}x`;
        // æ›´æ–°ç¿»è½¬å¤é€‰æ¡†çŠ¶æ€
        document.getElementById('flip-horizontal').checked = image.flipHorizontal;
        document.getElementById('flip-vertical').checked = image.flipVertical;
    },

    // æ›´æ–°å›¾ç‰‡ç¼©æ”¾
    updateImageScale(newScale) {
        if (!this.currentSelectedImage || isNaN(newScale)) return;

        const image = this.currentSelectedImage;
        // è®¡ç®—æ–°çš„å®½åº¦å’Œé«˜åº¦
        const newWidth = Math.round(image.originalWidth * newScale);
        const newHeight = Math.round(image.originalHeight * newScale);

        // æ›´æ–°å›¾ç‰‡å°ºå¯¸
        image.width = newWidth;
        image.height = newHeight;
        image.updatedAt = new Date().toISOString();

        // æ›´æ–°DOMæ˜¾ç¤º
        const imgElement = document.getElementById(`image-${image.id}`);
        if (imgElement) {
            imgElement.style.width = `${newWidth}px`;
            imgElement.style.height = `${newHeight}px`;
            // ç¡®ä¿ä½ç½®å’Œæ—‹è½¬ä¹Ÿæ­£ç¡®
            imgElement.style.transform = `translate(${image.x}px, ${image.y}px) rotate(${image.rotation}deg)`;
        }

        // æ›´æ–°é¢æ¿æ˜¾ç¤º
        document.getElementById('scale-value').textContent = `${newScale}x`;

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
        

    },

    // é‡ç½®å›¾ç‰‡ç¼©æ”¾åˆ°åŸå§‹å¤§å°
    resetImageScale() {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // æ¢å¤åŸå§‹å°ºå¯¸
        const originalWidth = image.originalWidth;
        const originalHeight = image.originalHeight;

        // æ›´æ–°å›¾ç‰‡å°ºå¯¸
        image.width = originalWidth;
        image.height = originalHeight;
        image.updatedAt = new Date().toISOString();

        // æ›´æ–°DOMæ˜¾ç¤º
        const imgElement = document.getElementById(`image-${image.id}`);
        if (imgElement) {
            imgElement.style.width = `${originalWidth}px`;
            imgElement.style.height = `${originalHeight}px`;
            // ç¡®ä¿ä½ç½®å’Œæ—‹è½¬ä¹Ÿæ­£ç¡®
            imgElement.style.transform = `translate(${image.x}px, ${image.y}px) rotate(${image.rotation}deg)`;
        }

        // æ›´æ–°é¢æ¿æ˜¾ç¤º
        document.getElementById('image-scale').value = 1;
        document.getElementById('scale-value').textContent = `1.0x`;

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
        

    },

    // æ›´æ–°å›¾ç‰‡ä½ç½®
    updateImagePosition(newX, newY) {
        if (!this.currentSelectedImage || isNaN(newX) || isNaN(newY)) return;

        const image = this.currentSelectedImage;
        image.x = newX;
        image.y = newY;
        image.updatedAt = new Date().toISOString();

        // æ›´æ–°DOMæ˜¾ç¤º
        const imgElement = document.getElementById(`image-${image.id}`);
        if (imgElement) {
            imgElement.style.transform = `translate(${newX}px, ${newY}px) rotate(${image.rotation}deg)`;
        }

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
        
        // æ’­æ”¾ç§»åŠ¨éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
        
        // ç”Ÿæˆç§»åŠ¨ç‰¹æ•ˆ
        if (window.FXManager && FXManager.spawn) {
            const rect = imgElement.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            FXManager.spawn(centerX, centerY, '#2196F3', 8); // è“è‰²ç§»åŠ¨ç‰¹æ•ˆ
        }
    },

    // æ˜¾ç¤ºå›¾ç‰‡ç¼–è¾‘é¢æ¿
    showImageEditorPanel() {
        document.getElementById('image-editor-panel').style.display = 'block';
        
        // æ’­æ”¾é¢æ¿æ‰“å¼€éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
    },

    // éšè—å›¾ç‰‡ç¼–è¾‘é¢æ¿
    hideImageEditorPanel() {
        document.getElementById('image-editor-panel').style.display = 'none';

        // æ’­æ”¾é¢æ¿å…³é—­éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }

        // å–æ¶ˆé€‰ä¸­çš„å›¾ç‰‡
        if (this.currentSelectedImage) {
            const imgElement = document.getElementById(`image-${this.currentSelectedImage.id}`);
            if (imgElement) {
                imgElement.style.border = '';
            }
            this.currentSelectedImage = null;
        }
    },

    // æ›´æ–°å›¾ç‰‡æ—‹è½¬è§’åº¦
    updateImageRotation(newRotation) {
        if (!this.currentSelectedImage || isNaN(newRotation)) return;

        const image = this.currentSelectedImage;
        // ç¡®ä¿æ—‹è½¬è§’åº¦åœ¨0-360èŒƒå›´å†…ï¼Œå½“ç­‰äº360æ—¶ä¿æŒ360
        if (newRotation === 360) {
            image.rotation = 360;
        } else {
            image.rotation = newRotation % 360;
            if (image.rotation < 0) {
                image.rotation += 360;
            }
        }
        image.updatedAt = new Date().toISOString();

        // æ›´æ–°DOMæ˜¾ç¤º
        const imgElement = document.getElementById(`image-${image.id}`);
        if (imgElement) {
            // ä½¿ç”¨transformåŒæ—¶è®¾ç½®ä½ç½®å’Œæ—‹è½¬
            imgElement.style.transform = `translate(${image.x}px, ${image.y}px) rotate(${image.rotation}deg)`;
        }

        // æ›´æ–°é¢æ¿æ˜¾ç¤º
        document.getElementById('rotation-value').textContent = `${image.rotation}Â°`;

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
        

    },

    // å¼€å§‹æ‹–åŠ¨å›¾ç‰‡
    startDragging(imageId, startX, startY) {
        // æ£€æŸ¥æ˜¯å¦å¤„äºç»˜ç”»æ¨¡å¼
        if (this.isDrawingMode()) {
            // ç»˜ç”»æ¨¡å¼ä¸‹ï¼Œä¸å¤„ç†å›¾ç‰‡æ‹–åŠ¨
            return;
        }

        const image = this.images.find(img => img.id === imageId);
        if (!image) return;

        this.isDragging = true;
        this.currentDragImageId = imageId;
        this.startDragX = startX;
        this.startDragY = startY;
        this.startDragImageX = image.x;
        this.startDragImageY = image.y;
    },

    // æ‹–åŠ¨å›¾ç‰‡
    drag(currentX, currentY) {
        if (!this.isDragging || !this.currentDragImageId) return;

        // è®¡ç®—é¼ æ ‡ç§»åŠ¨çš„è·ç¦»
        const deltaX = currentX - this.startDragX;
        const deltaY = currentY - this.startDragY;

        // æ›´æ–°å›¾ç‰‡ä½ç½®
        const newX = this.startDragImageX + deltaX / app.zoom;
        const newY = this.startDragImageY + deltaY / app.zoom;

        // ç›´æ¥æ›´æ–°DOMï¼Œé¿å…å¤šæ¬¡æŸ¥æ‰¾
        const imgElement = document.getElementById(`image-${this.currentDragImageId}`);
        if (imgElement) {
            // ä½¿ç”¨transformä»£æ›¿top/leftï¼Œæé«˜æ€§èƒ½
            imgElement.style.transform = `translate(${newX}px, ${newY}px) rotate(${this.currentSelectedImage.rotation}deg)`;
        }

        // åªæ›´æ–°å›¾ç‰‡å¯¹è±¡çš„ä½ç½®ï¼Œé¿å…æ›´æ–°å…¶ä»–å±æ€§
        this.currentSelectedImage.x = newX;
        this.currentSelectedImage.y = newY;

        // å‡å°‘ç¼–è¾‘é¢æ¿æ›´æ–°é¢‘ç‡ï¼Œåªåœ¨å¿…è¦æ—¶æ›´æ–°
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            this.updateImageEditorPanel();
            // é‡ç½®deltaXå’ŒdeltaYçš„å‚è€ƒç‚¹
            this.startDragX = currentX;
            this.startDragY = currentY;
            this.startDragImageX = newX;
            this.startDragImageY = newY;
        }
    },

    // åœæ­¢æ‹–åŠ¨å›¾ç‰‡
    stopDragging() {
        if (this.isDragging) {
            this.isDragging = false;
            // ä¿å­˜æ‹–åŠ¨ç»“æŸæ—¶çš„æ›´æ–°æ—¶é—´
            if (this.currentSelectedImage) {
                this.currentSelectedImage.updatedAt = new Date().toISOString();
            }
            this.saveImages(); // ä¿å­˜æ‹–åŠ¨åçš„ä½ç½®
            
            // æ’­æ”¾æ‹–æ”¾éŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
            
            // ç”Ÿæˆæ‹–æ”¾ç‰¹æ•ˆ
            if (window.FXManager && FXManager.spawnExplosion && this.currentSelectedImage) {
                const imgElement = document.getElementById(`image-${this.currentSelectedImage.id}`);
                if (imgElement) {
                    const rect = imgElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width/2;
                    const centerY = rect.top + rect.height/2;
                    FXManager.spawnExplosion(centerX, centerY, '#00ff00', 8); // ç»¿è‰²çˆ†ç‚¸ç‰¹æ•ˆ
                }
            }
        }
    },

    // æŒ‰æŒ‡å®šè§’åº¦æ—‹è½¬å›¾ç‰‡ï¼ˆç¡®ä¿è§’åº¦åœ¨0-360èŒƒå›´å†…ï¼‰
    rotateImageByAngle(angle) {
        if (!this.currentSelectedImage) return;

        const currentRotation = this.currentSelectedImage.rotation;
        let newRotation = currentRotation + angle;
        // ç¡®ä¿æ—‹è½¬è§’åº¦åœ¨0-360èŒƒå›´å†…
        if (newRotation === 360) {
            newRotation = 360;
        } else {
            newRotation = newRotation % 360;
            if (newRotation < 0) {
                newRotation += 360;
            }
        }
        this.updateImageRotation(newRotation);
    },

    // ç¿»è½¬å›¾ç‰‡
    flipImage(direction) {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // æ›´æ–°ç¿»è½¬çŠ¶æ€
        if (direction === 'horizontal') {
            image.flipHorizontal = !image.flipHorizontal;
        } else if (direction === 'vertical') {
            image.flipVertical = !image.flipVertical;
        }

        // æ›´æ–°å›¾ç‰‡æ˜¾ç¤º
        this.updateImageFlip(image);
        // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
        this.updateImageEditorPanel();

        image.updatedAt = new Date().toISOString();
        this.saveImages();
        
        // æ’­æ”¾ç¿»è½¬éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
        
        // ç”Ÿæˆç¿»è½¬ç‰¹æ•ˆ
        if (window.FXManager && FXManager.spawn) {
            const imgElement = document.getElementById(`image-${image.id}`);
            if (imgElement) {
                const rect = imgElement.getBoundingClientRect();
                const centerX = rect.left + rect.width/2;
                const centerY = rect.top + rect.height/2;
                
                if (direction === 'horizontal') {
                    // å·¦å³ç¿»è½¬ç‰¹æ•ˆ
                    FXManager.spawnFlow(centerX, centerY, 'left', '#ff6600', 10);
                    FXManager.spawnFlow(centerX, centerY, 'right', '#ff6600', 10);
                } else {
                    // ä¸Šä¸‹ç¿»è½¬ç‰¹æ•ˆ
                    FXManager.spawnFlow(centerX, centerY, 'up', '#ff6600', 10);
                    FXManager.spawnFlow(centerX, centerY, 'down', '#ff6600', 10);
                }
            }
        }
    },

    // è®¾ç½®å›¾ç‰‡ç¿»è½¬çŠ¶æ€
    setFlipImage(direction, isFlip) {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // æ›´æ–°ç¿»è½¬çŠ¶æ€
        if (direction === 'horizontal') {
            image.flipHorizontal = isFlip;
        } else if (direction === 'vertical') {
            image.flipVertical = isFlip;
        }

        // æ›´æ–°å›¾ç‰‡æ˜¾ç¤º
        this.updateImageFlip(image);

        image.updatedAt = new Date().toISOString();
        this.saveImages();
        
        // æ’­æ”¾ç¿»è½¬éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
    },

    // æ›´æ–°å›¾ç‰‡ç¿»è½¬æ˜¾ç¤º
    updateImageFlip(image) {
        const imgElement = document.getElementById(`image-${image.id}`);
        if (!imgElement) return;

        const img = imgElement.querySelector('img');
        if (!img) return;

        // æ„å»ºtransformæ ·å¼
        let transform = '';
        if (image.flipHorizontal) {
            transform += ' scaleX(-1)';
        }
        if (image.flipVertical) {
            transform += ' scaleY(-1)';
        }

        img.style.transform = transform;
    },

    // é‡ç½®å›¾ç‰‡ç¿»è½¬ä¸ºåˆå§‹çŠ¶æ€
    resetFlipImage() {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // é‡ç½®ç¿»è½¬çŠ¶æ€
        image.flipHorizontal = false;
        image.flipVertical = false;

        // æ›´æ–°å›¾ç‰‡æ˜¾ç¤º
        this.updateImageFlip(image);
        // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
        this.updateImageEditorPanel();

        image.updatedAt = new Date().toISOString();
        this.saveImages();
        
        // æ’­æ”¾é‡ç½®éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
        
        // ç”Ÿæˆé‡ç½®ç‰¹æ•ˆ
        if (window.FXManager && FXManager.spawnExplosion) {
            const imgElement = document.getElementById(`image-${image.id}`);
            if (imgElement) {
                const rect = imgElement.getBoundingClientRect();
                const centerX = rect.left + rect.width/2;
                const centerY = rect.top + rect.height/2;
                FXManager.spawnExplosion(centerX, centerY, '#00ffff', 12); // é’è‰²çˆ†ç‚¸ç‰¹æ•ˆ
            }
        }
    },

    // å°†å›¾ç‰‡ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®
    moveImageToPosition(targetX, targetY) {
        if (!this.currentSelectedImage) return;

        const image = this.currentSelectedImage;
        // æ›´æ–°å›¾ç‰‡ä½ç½®
        image.x = targetX;
        image.y = targetY;
        image.updatedAt = new Date().toISOString();

        // æ›´æ–°DOMæ˜¾ç¤º
        const imgElement = document.getElementById(`image-${image.id}`);
        if (imgElement) {
            imgElement.style.transform = `translate(${targetX}px, ${targetY}px) rotate(${image.rotation}deg)`;
        }

        // æ›´æ–°ç¼–è¾‘é¢æ¿
        this.updateImageEditorPanel();

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
        
        // æ’­æ”¾ç§»åŠ¨éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playButtonSound) {
            AudioSystem.playButtonSound();
        }
        
        // ç”Ÿæˆç§»åŠ¨ç‰¹æ•ˆ
        if (window.FXManager && FXManager.spawnExplosion) {
            const rect = imgElement.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            FXManager.spawnExplosion(centerX, centerY, '#2196F3', 15); // è“è‰²çˆ†ç‚¸ç‰¹æ•ˆ
        }
    },

    // åˆ é™¤å›¾ç‰‡
    deleteImage(imageId) {
        // æ’­æ”¾åˆ é™¤éŸ³æ•ˆ
        if (window.AudioSystem && AudioSystem.playDeleteSound) {
            AudioSystem.playDeleteSound();
        }
        
        // è·å–å›¾ç‰‡ä½ç½®ç”¨äºç‰¹æ•ˆ
        const image = this.images.find(img => img.id === imageId);
        let imgElement = null;
        if (image) {
            imgElement = document.getElementById(`image-${imageId}`);
        }

        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„å›¾ç‰‡ï¼Œå–æ¶ˆé€‰ä¸­
        if (this.currentSelectedImage && this.currentSelectedImage.id === imageId) {
            this.currentSelectedImage = null;
            this.hideImageEditorPanel();
        }

        // ä»æ•°ç»„ä¸­åˆ é™¤
        const index = this.images.findIndex(img => img.id === imageId);
        if (index > -1) {
            this.images.splice(index, 1);
        }

        // ä»DOMä¸­åˆ é™¤
        if (imgElement) {
            // åœ¨åˆ é™¤å‰ç”Ÿæˆç‰¹æ•ˆ
            if (window.FXManager && FXManager.spawnExplosion) {
                const rect = imgElement.getBoundingClientRect();
                const centerX = rect.left + rect.width/2;
                const centerY = rect.top + rect.height/2;
                FXManager.spawnExplosion(centerX, centerY, '#ff0000', 25); // çº¢è‰²åˆ é™¤ç‰¹æ•ˆ
            }
            
            // æ·»åŠ åˆ é™¤åŠ¨ç”»
            imgElement.style.opacity = '0';
            imgElement.style.transform += ' scale(0.5)';
            setTimeout(() => {
                imgElement.remove();
            }, 200);
        }

        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        this.saveImages();
    },
    
    // ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°
    saveImage(image) {
        if (!image) return;
        
        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶Canvasæ¥è·å–å®Œæ•´çš„å›¾ç‰‡æ•°æ®
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®Canvaså°ºå¯¸ä¸ºå›¾ç‰‡çš„åŸå§‹å°ºå¯¸
        canvas.width = image.originalWidth;
        canvas.height = image.originalHeight;
        
        // ç»˜åˆ¶å›¾ç‰‡åˆ°Canvas
        const img = new Image();
        img.onload = () => {
            // ç»˜åˆ¶å›¾ç‰‡
            ctx.drawImage(img, 0, 0);
            
            // è·å–å›¾ç‰‡æ•°æ®
            const dataURL = canvas.toDataURL('image/png');
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const link = document.createElement('a');
            link.download = `edited-image-${Date.now()}.png`;
            link.href = dataURL;
            
            // è§¦å‘ä¸‹è½½
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // æ’­æ”¾ä¿å­˜éŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
            
            // ç”Ÿæˆä¿å­˜ç‰¹æ•ˆ
            if (window.FXManager && FXManager.spawn) {
                const screenPos = app.toScreen(image.x + image.width/2, image.y + image.height/2);
                FXManager.spawn(screenPos.x, screenPos.y, '#00ff00', 20); // ç»¿è‰²ä¿å­˜ç‰¹æ•ˆ
            }
        };
        img.src = image.src;
    },
    
    // å›¾å±‚æ“ä½œï¼šä¸Šç§»ä¸€å±‚
    moveImageUp() {
        if (!this.currentSelectedImage) return;
        
        const imageId = this.currentSelectedImage.id;
        const index = this.images.findIndex(img => img.id === imageId);
        
        if (index < this.images.length - 1) {
            // äº¤æ¢æ•°ç»„ä¸­çš„ä½ç½®
            [this.images[index], this.images[index + 1]] = [this.images[index + 1], this.images[index]];
            // æ›´æ–°DOMé¡ºåº
            this.updateImageOrder();
            // ä¿å­˜æ›´æ–°
            this.saveImages();
            
            // æ’­æ”¾æ“ä½œéŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
        }
    },
    
    // å›¾å±‚æ“ä½œï¼šä¸‹ç§»ä¸€å±‚
    moveImageDown() {
        if (!this.currentSelectedImage) return;
        
        const imageId = this.currentSelectedImage.id;
        const index = this.images.findIndex(img => img.id === imageId);
        
        if (index > 0) {
            // äº¤æ¢æ•°ç»„ä¸­çš„ä½ç½®
            [this.images[index], this.images[index - 1]] = [this.images[index - 1], this.images[index]];
            // æ›´æ–°DOMé¡ºåº
            this.updateImageOrder();
            // ä¿å­˜æ›´æ–°
            this.saveImages();
            
            // æ’­æ”¾æ“ä½œéŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
        }
    },
    
    // å›¾å±‚æ“ä½œï¼šç½®é¡¶
    moveImageToTop() {
        if (!this.currentSelectedImage) return;
        
        const imageId = this.currentSelectedImage.id;
        const index = this.images.findIndex(img => img.id === imageId);
        
        if (index < this.images.length - 1) {
            // å°†å›¾ç‰‡ç§»åˆ°æ•°ç»„æœ«å°¾
            const [movedImage] = this.images.splice(index, 1);
            this.images.push(movedImage);
            // æ›´æ–°DOMé¡ºåº
            this.updateImageOrder();
            // ä¿å­˜æ›´æ–°
            this.saveImages();
            
            // æ’­æ”¾æ“ä½œéŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
        }
    },
    
    // å›¾å±‚æ“ä½œï¼šç½®ä½
    moveImageToBottom() {
        if (!this.currentSelectedImage) return;
        
        const imageId = this.currentSelectedImage.id;
        const index = this.images.findIndex(img => img.id === imageId);
        
        if (index > 0) {
            // å°†å›¾ç‰‡ç§»åˆ°æ•°ç»„å¼€å¤´
            const [movedImage] = this.images.splice(index, 1);
            this.images.unshift(movedImage);
            // æ›´æ–°DOMé¡ºåº
            this.updateImageOrder();
            // ä¿å­˜æ›´æ–°
            this.saveImages();
            
            // æ’­æ”¾æ“ä½œéŸ³æ•ˆ
            if (window.AudioSystem && AudioSystem.playButtonSound) {
                AudioSystem.playButtonSound();
            }
        }
    },
    
    // æ›´æ–°å›¾ç‰‡åœ¨DOMä¸­çš„é¡ºåº
    updateImageOrder() {
        const nodesLayer = document.getElementById('nodes-layer');
        if (!nodesLayer) return;
        
        // æŒ‰é¡ºåºé‡æ–°æ·»åŠ å›¾ç‰‡å…ƒç´ 
        this.images.forEach(image => {
            const imgElement = document.getElementById(`image-${image.id}`);
            if (imgElement) {
                // å…ˆç§»é™¤å…ƒç´ 
                imgElement.remove();
                // å†æ·»åŠ å…ƒç´ ï¼Œè¿™æ ·ä¼šå°†å…¶ç§»åˆ°å›¾å±‚æœ«å°¾ï¼ˆæœ€ä¸Šå±‚ï¼‰
                nodesLayer.appendChild(imgElement);
            }
        });
    }
};

// åˆå§‹åŒ–å›¾ç‰‡å¤„ç†æ¨¡å—
window.addEventListener('load', () => {
    imageHandler.init();
    imageHandler.loadImages();
});

// å›¾ç‰‡è£å‰ªåŠŸèƒ½æ¨¡å—
// æ ¸å¿ƒåŠŸèƒ½ï¼šå›¾ç‰‡åŠ è½½ä¸é¢„è§ˆã€è£å‰ªåŒºåŸŸé€‰æ‹©ä¸è°ƒæ•´ã€è£å‰ªæ¯”ä¾‹è®¾ç½®ã€è£å‰ªæ“ä½œæ‰§è¡Œã€è£å‰ªç»“æœé¢„è§ˆåŠå¯¼å‡º
const imageCropper = window.imageCropper = {
    // ä¿å­˜ä¸Šæ¬¡çš„è£å‰ªçŠ¶æ€
    savedCropState: {
        cropBox: {
            x: 0,
            y: 0,
            width: 200,
            height: 200
        },
        aspectRatio: null, // nullè¡¨ç¤ºè‡ªç”±æ¯”ä¾‹
        rotation: 0, // æ—‹è½¬è§’åº¦ï¼Œå•ä½ï¼šåº¦
        gridType: 'thirds' // åˆ†å‰²çº¿ç±»å‹ï¼šthirds(ä¸‰åˆ†çº¿)æˆ–golden(é»„é‡‘æ¯”ä¾‹)
    },
    
    // è£å‰ªçŠ¶æ€
    state: {
        isCropping: false,
        currentImage: null,
        originalImage: null,
        canvas: null,
        ctx: null,
        cropBox: {
            x: 0,
            y: 0,
            width: 200,
            height: 200
        },
        aspectRatio: null, // nullè¡¨ç¤ºè‡ªç”±æ¯”ä¾‹
        rotation: 0, // æ—‹è½¬è§’åº¦ï¼Œå•ä½ï¼šåº¦
        gridType: 'thirds', // åˆ†å‰²çº¿ç±»å‹ï¼šthirds(ä¸‰åˆ†çº¿)æˆ–golden(é»„é‡‘æ¯”ä¾‹)
        isResizing: false,
        resizeHandle: null,
        startX: 0,
        startY: 0,
        startCropBox: { x: 0, y: 0, width: 0, height: 0 },
        isDragging: false
    },

    // åˆå§‹åŒ–è£å‰ªåŠŸèƒ½
    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.setupRatioButtons();
    },

    // è®¾ç½®Canvas
    setupCanvas() {
        // åˆ›å»ºè£å‰ªé¢„è§ˆå®¹å™¨
        const container = document.createElement('div');
        container.id = 'image-cropper-container';
        container.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        `;

        // åˆ›å»ºè£å‰ªé¢æ¿
        const panel = document.createElement('div');
        panel.id = 'image-cropper-panel';
        panel.style.cssText = `
            background: #222;
            padding: 20px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        `;

        // ç§»é™¤äº†é¡¶éƒ¨æ ‡é¢˜

        // åˆ›å»ºCanvaså®¹å™¨
        const canvasContainer = document.createElement('div');
        canvasContainer.id = 'canvas-container';
        canvasContainer.style.cssText = `
            position: relative;
            margin-bottom: 20px;
            border: 2px solid #444;
            background: transparent;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            margin-left: auto;
            margin-right: auto;
        `;

        // åˆ›å»ºCanvas
        const canvas = document.createElement('canvas');
        canvas.id = 'crop-canvas';
        canvas.style.cssText = `
            display: block;
            border-radius: 6px;
            margin: 0 auto;
        `;

        // åˆ›å»ºè£å‰ªé®ç½©å±‚
        const mask = document.createElement('div');
        mask.id = 'crop-mask';
        mask.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 1;
        `;
        canvasContainer.appendChild(mask);

        // åˆ›å»ºè£å‰ªæ¡†
        const cropBox = document.createElement('div');
        cropBox.id = 'crop-box';
        cropBox.style.cssText = `
            position: absolute;
            border: 2px solid #4CAF50;
            background: transparent;
            cursor: move;
            z-index: 2;
        `;

        // åˆ›å»ºä¸‰åˆ†çº¿å®¹å™¨
        const gridContainer = document.createElement('div');
        gridContainer.id = 'crop-grid';
        gridContainer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        `;
        cropBox.appendChild(gridContainer);

        // åˆ›å»ºè°ƒæ•´æ‰‹æŸ„
        const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
        handles.forEach(handle => {
            const handleEl = document.createElement('div');
            handleEl.className = `resize-handle ${handle}`;
            handleEl.dataset.handle = handle;
            handleEl.style.cssText = `
                position: absolute;
                width: 16px;
                height: 16px;
                background: #333;
                border: 2px solid #4CAF50;
                border-radius: 50%;
                cursor: ${this.getCursorStyle(handle)};
                box-sizing: border-box;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
                transition: all 0.2s ease;
            `;
            cropBox.appendChild(handleEl);
        });

        // åˆ›å»ºæ§åˆ¶æŒ‰é’®åŒº
        const controls = document.createElement('div');
        controls.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
        `;

        // è£å‰ªæ¯”ä¾‹é€‰æ‹©
        const ratioGroup = document.createElement('div');
        ratioGroup.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        `;
        ratioGroup.innerHTML = `
            <label style="
                margin-right: 10px;
                font-size: 16px;
                font-weight: bold;
                color: #ccc;
            ">æ¯”ä¾‹æ ¡æ­£ï¼š</label>
            <button class="ratio-btn" data-ratio="original" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">åŸæ¯”ä¾‹</button>
            <button class="ratio-btn" data-ratio="1:1" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">1:1</button>
            <button class="ratio-btn" data-ratio="4:3" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">4:3</button>
            <button class="ratio-btn" data-ratio="16:9" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">16:9</button>
            <button class="ratio-btn" data-ratio="3:4" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">3:4</button>
            <button class="ratio-btn" data-ratio="9:16" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">9:16</button>
            <button class="ratio-btn" data-ratio="free" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">è‡ªç”±</button>
        `;

        // åˆ†å‰²çº¿ç±»å‹é€‰æ‹©
        const gridTypeGroup = document.createElement('div');
        gridTypeGroup.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: flex-start;
            margin: 0 auto;
        `;
        gridTypeGroup.innerHTML = `
            <label style="
                margin-right: 10px;
                font-size: 16px;
                font-weight: bold;
                color: #ccc;
            ">åˆ†å‰²çº¿ç±»å‹ï¼š</label>
            <button class="grid-type-btn" data-type="thirds" style="
                padding: 8px 16px;
                background: #4CAF50;
                color: white;
                border: 1px solid #4CAF50;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">ä¸‰åˆ†çº¿</button>
            <button class="grid-type-btn" data-type="golden" style="
                padding: 8px 16px;
                background: #333;
                color: #fff;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s ease;
            ">é»„é‡‘æ¯”ä¾‹çº¿</button>
        `;
        
        // æ—‹è½¬æ§åˆ¶ç»„
        const rotationGroup = document.createElement('div');
        rotationGroup.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: flex-start;
            margin: 0 auto;
            width: 100%;
            flex-wrap: wrap;
        `;
        rotationGroup.innerHTML = `
            <label style="margin-right: 10px; font-size: 16px; font-weight: bold; color: #ccc;">æ—‹è½¬è§’åº¦ï¼š</label>
            <span id="crop-rotation-value" style="min-width: 50px; text-align: center; color: #fff; font-size: 16px; font-weight: bold;">0Â°</span>
            <input type="range" id="crop-rotation-slider" min="0" max="360" value="0" style="width: 300px; cursor: pointer;">
            <button id="crop-reset-rotation" style="padding: 8px 16px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.3s ease;">æ¢å¤åŸå›¾è§’åº¦</button>
        `;

        // ç»„è£…DOMç»“æ„
        canvasContainer.appendChild(canvas);
        canvasContainer.appendChild(cropBox);
        controls.appendChild(ratioGroup);
        controls.appendChild(gridTypeGroup);
        controls.appendChild(rotationGroup);
        panel.appendChild(canvasContainer);
        panel.appendChild(controls);
        container.appendChild(panel);
        document.body.appendChild(container);

        // ä¿å­˜å¼•ç”¨
        this.state.canvas = canvas;
        this.state.ctx = canvas.getContext('2d');
    },

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    setupEventListeners() {
        // è£å‰ªæ¡†äº‹ä»¶
        const cropBox = document.getElementById('crop-box');
        const canvasContainer = document.getElementById('canvas-container');
        const container = document.getElementById('image-cropper-container');
        const panel = document.getElementById('image-cropper-panel');

        // è£å‰ªæ¡†æ‹–åŠ¨
        cropBox.addEventListener('mousedown', (e) => {
            if (e.target === cropBox) {
                this.startDrag(e);
            }
        });

        // è°ƒæ•´æ‰‹æŸ„äº‹ä»¶
        document.querySelectorAll('.resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                this.startResize(e);
            });
        });

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        document.addEventListener('mousemove', (e) => {
            this.onMouseMove(e);
        });

        // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
        document.addEventListener('mouseup', () => {
            this.stopDrag();
            this.stopResize();
        });

        // ç‚¹å‡»éè£å‰ªåŒºåŸŸä¿å­˜å¹¶å…³é—­è£å‰ªå™¨
        container.addEventListener('click', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯å®¹å™¨æœ¬èº«è€Œä¸æ˜¯é¢æ¿æˆ–å…¶å­å…ƒç´ ï¼Œåˆ™ä¿å­˜å¹¶å…³é—­
            if (e.target === container) {
                // ä¿å­˜è£å‰ªç»“æœ
                this.saveResult();
            }
        });

        // æ—‹è½¬æ»‘å—äº‹ä»¶
        const rotationSlider = document.getElementById('crop-rotation-slider');
        if (rotationSlider) {
            rotationSlider.addEventListener('input', (e) => {
                const rotation = parseInt(e.target.value, 10);
                this.setRotation(rotation);
            });
        }

        // æ¢å¤æ—‹è½¬æŒ‰é’®äº‹ä»¶
        const resetRotationBtn = document.getElementById('crop-reset-rotation');
        if (resetRotationBtn) {
            resetRotationBtn.addEventListener('click', () => {
                this.setRotation(0);
            });
        }
        
        // åˆ†å‰²çº¿ç±»å‹åˆ‡æ¢äº‹ä»¶
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('grid-type-btn')) {
                const gridType = e.target.dataset.type;
                this.setGridType(gridType);
            }
        });
    },
    
    // è®¾ç½®åˆ†å‰²çº¿ç±»å‹
    setGridType(type) {
        this.state.gridType = type;
        
        // æ›´æ–°æŒ‰é’®æ ·å¼
        document.querySelectorAll('.grid-type-btn').forEach(btn => {
            btn.style.backgroundColor = '#333';
            btn.style.color = '#fff';
            btn.style.border = '1px solid #555';
            btn.style.transform = 'scale(1)';
        });
        
        const targetBtn = document.querySelector(`[data-type="${type}"]`);
        if (targetBtn) {
            targetBtn.style.backgroundColor = '#4CAF50';
            targetBtn.style.color = 'white';
            targetBtn.style.border = '1px solid #4CAF50';
            targetBtn.style.transform = 'scale(1.05)';
        }
        
        // æ›´æ–°åˆ†å‰²çº¿ä½ç½®
        this.updateGridLines();
    },

    // è®¾ç½®æ¯”ä¾‹æŒ‰é’®
    setupRatioButtons() {
        document.querySelectorAll('.ratio-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                this.selectRatioButton(e.target.dataset.ratio);
            });
        });
        
        // ä»localStorageè¯»å–ä¸Šæ¬¡ä¿å­˜çš„æ¯”ä¾‹ï¼Œå¦‚æœå­˜åœ¨åˆ™è®¾ç½®ä¸ºå½“å‰é€‰ä¸­çŠ¶æ€
        const lastRatio = localStorage.getItem('lastSelectedRatio');
        if (lastRatio) {
            this.selectRatioButton(lastRatio);
        }
    },
    
    // é€‰ä¸­æŒ‡å®šæ¯”ä¾‹æŒ‰é’®
    selectRatioButton(ratio) {
        // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„æ¿€æ´»çŠ¶æ€
        document.querySelectorAll('.ratio-btn').forEach(b => {
            b.style.backgroundColor = '#333';
            b.style.color = '#fff';
            b.style.border = '1px solid #555';
            b.style.transform = 'scale(1)';
        });
        
        // æ‰¾åˆ°å¹¶è®¾ç½®å½“å‰æŒ‰é’®ä¸ºæ¿€æ´»çŠ¶æ€
        const targetBtn = document.querySelector(`[data-ratio="${ratio}"]`);
        if (targetBtn) {
            targetBtn.style.backgroundColor = '#4CAF50';
            targetBtn.style.color = 'white';
            targetBtn.style.border = '1px solid #4CAF50';
            targetBtn.style.transform = 'scale(1.05)';
        }
        
        // è®¾ç½®è£å‰ªæ¯”ä¾‹
        if (ratio === 'free') {
            this.state.aspectRatio = null;
        } else if (ratio === 'original') {
            // ä½¿ç”¨åŸå§‹å›¾ç‰‡çš„å®½é«˜æ¯”
            if (this.state.originalImage) {
                this.state.aspectRatio = this.state.originalImage.width / this.state.originalImage.height;
            } else {
                this.state.aspectRatio = null;
            }
        } else {
            const [width, height] = ratio.split(':').map(Number);
            this.state.aspectRatio = width / height;
        }
        
        // ä¿å­˜å½“å‰æ¯”ä¾‹åˆ°localStorage
        localStorage.setItem('lastSelectedRatio', ratio);
        
        // å¦‚æœå·²ç»æœ‰å›¾ç‰‡ï¼Œè°ƒæ•´è£å‰ªæ¡†
        if (this.state.originalImage) {
            this.adjustCropBoxToRatio();
        }
    },



    // ç»˜åˆ¶æ—‹è½¬åçš„å›¾ç‰‡
    drawImage() {
        if (!this.state.originalImage) return;
        
        const ctx = this.state.ctx;
        const canvas = this.state.canvas;
        const img = this.state.originalImage;
        const rotation = this.state.rotation;
        
        // æ¸…ç©ºCanvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ä¿å­˜å½“å‰ç»˜å›¾çŠ¶æ€
        ctx.save();
        
        // 1. å…ˆå°†åŸç‚¹ç§»åˆ°Canvasä¸­å¿ƒ
        ctx.translate(canvas.width / 2, canvas.height / 2);
        
        // 2. åº”ç”¨æ—‹è½¬
        ctx.rotate((rotation * Math.PI) / 180);
        
        // 3. å°†åŸç‚¹ç§»å›å·¦ä¸Šè§’ï¼Œä»¥ä¾¿æ­£ç¡®ç»˜åˆ¶å›¾ç‰‡
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        
        // 4. ç»˜åˆ¶å›¾ç‰‡
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        // æ¢å¤ç»˜å›¾çŠ¶æ€
        ctx.restore();
    },
    
    // åŠ è½½å›¾ç‰‡åˆ°è£å‰ªå™¨
    loadImage(img) {
        this.state.originalImage = img;
        
        // è®¾ç½®Canvaså°ºå¯¸ - æ˜¾ç¤ºå®Œæ•´åŸå›¾ï¼Œä¸é™åˆ¶æœ€å¤§å°ºå¯¸
        let width = img.width;
        let height = img.height;
        
        // åªåœ¨å›¾ç‰‡å°ºå¯¸è¿‡å¤§æ—¶è¿›è¡Œé€‚å½“ç¼©å°ï¼Œç¡®ä¿èƒ½å®Œæ•´æ˜¾ç¤º
        const maxDisplayWidth = 1000;
        const maxDisplayHeight = 800;
        if (width > maxDisplayWidth || height > maxDisplayHeight) {
            const ratio = Math.min(maxDisplayWidth / width, maxDisplayHeight / height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
        }
        
        // è®¾ç½®Canvaså°ºå¯¸ä¸å›¾ç‰‡å°ºå¯¸ç›¸åŒ
        this.state.canvas.width = width;
        this.state.canvas.height = height;
        
        // åˆå§‹åŒ–è£å‰ªæ¡†å®¹å™¨
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.width = `${width}px`;
        canvasContainer.style.height = `${height}px`;
        
        // ä½¿ç”¨åŸå›¾ç‰‡æ¯”ä¾‹ä½œä¸ºé»˜è®¤æ¯”ä¾‹ï¼Œå¿½ç•¥ä¸Šæ¬¡ä¿å­˜çš„æ¯”ä¾‹
        const originalAspectRatio = img.width / img.height;
        this.state.aspectRatio = originalAspectRatio;
        this.state.rotation = this.savedCropState.rotation;
        
        // ä½¿ç”¨å®Œæ•´å›¾ç‰‡å¤§å°ä½œä¸ºé»˜è®¤è£å‰ªæ¡†
        this.state.cropBox = {
            x: 0,
            y: 0,
            width: width,
            height: height
        };
        
        // ç¡®ä¿è£å‰ªæ¡†åœ¨CanvasèŒƒå›´å†…
        if (this.state.cropBox.x < 0) this.state.cropBox.x = 0;
        if (this.state.cropBox.y < 0) this.state.cropBox.y = 0;
        if (this.state.cropBox.x + this.state.cropBox.width > width) {
            this.state.cropBox.width = width - this.state.cropBox.x;
            this.state.cropBox.height = this.state.cropBox.width / originalAspectRatio;
        }
        if (this.state.cropBox.y + this.state.cropBox.height > height) {
            this.state.cropBox.height = height - this.state.cropBox.y;
            this.state.cropBox.width = this.state.cropBox.height * originalAspectRatio;
        }
        
        // è°ƒæ•´è£å‰ªæ¡†ä»¥ç¬¦åˆåŸæ¯”ä¾‹
        this.adjustCropBoxToRatio();
        
        // ç»˜åˆ¶å›¾ç‰‡
        this.drawImage();
        
        this.updateCropBox();
        this.state.isCropping = true;
        
        // æ›´æ–°UI
        this.updateRotationUI();
        
        // ä¼˜å…ˆä½¿ç”¨localStorageä¸­ä¿å­˜çš„ä¸Šæ¬¡é€‰æ‹©çš„æ¯”ä¾‹ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™é€‰ä¸­åŸæ¯”ä¾‹
        const lastRatio = localStorage.getItem('lastSelectedRatio') || 'original';
        this.selectRatioButton(lastRatio);
    },

    // åˆ›å»ºåˆ†å‰²çº¿ï¼ˆä¸‰åˆ†çº¿æˆ–é»„é‡‘æ¯”ä¾‹çº¿ï¼‰
    createGridLines() {
        const cropBox = document.getElementById('crop-box');
        if (!cropBox) return;
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨åˆ†å‰²çº¿å®¹å™¨
        let gridContainer = cropBox.querySelector('#crop-grid');
        if (!gridContainer) {
            // åˆ›å»ºåˆ†å‰²çº¿å®¹å™¨
            gridContainer = document.createElement('div');
            gridContainer.id = 'crop-grid';
            gridContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            `;
            cropBox.appendChild(gridContainer);
        }
        
        // æ¸…ç©ºç°æœ‰çš„åˆ†å‰²çº¿
        gridContainer.innerHTML = '';
        
        // åˆ›å»ºå•æ¡åˆ†å‰²çº¿
        const createGridLine = (isHorizontal) => {
            const line = document.createElement('div');
            line.style.cssText = `
                position: absolute;
                ${isHorizontal ? 'left: 0; right: 0;' : 'top: 0; bottom: 0;'};
                ${isHorizontal ? 'height: 1px;' : 'width: 1px;'}
                background-color: #4CAF50;
                opacity: 1;
                pointer-events: none;
                z-index: 3;
            `;
            gridContainer.appendChild(line);
            return line;
        };
        
        // æ·»åŠ 4æ¡åˆ†å‰²çº¿ï¼š2æ¡æ°´å¹³çº¿ï¼Œ2æ¡å‚ç›´çº¿
        this.state.gridLines = {
            h1: createGridLine(true),
            h2: createGridLine(true),
            v1: createGridLine(false),
            v2: createGridLine(false)
        };
        
        // æ›´æ–°åˆ†å‰²çº¿ä½ç½®
        this.updateCropBox();
    },
    
    // æ˜¾ç¤ºè£å‰ªå™¨
    show() {
        document.getElementById('image-cropper-container').style.display = 'flex';
    },

    // å…³é—­è£å‰ªå™¨
    closeCropper() {
        // ä¿å­˜å½“å‰çš„è£å‰ªçŠ¶æ€
        this.savedCropState = {
            cropBox: { ...this.state.cropBox },
            aspectRatio: this.state.aspectRatio,
            rotation: this.state.rotation
        };
        
        document.getElementById('image-cropper-container').style.display = 'none';
        this.reset();
    },

    // é‡ç½®è£å‰ªå™¨
    reset() {
        this.state = {
            isCropping: false,
            currentImage: null,
            originalImage: null,
            canvas: this.state.canvas,
            ctx: this.state.ctx,
            cropBox: {
                x: 0,
                y: 0,
                width: 200,
                height: 200
            },
            aspectRatio: null,
            rotation: 0,
            isResizing: false,
            resizeHandle: null,
            startX: 0,
            startY: 0,
            startCropBox: { x: 0, y: 0, width: 0, height: 0 },
            isDragging: false
        };
        
        // æ¸…ç©ºCanvas
        if (this.state.ctx) {
            this.state.ctx.clearRect(0, 0, this.state.canvas.width, this.state.canvas.height);
        }
    },

    // å¼€å§‹æ‹–åŠ¨è£å‰ªæ¡†
    startDrag(e) {
        this.state.isDragging = true;
        this.state.startX = e.clientX;
        this.state.startY = e.clientY;
        this.state.startCropBox = { ...this.state.cropBox };
    },

    // åœæ­¢æ‹–åŠ¨
    stopDrag() {
        this.state.isDragging = false;
    },

    // å¼€å§‹è°ƒæ•´å¤§å°
    startResize(e) {
        this.state.isResizing = true;
        this.state.resizeHandle = e.target.dataset.handle;
        this.state.startX = e.clientX;
        this.state.startY = e.clientY;
        this.state.startCropBox = { ...this.state.cropBox };
    },

    // åœæ­¢è°ƒæ•´å¤§å°
    stopResize() {
        this.state.isResizing = false;
    },

    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
    onMouseMove(e) {
        if (this.state.isDragging) {
            this.dragCropBox(e);
        } else if (this.state.isResizing) {
            this.resizeCropBox(e);
        }
    },

    // æ‹–åŠ¨è£å‰ªæ¡†
    dragCropBox(e) {
        const deltaX = e.clientX - this.state.startX;
        const deltaY = e.clientY - this.state.startY;
        
        const newX = this.state.startCropBox.x + deltaX;
        const newY = this.state.startCropBox.y + deltaY;
        
        // é™åˆ¶è£å‰ªæ¡†åœ¨Canvaså†…
        this.state.cropBox.x = Math.max(0, Math.min(newX, this.state.canvas.width - this.state.cropBox.width));
        this.state.cropBox.y = Math.max(0, Math.min(newY, this.state.canvas.height - this.state.cropBox.height));
        
        this.updateCropBox();
    },

    // è°ƒæ•´è£å‰ªæ¡†å¤§å°
    resizeCropBox(e) {
        const deltaX = e.clientX - this.state.startX;
        const deltaY = e.clientY - this.state.startY;
        
        let { x, y, width, height } = this.state.startCropBox;
        
        // æ ¹æ®è°ƒæ•´æ‰‹æŸ„è°ƒæ•´å¤§å°
        switch (this.state.resizeHandle) {
            case 'nw':
                width = Math.max(20, this.state.startCropBox.width - deltaX);
                height = Math.max(20, this.state.startCropBox.height - deltaY);
                x = this.state.startCropBox.x + (this.state.startCropBox.width - width);
                y = this.state.startCropBox.y + (this.state.startCropBox.height - height);
                break;
            case 'n':
                height = Math.max(20, this.state.startCropBox.height - deltaY);
                y = this.state.startCropBox.y + (this.state.startCropBox.height - height);
                break;
            case 'ne':
                width = Math.max(20, this.state.startCropBox.width + deltaX);
                height = Math.max(20, this.state.startCropBox.height - deltaY);
                y = this.state.startCropBox.y + (this.state.startCropBox.height - height);
                break;
            case 'e':
                width = Math.max(20, this.state.startCropBox.width + deltaX);
                break;
            case 'se':
                width = Math.max(20, this.state.startCropBox.width + deltaX);
                height = Math.max(20, this.state.startCropBox.height + deltaY);
                break;
            case 's':
                height = Math.max(20, this.state.startCropBox.height + deltaY);
                break;
            case 'sw':
                width = Math.max(20, this.state.startCropBox.width - deltaX);
                height = Math.max(20, this.state.startCropBox.height + deltaY);
                x = this.state.startCropBox.x + (this.state.startCropBox.width - width);
                break;
            case 'w':
                width = Math.max(20, this.state.startCropBox.width - deltaX);
                x = this.state.startCropBox.x + (this.state.startCropBox.width - width);
                break;
        }
        
        // å¦‚æœæœ‰æ¯”ä¾‹é™åˆ¶ï¼Œè°ƒæ•´å°ºå¯¸
        if (this.state.aspectRatio) {
            if (['nw', 'n', 'ne', 'sw', 's', 'se'].includes(this.state.resizeHandle)) {
                // å‚ç›´æ–¹å‘è°ƒæ•´ï¼Œä¿æŒå®½åº¦
                height = width / this.state.aspectRatio;
            } else {
                // æ°´å¹³æ–¹å‘è°ƒæ•´ï¼Œä¿æŒé«˜åº¦
                width = height * this.state.aspectRatio;
            }
        }
        
        // é™åˆ¶è£å‰ªæ¡†åœ¨Canvaså†…
        if (x < 0) {
            x = 0;
            width = this.state.startCropBox.width + this.state.startCropBox.x;
            if (this.state.aspectRatio) {
                height = width / this.state.aspectRatio;
            }
        }
        
        if (y < 0) {
            y = 0;
            height = this.state.startCropBox.height + this.state.startCropBox.y;
            if (this.state.aspectRatio) {
                width = height * this.state.aspectRatio;
            }
        }
        
        if (x + width > this.state.canvas.width) {
            width = this.state.canvas.width - x;
            if (this.state.aspectRatio) {
                height = width / this.state.aspectRatio;
            }
        }
        
        if (y + height > this.state.canvas.height) {
            height = this.state.canvas.height - y;
            if (this.state.aspectRatio) {
                width = height * this.state.aspectRatio;
            }
        }
        
        // æ›´æ–°è£å‰ªæ¡†
        this.state.cropBox = {
            x: Math.round(x),
            y: Math.round(y),
            width: Math.round(width),
            height: Math.round(height)
        };
        
        this.updateCropBox();
    },

    // è°ƒæ•´è£å‰ªæ¡†ä»¥ç¬¦åˆå½“å‰æ¯”ä¾‹
    adjustCropBoxToRatio() {
        if (!this.state.aspectRatio) return;
        
        // ä¿å­˜å½“å‰è£å‰ªæ¡†çš„ä¸­å¿ƒä½ç½®
        const centerX = this.state.cropBox.x + this.state.cropBox.width / 2;
        const centerY = this.state.cropBox.y + this.state.cropBox.height / 2;
        
        // è®¡ç®—å½“å‰è£å‰ªæ¡†çš„é¢ç§¯
        const currentArea = this.state.cropBox.width * this.state.cropBox.height;
        
        // åŸºäºå½“å‰é¢ç§¯å’Œç›®æ ‡æ¯”ä¾‹è®¡ç®—æ–°çš„å®½é«˜ï¼Œä¿æŒé¢ç§¯ä¸å˜
        let newWidth, newHeight;
        if (this.state.aspectRatio > 1) {
            // å®½å±æ¯”ä¾‹ï¼Œä»¥å®½åº¦ä¸ºåŸºå‡†
            newWidth = Math.sqrt(currentArea * this.state.aspectRatio);
            newHeight = newWidth / this.state.aspectRatio;
        } else {
            // ç«–å±æˆ–æ­£æ–¹å½¢æ¯”ä¾‹ï¼Œä»¥é«˜åº¦ä¸ºåŸºå‡†
            newHeight = Math.sqrt(currentArea / this.state.aspectRatio);
            newWidth = newHeight * this.state.aspectRatio;
        }
        
        // ç¡®ä¿æ–°å°ºå¯¸ä¸è¶…è¿‡Canvaså¤§å°
        const maxWidth = this.state.canvas.width;
        const maxHeight = this.state.canvas.height;
        
        // å¦‚æœè®¡ç®—å‡ºçš„å°ºå¯¸è¶…è¿‡Canvasï¼ŒæŒ‰æ¯”ä¾‹ç¼©å°
        const scaleFactor = Math.min(maxWidth / newWidth, maxHeight / newHeight);
        newWidth = Math.round(newWidth * scaleFactor);
        newHeight = Math.round(newHeight * scaleFactor);
        
        // è®¡ç®—æ–°çš„ä½ç½®ï¼Œä¿æŒä¸­å¿ƒä¸å˜
        this.state.cropBox.x = Math.round(centerX - newWidth / 2);
        this.state.cropBox.y = Math.round(centerY - newHeight / 2);
        this.state.cropBox.width = newWidth;
        this.state.cropBox.height = newHeight;
        
        // ç¡®ä¿è£å‰ªæ¡†åœ¨Canvaså†…
        if (this.state.cropBox.x < 0) this.state.cropBox.x = 0;
        if (this.state.cropBox.y < 0) this.state.cropBox.y = 0;
        if (this.state.cropBox.x + this.state.cropBox.width > maxWidth) {
            this.state.cropBox.x = maxWidth - this.state.cropBox.width;
        }
        if (this.state.cropBox.y + this.state.cropBox.height > maxHeight) {
            this.state.cropBox.y = maxHeight - this.state.cropBox.height;
        }
        
        this.updateCropBox();
    },

    // æ›´æ–°è£å‰ªæ¡†UI
    updateCropBox() {
        const cropBox = document.getElementById('crop-box');
        const mask = document.getElementById('crop-mask');
        const { x, y, width, height } = this.state.cropBox;
        
        cropBox.style.left = `${x}px`;
        cropBox.style.top = `${y}px`;
        cropBox.style.width = `${width}px`;
        cropBox.style.height = `${height}px`;
        
        // æ›´æ–°é®ç½©å±‚ï¼Œå®ç°éè£å‰ªåŒºåŸŸå˜æš—æ•ˆæœ
        // ä½¿ç”¨å››ä¸ªdivç»„åˆå®ç°é®ç½©å±‚
        const canvasContainer = document.getElementById('canvas-container');
        const containerWidth = parseInt(canvasContainer.style.width);
        const containerHeight = parseInt(canvasContainer.style.height);
        
        // æ¸…ç©ºç°æœ‰é®ç½©å­å…ƒç´ 
        mask.innerHTML = '';
        
        // åˆ›å»ºå››ä¸ªé®ç½©åŒºåŸŸï¼šä¸Šã€å³ã€ä¸‹ã€å·¦
        const maskStyle = `
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: 1;
        `;
        
        // ä¸Šé®ç½©
        const topMask = document.createElement('div');
        topMask.style.cssText = `${maskStyle}
            top: 0;
            left: 0;
            width: ${containerWidth}px;
            height: ${y}px;
        `;
        mask.appendChild(topMask);
        
        // å³é®ç½©
        const rightMask = document.createElement('div');
        rightMask.style.cssText = `${maskStyle}
            top: ${y}px;
            left: ${x + width}px;
            width: ${containerWidth - (x + width)}px;
            height: ${height}px;
        `;
        mask.appendChild(rightMask);
        
        // ä¸‹é®ç½©
        const bottomMask = document.createElement('div');
        bottomMask.style.cssText = `${maskStyle}
            top: ${y + height}px;
            left: 0;
            width: ${containerWidth}px;
            height: ${containerHeight - (y + height)}px;
        `;
        mask.appendChild(bottomMask);
        
        // å·¦é®ç½©
        const leftMask = document.createElement('div');
        leftMask.style.cssText = `${maskStyle}
            top: ${y}px;
            left: 0;
            width: ${x}px;
            height: ${height}px;
        `;
        mask.appendChild(leftMask);
        
        // æ›´æ–°è°ƒæ•´æ‰‹æŸ„ä½ç½®
        this.updateResizeHandles();
        
        // æ›´æ–°åˆ†å‰²çº¿ä½ç½®
        this.updateGridLines();
    },
    
    // æ›´æ–°åˆ†å‰²çº¿ä½ç½®
    updateGridLines() {
        if (!this.state.gridLines) {
            this.createGridLines();
            return;
        }
        
        const { h1, h2, v1, v2 } = this.state.gridLines;
        
        if (this.state.gridType === 'thirds') {
            // ä¸‰åˆ†çº¿ä½ç½®ï¼š1/3å’Œ2/3
            h1.style.top = '33.33%';
            h2.style.top = '66.66%';
            v1.style.left = '33.33%';
            v2.style.left = '66.66%';
        } else if (this.state.gridType === 'golden') {
            // é»„é‡‘æ¯”ä¾‹ï¼šçº¦0.382å’Œ0.618
            const goldenRatio = 0.381966;
            h1.style.top = `${goldenRatio * 100}%`;
            h2.style.top = `${(1 - goldenRatio) * 100}%`;
            v1.style.left = `${goldenRatio * 100}%`;
            v2.style.left = `${(1 - goldenRatio) * 100}%`;
        }
    },

    // æ›´æ–°è°ƒæ•´æ‰‹æŸ„ä½ç½®
    updateResizeHandles() {
        document.querySelectorAll('.resize-handle').forEach(handle => {
            const handleType = handle.dataset.handle;
            let left = 0;
            let top = 0;
            
            // è®¡ç®—æ‰‹æŸ„çš„åç§»é‡ï¼Œç¡®ä¿å®ƒä»¬å‡†ç¡®åœ°ä½äºè£å‰ªæ¡†çš„é¡¶ç‚¹å’Œè¾¹ç¼˜ä¸­å¿ƒ
            const offset = -6; // æ‰‹æŸ„å®½åº¦çš„ä¸€åŠï¼Œç”¨äºå±…ä¸­å®šä½
            
            switch (handleType) {
                case 'nw':
                    left = `${offset}px`;
                    top = `${offset}px`;
                    break;
                case 'n':
                    left = '50%';
                    top = `${offset}px`;
                    handle.style.transform = 'translateX(-50%)';
                    break;
                case 'ne':
                    left = '100%';
                    top = `${offset}px`;
                    handle.style.transform = 'translateX(-100%)';
                    break;
                case 'e':
                    left = '100%';
                    top = '50%';
                    handle.style.transform = 'translateX(-100%) translateY(-50%)';
                    break;
                case 'se':
                    left = '100%';
                    top = '100%';
                    handle.style.transform = 'translateX(-100%) translateY(-100%)';
                    break;
                case 's':
                    left = '50%';
                    top = '100%';
                    handle.style.transform = 'translateX(-50%) translateY(-100%)';
                    break;
                case 'sw':
                    left = `${offset}px`;
                    top = '100%';
                    handle.style.transform = 'translateY(-100%)';
                    break;
                case 'w':
                    left = `${offset}px`;
                    top = '50%';
                    handle.style.transform = 'translateY(-50%)';
                    break;
            }
            
            handle.style.left = left;
            handle.style.top = top;
        });
    },

    // è·å–é¼ æ ‡æ ·å¼
    getCursorStyle(handle) {
        const cursorMap = {
            'nw': 'nwse-resize',
            'n': 'ns-resize',
            'ne': 'nesw-resize',
            'e': 'ew-resize',
            'se': 'nwse-resize',
            's': 'ns-resize',
            'sw': 'nesw-resize',
            'w': 'ew-resize'
        };
        return cursorMap[handle] || 'move';
    },

    // æ›´æ–°æ—‹è½¬UI
    updateRotationUI() {
        const rotationValue = document.getElementById('crop-rotation-value');
        const rotationSlider = document.getElementById('crop-rotation-slider');
        if (rotationValue && rotationSlider) {
            rotationValue.textContent = `${this.state.rotation}Â°`;
            rotationSlider.value = this.state.rotation;
        }
    },


    
    // è®¾ç½®æ—‹è½¬è§’åº¦
    setRotation(rotation) {
        this.state.rotation = rotation;
        this.drawImage();
        this.updateRotationUI();
    },
    
    // æ‰§è¡Œè£å‰ª
    executeCrop() {
        if (!this.state.originalImage || !this.state.isCropping) {
            alert('è¯·å…ˆåŠ è½½å›¾ç‰‡');
            return;
        }
        
        try {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶Canvasæ¥ç»˜åˆ¶æ—‹è½¬åçš„å®Œæ•´å›¾ç‰‡
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // è®¾ç½®ä¸´æ—¶Canvaså°ºå¯¸ä¸åŸå§‹å›¾ç‰‡ç›¸åŒ
            tempCanvas.width = this.state.originalImage.width;
            tempCanvas.height = this.state.originalImage.height;
            
            // ä¿å­˜ä¸´æ—¶Canvasçš„ç»˜å›¾çŠ¶æ€
            tempCtx.save();
            
            // å°†ä¸´æ—¶Canvasçš„åŸç‚¹ç§»åˆ°ä¸­å¿ƒ
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            
            // åº”ç”¨æ—‹è½¬
            if (this.state.rotation !== 0) {
                tempCtx.rotate((this.state.rotation * Math.PI) / 180);
            }
            
            // å°†åŸç‚¹ç§»å›å·¦ä¸Šè§’ï¼Œå¹¶ç»˜åˆ¶åŸå§‹å›¾ç‰‡ï¼ˆæ­¤æ—¶å›¾ç‰‡å·²ç»æ—‹è½¬ï¼‰
            tempCtx.translate(-tempCanvas.width / 2, -tempCanvas.height / 2);
            tempCtx.drawImage(this.state.originalImage, 0, 0);
            
            // æ¢å¤ä¸´æ—¶Canvasçš„ç»˜å›¾çŠ¶æ€
            tempCtx.restore();
            
            // è®¡ç®—å®é™…è£å‰ªåŒºåŸŸï¼ˆç›¸å¯¹äºæ˜¾ç¤ºçš„Canvasï¼Œéœ€è¦è½¬æ¢ä¸ºåŸå§‹å›¾ç‰‡å°ºå¯¸ï¼‰
            const scaleX = this.state.originalImage.width / this.state.canvas.width;
            const scaleY = this.state.originalImage.height / this.state.canvas.height;
            
            const actualX = this.state.cropBox.x * scaleX;
            const actualY = this.state.cropBox.y * scaleY;
            const actualWidth = this.state.cropBox.width * scaleX;
            const actualHeight = this.state.cropBox.height * scaleY;
            
            // åˆ›å»ºè£å‰ªç»“æœCanvasï¼Œä½¿ç”¨åŸå§‹å›¾ç‰‡å®é™…è£å‰ªåŒºåŸŸçš„å°ºå¯¸ï¼Œè€Œä¸æ˜¯æ˜¾ç¤ºå°ºå¯¸
            const resultCanvas = document.createElement('canvas');
            const resultCtx = resultCanvas.getContext('2d');
            
            // è®¾ç½®ç»“æœCanvaså°ºå¯¸ä¸ºå®é™…è£å‰ªåŒºåŸŸçš„å°ºå¯¸ï¼ˆä¿æŒåŸå§‹åˆ†è¾¨ç‡ï¼‰
            resultCanvas.width = Math.round(actualWidth);
            resultCanvas.height = Math.round(actualHeight);
            
            // ä»ä¸´æ—¶Canvasï¼ˆå·²ç»˜åˆ¶æ—‹è½¬åçš„å®Œæ•´å›¾ç‰‡ï¼‰ä¸­è£å‰ªå‡ºæŒ‡å®šåŒºåŸŸ
            // ç›´æ¥ä½¿ç”¨å®é™…å°ºå¯¸ï¼Œä¸è¿›è¡Œæ‹‰ä¼¸ï¼Œä¿æŒåŸå§‹åˆ†è¾¨ç‡
            resultCtx.drawImage(
                tempCanvas,
                actualX, actualY, actualWidth, actualHeight,
                0, 0, resultCanvas.width, resultCanvas.height
            );
            
            this.state.currentImage = resultCanvas;
            return resultCanvas;
        } catch (error) {
            console.error('è£å‰ªå¤±è´¥:', error);
            alert('è£å‰ªå¤±è´¥ï¼Œè¯·é‡è¯•');
            return null;
        }
    },



    // ä¿å­˜è£å‰ªç»“æœå¹¶æ›´æ–°å½“å‰é€‰ä¸­çš„å›¾ç‰‡
    saveResult() {
        const resultCanvas = this.state.currentImage || this.executeCrop();
        if (!resultCanvas) return;
        
        try {
            const imageData = resultCanvas.toDataURL('image/png');
            
            // æ›´æ–°å½“å‰é€‰ä¸­çš„å›¾ç‰‡
            if (window.imageHandler && window.imageHandler.currentSelectedImage) {
                const selectedImage = window.imageHandler.currentSelectedImage;
                const imgElement = document.getElementById(`image-${selectedImage.id}`);
                
                if (imgElement) {
                    // æ›´æ–°å›¾ç‰‡æº
                    const img = imgElement.querySelector('img');
                    if (img) {
                        img.src = imageData;
                    }
                    
                    // æ›´æ–°å›¾ç‰‡å°ºå¯¸ï¼Œç¡®ä¿å¤–éƒ¨æ¡†è·Ÿéšå›¾ç‰‡è£å‰ªè€Œæ”¹å˜
                    const croppedWidth = resultCanvas.width;
                    const croppedHeight = resultCanvas.height;
                    
                    // ä¿æŒDOMå…ƒç´ å°ºå¯¸ä¸å˜ï¼Œç¡®ä¿è£å‰ªåå›¾ç‰‡æ˜¾ç¤ºå¤§å°ä¸è£å‰ªå‰ä¸€è‡´
                    // imgElement.style.width å’Œ imgElement.style.height ä¿æŒä¸å˜
                    
                    // ä¿å­˜åŸæœ‰çš„æ—‹è½¬ã€ç¿»è½¬çŠ¶æ€
                    const originalRotation = selectedImage.rotation;
                    const originalFlipHorizontal = selectedImage.flipHorizontal;
                    const originalFlipVertical = selectedImage.flipVertical;
                    
                    // æ›´æ–°å›¾ç‰‡æ•°æ®ï¼Œä¿ç•™åŸæœ‰æ—‹è½¬ã€ç¿»è½¬çŠ¶æ€
                    selectedImage.src = imageData;
                    selectedImage.originalWidth = croppedWidth; // è®¾ç½®æ–°çš„åŸå§‹å®½åº¦ä¸ºè£å‰ªåçš„å®½åº¦
                    selectedImage.originalHeight = croppedHeight; // è®¾ç½®æ–°çš„åŸå§‹é«˜åº¦ä¸ºè£å‰ªåçš„é«˜åº¦
                    
                    // ä¿æŒæ˜¾ç¤ºå°ºå¯¸ä¸å˜ï¼Œç¡®ä¿è£å‰ªåå›¾ç‰‡å¤§å°ä¸è£å‰ªå‰ä¸€è‡´
                    // è¿™æ ·ç”¨æˆ·çœ‹åˆ°çš„å›¾ç‰‡å¤§å°ä¸ä¼šå› ä¸ºè£å‰ªè€Œæ”¹å˜
                    // selectedImage.width å’Œ selectedImage.height ä¿æŒä¸å˜
                    
                    selectedImage.rotation = originalRotation; // ä¿ç•™åŸæœ‰æ—‹è½¬è§’åº¦
                    selectedImage.flipHorizontal = originalFlipHorizontal; // ä¿ç•™åŸæœ‰æ°´å¹³ç¿»è½¬çŠ¶æ€
                    selectedImage.flipVertical = originalFlipVertical; // ä¿ç•™åŸæœ‰å‚ç›´ç¿»è½¬çŠ¶æ€
                    selectedImage.updatedAt = new Date().toISOString();
                    
                    // æ›´æ–°DOMå…ƒç´ çš„å°ºå¯¸å’Œæ—‹è½¬çŠ¶æ€
                    imgElement.style.width = `${selectedImage.width}px`;
                    imgElement.style.height = `${selectedImage.height}px`;
                    imgElement.style.transform = `translate(${selectedImage.x}px, ${selectedImage.y}px) rotate(${originalRotation}deg)`;
                    
                    // æ›´æ–°å›¾ç‰‡çš„ç¿»è½¬çŠ¶æ€
                    const innerImg = imgElement.querySelector('img');
                    if (innerImg) {
                        let transform = '';
                        if (originalFlipHorizontal) {
                            transform += ' scaleX(-1)';
                        }
                        if (originalFlipVertical) {
                            transform += ' scaleY(-1)';
                        }
                        innerImg.style.transform = transform;
                    }
                    
                    // ä¿å­˜æ›´æ–°
                    window.imageHandler.saveImages();
                    
                    // å…³é—­è£å‰ªå™¨
                    this.closeCropper();
                }
            } else {
                // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„å›¾ç‰‡ï¼Œä»ç„¶æä¾›ä¸‹è½½é€‰é¡¹
                const link = document.createElement('a');
                link.download = `cropped_image_${Date.now()}.png`;
                link.href = imageData;
                link.click();
                
                // å…³é—­è£å‰ªå™¨
                this.closeCropper();
            }
        } catch (error) {
            console.error('ä¿å­˜å¤±è´¥:', error);
            alert('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    },
};

// åˆå§‹åŒ–å›¾ç‰‡è£å‰ªæ¨¡å—
window.addEventListener('load', () => {
    imageCropper.init();
});


// å›¾ç‰‡è°ƒè‰²åŠŸèƒ½æ¨¡å—
const imageColorAdjuster = window.imageColorAdjuster = {
    // è°ƒè‰²çŠ¶æ€
    state: {
        isAdjusting: false,
        currentImage: null,
        originalImage: null, // å½“å‰æ˜¾ç¤ºå›¾ç‰‡çš„å‰¯æœ¬ï¼Œç”¨äºæ¢å¤
        currentDisplayImage: null, // å½“å‰æ˜¾ç¤ºçš„å›¾ç‰‡
        canvas: null,
        ctx: null,
        compareCanvas: null,
        compareCtx: null,
        
        // è‰²å½©ç»„å‚æ•° (é»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100)
        colorEffects: {
            temperature: 0,     // è‰²æ¸©
            tint: 0,            // è‰²è°ƒ
            saturation: 0,      // é¥±å’Œåº¦
            naturalSaturation: 0 // è‡ªç„¶é¥±å’Œåº¦
        },
        
        // æ˜åº¦ç»„å‚æ•° (é»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100)
        lightEffects: {
            brightness: 0,     // äº®åº¦
            contrast: 0,       // å¯¹æ¯”åº¦
            highlight: 0,      // é«˜å…‰
            shadow: 0,         // é˜´å½±
            white: 0,          // ç™½è‰²
            black: 0,          // é»‘è‰²
            lightSense: 0      // å…‰æ„Ÿ
        },
        
        // æ•ˆæœç»„å‚æ•° (é»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100)
        effectEffects: {
            sharpen: 0,        // é”åŒ–
            clarity: 0,        // æ¸…æ™°
            grain: 0,          // é¢—ç²’
            fade: 0,           // è¤ªè‰²
            vignette: 0        // æš—è§’
        },
        
        // HSLç»„å‚æ•° (é»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100)
        hslEffects: {
            hue: 0,            // è‰²ç›¸
            saturation: 0,     // é¥±å’Œåº¦
            lightness: 0       // äº®åº¦
        },
        
        // æ›²çº¿ç»„å‚æ•° (RGBæ›²çº¿è°ƒæ•´)
        curveEffects: {
            rgbCurve: {
                red: Array(256).fill(0).map((_, i) => i), // çº¢è‰²é€šé“æ›²çº¿
                green: Array(256).fill(0).map((_, i) => i), // ç»¿è‰²é€šé“æ›²çº¿
                blue: Array(256).fill(0).map((_, i) => i), // è“è‰²é€šé“æ›²çº¿
                luminance: Array(256).fill(0).map((_, i) => i) // äº®åº¦æ›²çº¿
            }
        },
        
        // è‰²è½®ç»„å‚æ•° (é»˜è®¤å€¼ä¸º0ï¼ŒèŒƒå›´-100åˆ°100)
        colorWheelEffects: {
            shadows: 0,        // æš—éƒ¨
            midtones: 0,       // ä¸­ç°
            faces: 0,          // è„¸éƒ¨
            offset: 0          // åç§»
        },
        
        // è’™ç‰ˆç»„å‚æ•°
        maskEffects: {
            type: 'none',      // è’™ç‰ˆç±»å‹: none, linear, mirror, circle, rect, text
            invert: false,     // åé€‰åŠŸèƒ½
            feather: 0,        // ç¾½åŒ–åŠŸèƒ½ (0-100)
            // å„ç§è’™ç‰ˆçš„å…·ä½“å‚æ•°
            params: {
                // çº¿æ€§è’™ç‰ˆå‚æ•°
                linear: {
                    angle: 0,    // è§’åº¦
                    position: 50 // ä½ç½® (0-100)
                },
                // åœ†å½¢è’™ç‰ˆå‚æ•°
                circle: {
                    x: 50,       // ä¸­å¿ƒX (0-100)
                    y: 50,       // ä¸­å¿ƒY (0-100)
                    radius: 50   // åŠå¾„ (0-100)
                },
                // çŸ©å½¢è’™ç‰ˆå‚æ•°
                rect: {
                    x: 25,       // å·¦ä¸Šè§’X (0-100)
                    y: 25,       // å·¦ä¸Šè§’Y (0-100)
                    width: 50,    // å®½åº¦ (0-100)
                    height: 50    // é«˜åº¦ (0-100)
                },
                // æ–‡å­—è’™ç‰ˆå‚æ•°
                text: {
                    content: '',  // æ–‡å­—å†…å®¹
                    fontSize: 24, // å­—ä½“å¤§å°
                    fontFamily: 'Arial', // å­—ä½“
                    fontWeight: 'normal', // å­—é‡
                    color: '#ffffff' // æ–‡å­—é¢œè‰²
                }
            }
        },
        
        // æŠ˜å é¢æ¿çŠ¶æ€
        collapsedGroups: {
            colorEffects: false,
            lightEffects: false,
            effectEffects: false,
            hslEffects: false,
            curveEffects: false,
            colorWheelEffects: false,
            maskEffects: false
        },
        
        // ä¿å­˜åŸå§‹å‚æ•°ï¼Œç”¨äºæ¢å¤
        originalParams: {
            // è‰²å½©ç»„
            temperature: 0,
            tint: 0,
            saturation: 0,
            naturalSaturation: 0,
            // æ˜åº¦ç»„
            brightness: 0,
            contrast: 0,
            highlight: 0,
            shadow: 0,
            white: 0,
            black: 0,
            lightSense: 0,
            // æ•ˆæœç»„
            sharpen: 0,
            clarity: 0,
            grain: 0,
            fade: 0,
            vignette: 0,
            // HSLç»„
            hue: 0,
            hslSaturation: 0,
            hslLightness: 0,
            // è‰²è½®ç»„
            shadows: 0,
            midtones: 0,
            faces: 0,
            offset: 0,
            // è’™ç‰ˆç»„
            maskType: 'none',
            maskInvert: false,
            maskFeather: 0
        }
    },
    
    // åˆå§‹åŒ–è°ƒè‰²åŠŸèƒ½
    init() {
        this.setupCanvas();
        this.setupEventListeners();
    },
    
    // è®¾ç½®Canvas
    setupCanvas() {
        // åˆ›å»ºè°ƒè‰²å®¹å™¨
        const container = document.createElement('div');
        container.id = 'image-color-adjuster-container';
        container.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        `;
        
        // åˆ›å»ºè°ƒè‰²é¢æ¿
        const panel = document.createElement('div');
        panel.id = 'image-color-panel';
        panel.style.cssText = `
            background: #222;
            padding: 20px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            color: #fff;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        `;
        
        // å·¦ä¾§ï¼šå›¾ç‰‡é¢„è§ˆåŒºåŸŸ
        const previewSection = document.createElement('div');
        previewSection.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        `;
        
        // åˆ›å»ºå¯¹æ¯”å›¾å®¹å™¨
        const compareContainer = document.createElement('div');
        compareContainer.id = 'color-compare-container';
        compareContainer.style.cssText = `
            position: relative;
            border: 2px solid #444;
            background: transparent;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
            max-width: 800px;
            max-height: 500px;
            display: flex;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
        `;
        
        // åˆ›å»ºåŸå›¾é¢„è§ˆå®¹å™¨
        const originalPreview = document.createElement('div');
        originalPreview.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        `;
        
        const originalTitle = document.createElement('div');
        originalTitle.textContent = 'åŸå›¾';
        originalTitle.style.cssText = `
            font-weight: bold;
            color: #2196F3;
            font-size: 14px;
        `;
        
        // åˆ›å»ºåŸå›¾Canvas
        const originalCanvas = document.createElement('canvas');
        originalCanvas.id = 'color-original-canvas';
        originalCanvas.style.cssText = `
            display: block;
            border-radius: 6px;
            max-width: 100%;
            max-height: 450px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // åˆ›å»ºä¿®å›¾é¢„è§ˆå®¹å™¨
        const editedPreview = document.createElement('div');
        editedPreview.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        `;
        
        const editedTitle = document.createElement('div');
        editedTitle.textContent = 'è°ƒè‰²';
        editedTitle.style.cssText = `
            font-weight: bold;
            color: #4CAF50;
            font-size: 14px;
        `;
        
        // åˆ›å»ºä¿®å›¾Canvas
        const editedCanvas = document.createElement('canvas');
        editedCanvas.id = 'color-edited-canvas';
        editedCanvas.style.cssText = `
            display: block;
            border-radius: 6px;
            max-width: 100%;
            max-height: 450px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // æŒ‰é’®åŒºåŸŸ
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 50px;
            margin-top: 10px;
        `;
        
        // åˆ›å»ºé‡ç½®å‚æ•°æŒ‰é’®
        const resetBtn = document.createElement('button');
        resetBtn.id = 'reset-color-adjustments';
        resetBtn.textContent = 'é‡ç½®å‚æ•°';
        resetBtn.style.cssText = `
            padding: 10px 20px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        `;
        
        // åˆ›å»ºå¯¼å‡ºå‚æ•°æŒ‰é’®
        const exportBtn = document.createElement('button');
        exportBtn.id = 'export-color-params';
        exportBtn.textContent = 'å¯¼å‡ºå‚æ•°';
        exportBtn.style.cssText = `
            padding: 10px 20px;
            background: linear-gradient(135deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        `;
        
        // å¯¼å‡ºå‚æ•°æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        exportBtn.addEventListener('click', () => {
            this.exportColorParams();
        });
        
        // åˆ›å»ºå¯¼å…¥å‚æ•°æŒ‰é’®
        const importBtn = document.createElement('button');
        importBtn.id = 'import-color-params';
        importBtn.textContent = 'å¯¼å…¥å‚æ•°';
        importBtn.style.cssText = `
            padding: 10px 20px;
            background: linear-gradient(135deg, #FF9800, #F57C00);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        `;
        
        // åˆ›å»ºéšè—çš„æ–‡ä»¶è¾“å…¥
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.id = 'color-params-file';
        fileInput.accept = '.txt';
        fileInput.style.cssText = 'display: none;';
        
        // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
        fileInput.addEventListener('change', (e) => {
            this.importColorParams(e);
        });
        
        // å¯¼å…¥å‚æ•°æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        // åˆ›å»ºåº”ç”¨è°ƒè‰²æŒ‰é’®
        const applyBtn = document.createElement('button');
        applyBtn.id = 'apply-color-adjustments';
        applyBtn.textContent = 'åº”ç”¨è°ƒè‰²';
        applyBtn.style.cssText = `
            padding: 10px 20px;
            background: linear-gradient(135deg, #FFC107, #FFA000);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        `;
        
        // åº”ç”¨è°ƒè‰²æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        applyBtn.addEventListener('click', () => {
            this.saveAndHide(true);
        });
        

        
        // å³ä¾§ï¼šå‚æ•°è°ƒæ•´åŒºåŸŸ
        const paramsSection = document.createElement('div');
        paramsSection.style.cssText = `
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        // åˆ›å»ºæ ‡ç­¾é¡µå®¹å™¨
        const tabContainer = document.createElement('div');
        tabContainer.style.cssText = `
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
            height: 500px;
        `;
        
        // æ ‡ç­¾é¡µå¯¼èˆªï¼ˆå·¦ä¾§æ¨ªå‘ï¼‰
        const tabNav = document.createElement('div');
        tabNav.id = 'color-tabs-nav';
        tabNav.style.cssText = `
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            width: 80px;
        `;
        
        // æ ‡ç­¾é¡µå†…å®¹åŒºåŸŸ
        const tabContent = document.createElement('div');
        tabContent.style.cssText = `
            flex: 1;
            position: relative;
            overflow: hidden;
        `;
        
        // å®šä¹‰æ ‡ç­¾é¡µæ•°æ®
        const tabs = [
            {
                id: 'color-effects-tab',
                name: 'è‰²å½©ç»„',
                color: 'linear-gradient(135deg, #FF5722, #E64A19)',
                params: [
                    { key: 'temperature', name: 'è‰²æ¸©', valueColor: '#FFCCBC' },
                    { key: 'tint', name: 'è‰²è°ƒ', valueColor: '#FFCCBC' },
                    { key: 'saturation', name: 'é¥±å’Œåº¦', valueColor: '#FFCCBC' },
                    { key: 'naturalSaturation', name: 'è‡ªç„¶é¥±å’Œåº¦', valueColor: '#FFCCBC' }
                ]
            },
            {
                id: 'light-effects-tab',
                name: 'æ˜åº¦ç»„',
                color: 'linear-gradient(135deg, #2196F3, #1976D2)',
                params: [
                    { key: 'brightness', name: 'äº®åº¦', valueColor: '#BBDEFB' },
                    { key: 'contrast', name: 'å¯¹æ¯”åº¦', valueColor: '#BBDEFB' },
                    { key: 'highlight', name: 'é«˜å…‰', valueColor: '#BBDEFB' },
                    { key: 'shadow', name: 'é˜´å½±', valueColor: '#BBDEFB' },
                    { key: 'white', name: 'ç™½è‰²', valueColor: '#BBDEFB' },
                    { key: 'black', name: 'é»‘è‰²', valueColor: '#BBDEFB' },
                    { key: 'lightSense', name: 'å…‰æ„Ÿ', valueColor: '#BBDEFB' }
                ]
            },
            {
                id: 'effect-effects-tab',
                name: 'æ•ˆæœç»„',
                color: 'linear-gradient(135deg, #4CAF50, #388E3C)',
                params: [
                    { key: 'sharpen', name: 'é”åŒ–', valueColor: '#C8E6C9' },
                    { key: 'clarity', name: 'æ¸…æ™°', valueColor: '#C8E6C9' },
                    { key: 'grain', name: 'é¢—ç²’', valueColor: '#C8E6C9' },
                    { key: 'fade', name: 'è¤ªè‰²', valueColor: '#C8E6C9' },
                    { key: 'vignette', name: 'æš—è§’', valueColor: '#C8E6C9' }
                ]
            },
            {
                id: 'hsl-effects-tab',
                name: 'HSLç»„',
                color: 'linear-gradient(135deg, #9C27B0, #7B1FA2)',
                params: [
                    { key: 'hue', name: 'è‰²ç›¸', valueColor: '#E1BEE7' },
                    { key: 'saturation', name: 'é¥±å’Œåº¦', valueColor: '#E1BEE7' },
                    { key: 'lightness', name: 'äº®åº¦', valueColor: '#E1BEE7' }
                ]
            },
            {
                id: 'curve-effects-tab',
                name: 'æ›²çº¿ç»„',
                color: 'linear-gradient(135deg, #FFC107, #FFA000)',
                params: [
                    { key: 'rgbCurve', name: 'RGBæ›²çº¿', valueColor: '#FFECB3' }
                ]
            },
            {
                id: 'color-wheel-effects-tab',
                name: 'è‰²è½®ç»„',
                color: 'linear-gradient(135deg, #F44336, #D32F2F)',
                params: [
                    { key: 'shadows', name: 'æš—éƒ¨', valueColor: '#FFCDD2' },
                    { key: 'midtones', name: 'ä¸­ç°', valueColor: '#FFCDD2' },
                    { key: 'faces', name: 'è„¸éƒ¨', valueColor: '#FFCDD2' },
                    { key: 'offset', name: 'åç§»', valueColor: '#FFCDD2' }
                ]
            },
            {
                id: 'mask-effects-tab',
                name: 'è’™ç‰ˆç»„',
                color: 'linear-gradient(135deg, #607D8B, #455A64)',
                params: [
                    { key: 'type', name: 'è’™ç‰ˆç±»å‹', valueColor: '#B0BEC5' },
                    { key: 'invert', name: 'åé€‰', valueColor: '#B0BEC5' },
                    { key: 'feather', name: 'ç¾½åŒ–', valueColor: '#B0BEC5' }
                ]
            }
        ];
        
        // å½“å‰æ¿€æ´»çš„æ ‡ç­¾é¡µ
        let activeTab = tabs[0].id;
        
        // åˆ›å»ºæ ‡ç­¾é¡µæŒ‰é’®å’Œå†…å®¹
        tabs.forEach(tab => {
            // åˆ›å»ºæ ‡ç­¾é¡µæŒ‰é’®ï¼ˆå·¦ä¾§æ¨ªå‘æ–‡å­—ï¼‰
            const tabBtn = document.createElement('button');
            tabBtn.id = `${tab.id}-btn`;
            
            // ç¡®å®šæ˜¯å¦ç¦ç”¨è¯¥æ ‡ç­¾é¡µ
            const disabledTabs = ['curve-effects-tab', 'color-wheel-effects-tab', 'mask-effects-tab'];
            const isDisabled = disabledTabs.includes(tab.id);
            
            tabBtn.style.cssText = `
                background: ${tab.id === activeTab ? tab.color : 'transparent'};
                color: ${isDisabled ? '#aaa' : 'white'};
                border: none;
                padding: 10px;
                cursor: ${isDisabled ? 'not-allowed' : 'pointer'};
                font-weight: bold;
                font-size: 14px;
                transition: all 0.2s ease;
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                opacity: ${isDisabled ? '0.6' : '1'};
            `;
            
            // è®¾ç½®ç¦ç”¨å±æ€§
            if (isDisabled) {
                tabBtn.disabled = true;
            }
            
            tabBtn.textContent = tab.name;
            tabBtn.dataset.tabId = tab.id;
            
            // æ ‡ç­¾é¡µç‚¹å‡»äº‹ä»¶ - åªæœ‰éç¦ç”¨æ ‡ç­¾é¡µæ‰æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            if (!isDisabled) {
                tabBtn.addEventListener('click', () => {
                    // æ›´æ–°æ¿€æ´»çŠ¶æ€
                    activeTab = tab.id;
                    
                    // æ›´æ–°æŒ‰é’®æ ·å¼
                    document.querySelectorAll('#color-tabs-nav button').forEach(btn => {
                        const btnTabId = btn.dataset.tabId;
                        const btnTab = tabs.find(t => t.id === btnTabId);
                        btn.style.background = btnTabId === activeTab ? btnTab.color : 'transparent';
                    });
                    
                    // æ˜¾ç¤ºå¯¹åº”çš„å†…å®¹
                    document.querySelectorAll('.tab-pane').forEach(pane => {
                        pane.style.display = pane.id === activeTab ? 'block' : 'none';
                    });
                });
            }
            
            tabNav.appendChild(tabBtn);
            
            // åˆ›å»ºæ ‡ç­¾é¡µå†…å®¹
            const tabPane = document.createElement('div');
            tabPane.id = tab.id;
            tabPane.className = 'tab-pane';
            tabPane.style.cssText = `
                display: ${tab.id === activeTab ? 'block' : 'none'};
                padding: 15px;
                height: calc(100% - 30px);
                overflow-y: auto;
            `;
            
            // åˆ›å»ºå‚æ•°æ§ä»¶
            tab.params.forEach(param => {
                const paramContainer = document.createElement('div');
                paramContainer.className = 'param-container';
                paramContainer.style.cssText = `
                    margin-bottom: 15px;
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                `;
                
                const paramHeader = document.createElement('div');
                paramHeader.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    font-size: 14px;
                `;
                
                const paramName = document.createElement('span');
                paramName.textContent = param.name;
                
                const paramValue = document.createElement('span');
                paramValue.id = `color-${param.key}-value`;
                paramValue.textContent = '0';
                paramValue.style.cssText = `
                    color: ${param.valueColor};
                    font-weight: bold;
                `;
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `color-${param.key}`;
                slider.min = '-100';
                slider.max = '100';
                slider.value = '0';
                slider.dataset.param = param.key;
                slider.style.cssText = `
                    width: 100%;
                    height: 6px;
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 3px;
                    outline: none;
                    -webkit-appearance: none;
                `;
                
                paramHeader.appendChild(paramName);
                paramHeader.appendChild(paramValue);
                paramContainer.appendChild(paramHeader);
                paramContainer.appendChild(slider);
                tabPane.appendChild(paramContainer);
            });
            
            tabContent.appendChild(tabPane);
        });
        
        // ç»„è£…æ ‡ç­¾é¡µå®¹å™¨
        tabContainer.appendChild(tabNav);
        tabContainer.appendChild(tabContent);
        
        // ç»„è£…DOMç»“æ„
        originalPreview.appendChild(originalTitle);
        originalPreview.appendChild(originalCanvas);
        editedPreview.appendChild(editedTitle);
        editedPreview.appendChild(editedCanvas);
        compareContainer.appendChild(originalPreview);
        compareContainer.appendChild(editedPreview);
        buttonsContainer.appendChild(resetBtn);
        buttonsContainer.appendChild(exportBtn);
        buttonsContainer.appendChild(importBtn);
        buttonsContainer.appendChild(applyBtn);
        
        // æ·»åŠ æ–‡ä»¶è¾“å…¥åˆ°æ–‡æ¡£ä¸­
        container.appendChild(fileInput);
        
        previewSection.appendChild(compareContainer);
        previewSection.appendChild(buttonsContainer);
        
        paramsSection.appendChild(tabContainer);
        
        panel.appendChild(previewSection);
        panel.appendChild(paramsSection);
        container.appendChild(panel);
        document.body.appendChild(container);
        
        // ä¿å­˜å¼•ç”¨
        this.state.canvas = editedCanvas;
        this.state.ctx = editedCanvas.getContext('2d');
        this.state.compareCanvas = originalCanvas;
        this.state.compareCtx = originalCanvas.getContext('2d');
    },
    
    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    setupEventListeners() {
        const container = document.getElementById('image-color-adjuster-container');
        

        
        // è°ƒè‰²æ»‘å—äº‹ä»¶
        document.querySelectorAll('input[type="range"][data-param]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                e.preventDefault();
                const param = e.target.dataset.param;
                const value = parseInt(e.target.value);
                this.updateParam(param, value);
            });
        });
        
        // é‡ç½®å‚æ•°æŒ‰é’®äº‹ä»¶
        document.getElementById('reset-color-adjustments').addEventListener('click', () => {
            this.resetAllParams();
        });
        
        // ç‚¹å‡»å®¹å™¨å¤–éƒ¨å…³é—­è°ƒè‰²é¢æ¿å¹¶ä¿å­˜
        container.addEventListener('click', (e) => {
            if (e.target === container) {
                this.saveAndHide();
            }
        });
    },
    
    // æ›´æ–°è°ƒè‰²å‚æ•°
    updateParam(param, value) {
        // ç¡®å®šå‚æ•°æ‰€å±çš„ç»„
        let group;
        if (['temperature', 'tint', 'saturation', 'naturalSaturation'].includes(param)) {
            group = 'colorEffects';
        } else if (['brightness', 'contrast', 'highlight', 'shadow', 'white', 'black', 'lightSense'].includes(param)) {
            group = 'lightEffects';
        } else if (['sharpen', 'clarity', 'grain', 'fade', 'vignette'].includes(param)) {
            group = 'effectEffects';
        } else if (['hue', 'hslSaturation', 'hslLightness'].includes(param)) {
            group = 'hslEffects';
        } else if (['shadows', 'midtones', 'faces', 'offset'].includes(param)) {
            group = 'colorWheelEffects';
        } else if (['type', 'invert', 'feather'].includes(param)) {
            group = 'maskEffects';
        } else if (['rgbCurve'].includes(param)) {
            group = 'curveEffects';
        }
        
        // æ›´æ–°çŠ¶æ€
        if (group) {
            this.state[group][param] = value;
        }
        
        // æ›´æ–°UIæ˜¾ç¤º
        const valueElement = document.getElementById(`color-${param}-value`);
        if (valueElement) {
            valueElement.textContent = value;
        }
        
        // å®æ—¶ä¿å­˜è°ƒè‰²å‚æ•°åˆ°å›¾ç‰‡å¯¹è±¡
        if (this.state.currentImage) {
            // ç¡®ä¿å›¾ç‰‡å¯¹è±¡æœ‰colorParamså±æ€§
            if (!this.state.currentImage.colorParams) {
                this.state.currentImage.colorParams = {
                    // è‰²å½©ç»„
                    temperature: 0,
                    tint: 0,
                    saturation: 0,
                    naturalSaturation: 0,
                    // æ˜åº¦ç»„
                    brightness: 0,
                    contrast: 0,
                    highlight: 0,
                    shadow: 0,
                    white: 0,
                    black: 0,
                    lightSense: 0,
                    // æ•ˆæœç»„
                    sharpen: 0,
                    clarity: 0,
                    grain: 0,
                    fade: 0,
                    vignette: 0,
                    // HSLç»„
                    hue: 0,
                    hslSaturation: 0,
                    hslLightness: 0,
                    // è‰²è½®ç»„
                    shadows: 0,
                    midtones: 0,
                    faces: 0,
                    offset: 0,
                    // è’™ç‰ˆç»„
                    maskType: 'none',
                    maskInvert: false,
                    maskFeather: 0
                };
            }
            // æ›´æ–°å½“å‰å‚æ•°å€¼
            this.state.currentImage.colorParams[param] = value;
            // æ›´æ–°å›¾ç‰‡çš„æ›´æ–°æ—¶é—´
            this.state.currentImage.updatedAt = new Date().toISOString();
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            if (window.imageHandler && window.imageHandler.saveImages) {
                window.imageHandler.saveImages();
            }
        }
        
        // åº”ç”¨è°ƒè‰²æ•ˆæœåˆ°é¢„è§ˆ
        this.applyColorAdjustmentsToPreview();
    },

    // RGBè½¬HSLå‡½æ•°
    rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];
    },

    // HSLè½¬RGBå‡½æ•°
    hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    },

    // åº”ç”¨è°ƒè‰²æ•ˆæœåˆ°é¢„è§ˆCanvas
    applyColorAdjustmentsToPreview() {
        if (!this.state.currentDisplayImage || !this.state.ctx || !this.state.canvas) return;

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.state.canvas.width;
        tempCanvas.height = this.state.canvas.height;
        tempCtx.drawImage(this.state.currentDisplayImage, 0, 0, tempCanvas.width, tempCanvas.height);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;

        // è·å–æ‰€æœ‰å‚æ•°
        const colorParams = this.state.colorEffects;
        const lightParams = this.state.lightEffects;
        const effectParams = this.state.effectEffects;
        const hslParams = this.state.hslEffects;
        const colorWheelParams = this.state.colorWheelEffects;

        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];

            // 1. è‰²æ¸©è°ƒæ•´
            const temperatureFactor = colorParams.temperature / 100;
            r = Math.min(255, r + temperatureFactor * 20);
            b = Math.min(255, b - temperatureFactor * 20);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 2. è‰²è°ƒè°ƒæ•´
            const tintFactor = colorParams.tint / 100;
            g = Math.min(255, g + tintFactor * 20);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 3. é¥±å’Œåº¦è°ƒæ•´
            const [h, s, l] = this.rgbToHsl(r, g, b);
            const adjustedS = Math.max(0, Math.min(1, s * (1 + colorParams.saturation / 100)));
            [r, g, b] = this.hslToRgb(h, adjustedS, l);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 4. è‡ªç„¶é¥±å’Œåº¦è°ƒæ•´
            const naturalSaturationFactor = colorParams.naturalSaturation / 100;
            const gray = (r + g + b) / 3;
            r = gray + (r - gray) * (1 + naturalSaturationFactor);
            g = gray + (g - gray) * (1 + naturalSaturationFactor);
            b = gray + (b - gray) * (1 + naturalSaturationFactor);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 5. äº®åº¦è°ƒæ•´
            const brightnessFactor = lightParams.brightness / 100;
            r = r * (1 + brightnessFactor);
            g = g * (1 + brightnessFactor);
            b = b * (1 + brightnessFactor);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 6. å¯¹æ¯”åº¦è°ƒæ•´
            const contrastFactor = 1 + lightParams.contrast / 100;
            r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
            g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
            b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 7. é«˜å…‰è°ƒæ•´
            const highlightFactor = lightParams.highlight / 100;
            if (l > 0.7) {
                r += highlightFactor * 30;
                g += highlightFactor * 30;
                b += highlightFactor * 30;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 8. é˜´å½±è°ƒæ•´
            const shadowFactor = lightParams.shadow / 100;
            if (l < 0.3) {
                r += shadowFactor * 30;
                g += shadowFactor * 30;
                b += shadowFactor * 30;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 9. ç™½è‰²è°ƒæ•´
            const whiteFactor = lightParams.white / 100;
            r += whiteFactor * (255 - r) * 0.2;
            g += whiteFactor * (255 - g) * 0.2;
            b += whiteFactor * (255 - b) * 0.2;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 10. é»‘è‰²è°ƒæ•´
            const blackFactor = lightParams.black / 100;
            r -= blackFactor * r * 0.2;
            g -= blackFactor * g * 0.2;
            b -= blackFactor * b * 0.2;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 11. å…‰æ„Ÿè°ƒæ•´
            const lightSenseFactor = lightParams.lightSense / 100;
            const avg = (r + g + b) / 3;
            r += (r - avg) * lightSenseFactor;
            g += (g - avg) * lightSenseFactor;
            b += (b - avg) * lightSenseFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 12. é”åŒ–è°ƒæ•´ (ç®€åŒ–å®ç°ï¼Œä½¿ç”¨è¾¹ç¼˜å¢å¼º)
            const sharpenFactor = effectParams.sharpen / 100;
            const x = (i / 4) % tempCanvas.width;
            const y = Math.floor((i / 4) / tempCanvas.width);
            let avgR = r, avgG = g, avgB = b;
            if (x > 0 && y > 0 && x < tempCanvas.width - 1 && y < tempCanvas.height - 1) {
                const neighbors = [
                    data[(y-1)*tempCanvas.width*4 + (x-1)*4], data[(y-1)*tempCanvas.width*4 + x*4], data[(y-1)*tempCanvas.width*4 + (x+1)*4],
                    data[y*tempCanvas.width*4 + (x-1)*4],                                       data[y*tempCanvas.width*4 + (x+1)*4],
                    data[(y+1)*tempCanvas.width*4 + (x-1)*4], data[(y+1)*tempCanvas.width*4 + x*4], data[(y+1)*tempCanvas.width*4 + (x+1)*4]
                ].reduce((sum, val) => sum + val, 0) / 8;
                avgR = neighbors;
                avgG = neighbors; // ç®€åŒ–
                avgB = neighbors;
            }
            r = r + (r - avgR) * sharpenFactor;
            g = g + (g - avgG) * sharpenFactor;
            b = b + (b - avgB) * sharpenFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 13. æ¸…æ™°åº¦è°ƒæ•´
            const clarityFactor = effectParams.clarity / 100;
            const diff = (r + g + b) / 3 - gray;
            r = r + diff * clarityFactor;
            g = g + diff * clarityFactor;
            b = b + diff * clarityFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 14. è¤ªè‰²è°ƒæ•´
            const fadeFactor = effectParams.fade / 100;
            const fadeGray = 128;
            r = r * (1 - fadeFactor) + fadeGray * fadeFactor;
            g = g * (1 - fadeFactor) + fadeGray * fadeFactor;
            b = b * (1 - fadeFactor) + fadeGray * fadeFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 15. æš—è§’è°ƒæ•´
            const vignetteFactor = effectParams.vignette / 100;
            if (vignetteFactor > 0) {
                const x = (i / 4) % tempCanvas.width;
                const y = Math.floor((i / 4) / tempCanvas.width);
                const centerX = tempCanvas.width / 2;
                const centerY = tempCanvas.height / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
                const vignette = 1 - (distance / maxDistance) * vignetteFactor;
                r *= vignette;
                g *= vignette;
                b *= vignette;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 16. HSLè°ƒæ•´
            // è½¬æ¢ä¸ºHSL
            let [h2, s2, l2] = this.rgbToHsl(r, g, b);
            
            // è°ƒæ•´è‰²ç›¸ (-100åˆ°100è½¬æ¢ä¸º-1åˆ°1ï¼Œå†ä¹˜ä»¥360åº¦)
            let adjustedH = h2 + (hslParams.hue / 100);
            // ç¡®ä¿è‰²ç›¸åœ¨0-1èŒƒå›´å†…
            adjustedH = (adjustedH + 1) % 1;
            if (adjustedH < 0) adjustedH += 1;
            
            // è°ƒæ•´é¥±å’Œåº¦ (-100åˆ°100è½¬æ¢ä¸º0åˆ°2çš„å› å­)
            let adjustedS2 = s2 * (1 + hslParams.saturation / 100);
            adjustedS2 = Math.max(0, Math.min(1, adjustedS2));
            
            // è°ƒæ•´æ˜åº¦ (-100åˆ°100è½¬æ¢ä¸º-1åˆ°1çš„åç§»)
            let adjustedL = l2 + (hslParams.lightness / 200); // 0.5çš„èŒƒå›´ï¼Œå› ä¸ºæ˜åº¦èŒƒå›´æ˜¯0-1
            adjustedL = Math.max(0, Math.min(1, adjustedL));
            
            // è½¬æ¢å›RGB
            const [adjustedR, adjustedG, adjustedB] = this.hslToRgb(adjustedH, adjustedS2, adjustedL);
            r = adjustedR;
            g = adjustedG;
            b = adjustedB;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 17. è‰²è½®è°ƒæ•´
            // è½¬æ¢ä¸ºHSLä»¥è·å–l
            [h2, s2, l2] = this.rgbToHsl(r, g, b);
            // æš—éƒ¨è°ƒæ•´
            if (l2 < 0.3) {
                const shadowsHueShift = colorWheelParams.shadows / 200;
                adjustedH = h2 + shadowsHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [shadowsR, shadowsG, shadowsB] = this.hslToRgb(adjustedH, s2, l2);
                r = shadowsR;
                g = shadowsG;
                b = shadowsB;
            }
            // ä¸­ç°è°ƒæ•´
            else if (l2 >= 0.3 && l2 <= 0.7) {
                const midtonesHueShift = colorWheelParams.midtones / 200;
                adjustedH = h2 + midtonesHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [midtonesR, midtonesG, midtonesB] = this.hslToRgb(adjustedH, s2, l2);
                r = midtonesR;
                g = midtonesG;
                b = midtonesB;
            }
            // è„¸éƒ¨è°ƒæ•´ (ç®€åŒ–å®ç°ï¼Œå‡è®¾è„¸éƒ¨åœ¨äº®éƒ¨)
            else if (l2 > 0.7) {
                const facesHueShift = colorWheelParams.faces / 200;
                adjustedH = h2 + facesHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [facesR, facesG, facesB] = this.hslToRgb(adjustedH, s2, l2);
                r = facesR;
                g = facesG;
                b = facesB;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // 18. è‰²è°ƒåç§»
            const offsetHueShift = colorWheelParams.offset / 200;
            const [hOffset, sOffset, lOffset] = this.rgbToHsl(r, g, b);
            const adjustedHOffset = (hOffset + offsetHueShift + 1) % 1;
            const [offsetR, offsetG, offsetB] = this.hslToRgb(adjustedHOffset, sOffset, lOffset);
            r = offsetR;
            g = offsetG;
            b = offsetB;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // æœ€ç»ˆèµ‹å€¼
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
        }

        tempCtx.putImageData(imageData, 0, 0);
        this.state.ctx.drawImage(tempCanvas, 0, 0);
    },

    // ä¿å­˜å¹¶éšè—è°ƒè‰²é¢æ¿
    saveAndHide(apply = false) {
        if (apply) {
            // åº”ç”¨è°ƒè‰²æ•ˆæœåˆ°å®é™…å›¾åƒ
            this.applyColorAdjustmentsToImage();
        } else {
            // ä¸åº”ç”¨è°ƒè‰²æ•ˆæœï¼Œç›´æ¥éšè—é¢æ¿
            this.hide();
        }
    },

    // åº”ç”¨è°ƒè‰²æ•ˆæœåˆ°å®é™…å›¾åƒ
    applyColorAdjustmentsToImage() {
        if (!this.state.currentImage || !this.state.currentDisplayImage) return;

        // ä¿å­˜åŸå§‹å®½åº¦å’Œé«˜åº¦
        const originalWidth = this.state.currentImage.originalWidth || this.state.currentImage.width;
        const originalHeight = this.state.currentImage.originalHeight || this.state.currentImage.height;
        const currentWidth = this.state.currentImage.width;
        const currentHeight = this.state.currentImage.height;

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = originalWidth;
        tempCanvas.height = originalHeight;
        tempCtx.drawImage(this.state.currentDisplayImage, 0, 0, tempCanvas.width, tempCanvas.height);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;

        // è·å–æ‰€æœ‰å‚æ•°
        const colorParams = this.state.colorEffects;
        const lightParams = this.state.lightEffects;
        const effectParams = this.state.effectEffects;
        const hslParams = this.state.hslEffects;
        const colorWheelParams = this.state.colorWheelEffects;

        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];

            // 1. è‰²æ¸©è°ƒæ•´
            const temperatureFactor = colorParams.temperature / 100;
            r = Math.min(255, r + temperatureFactor * 20);
            b = Math.min(255, b - temperatureFactor * 20);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 2. è‰²è°ƒè°ƒæ•´
            const tintFactor = colorParams.tint / 100;
            g = Math.min(255, g + tintFactor * 20);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 3. é¥±å’Œåº¦è°ƒæ•´
            const [h, s, l] = this.rgbToHsl(r, g, b);
            const adjustedS = Math.max(0, Math.min(1, s * (1 + colorParams.saturation / 100)));
            [r, g, b] = this.hslToRgb(h, adjustedS, l);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 4. è‡ªç„¶é¥±å’Œåº¦è°ƒæ•´
            const naturalSaturationFactor = colorParams.naturalSaturation / 100;
            const gray = (r + g + b) / 3;
            r = gray + (r - gray) * (1 + naturalSaturationFactor);
            g = gray + (g - gray) * (1 + naturalSaturationFactor);
            b = gray + (b - gray) * (1 + naturalSaturationFactor);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 5. äº®åº¦è°ƒæ•´
            const brightnessFactor = lightParams.brightness / 100;
            r = r * (1 + brightnessFactor);
            g = g * (1 + brightnessFactor);
            b = b * (1 + brightnessFactor);
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 6. å¯¹æ¯”åº¦è°ƒæ•´
            const contrastFactor = 1 + lightParams.contrast / 100;
            r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
            g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
            b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 7. é«˜å…‰è°ƒæ•´
            const highlightFactor = lightParams.highlight / 100;
            if (l > 0.7) {
                r += highlightFactor * 30;
                g += highlightFactor * 30;
                b += highlightFactor * 30;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 8. é˜´å½±è°ƒæ•´
            const shadowFactor = lightParams.shadow / 100;
            if (l < 0.3) {
                r += shadowFactor * 30;
                g += shadowFactor * 30;
                b += shadowFactor * 30;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 9. ç™½è‰²è°ƒæ•´
            const whiteFactor = lightParams.white / 100;
            r += whiteFactor * (255 - r) * 0.2;
            g += whiteFactor * (255 - g) * 0.2;
            b += whiteFactor * (255 - b) * 0.2;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 10. é»‘è‰²è°ƒæ•´
            const blackFactor = lightParams.black / 100;
            r -= blackFactor * r * 0.2;
            g -= blackFactor * g * 0.2;
            b -= blackFactor * b * 0.2;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 11. å…‰æ„Ÿè°ƒæ•´
            const lightSenseFactor = lightParams.lightSense / 100;
            const avg = (r + g + b) / 3;
            r += (r - avg) * lightSenseFactor;
            g += (g - avg) * lightSenseFactor;
            b += (b - avg) * lightSenseFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 12. é”åŒ–è°ƒæ•´ (ç®€åŒ–å®ç°ï¼Œä½¿ç”¨è¾¹ç¼˜å¢å¼º)
            const sharpenFactor = effectParams.sharpen / 100;
            const x = (i / 4) % tempCanvas.width;
            const y = Math.floor((i / 4) / tempCanvas.width);
            let avgR = r, avgG = g, avgB = b;
            if (x > 0 && y > 0 && x < tempCanvas.width - 1 && y < tempCanvas.height - 1) {
                const neighbors = [
                    data[(y-1)*tempCanvas.width*4 + (x-1)*4], data[(y-1)*tempCanvas.width*4 + x*4], data[(y-1)*tempCanvas.width*4 + (x+1)*4],
                    data[y*tempCanvas.width*4 + (x-1)*4],                                       data[y*tempCanvas.width*4 + (x+1)*4],
                    data[(y+1)*tempCanvas.width*4 + (x-1)*4], data[(y+1)*tempCanvas.width*4 + x*4], data[(y+1)*tempCanvas.width*4 + (x+1)*4]
                ].reduce((sum, val) => sum + val, 0) / 8;
                avgR = neighbors;
                avgG = neighbors; // ç®€åŒ–
                avgB = neighbors;
            }
            r = r + (r - avgR) * sharpenFactor;
            g = g + (g - avgG) * sharpenFactor;
            b = b + (b - avgB) * sharpenFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 13. æ¸…æ™°åº¦è°ƒæ•´
            const clarityFactor = effectParams.clarity / 100;
            const diff = (r + g + b) / 3 - gray;
            r = r + diff * clarityFactor;
            g = g + diff * clarityFactor;
            b = b + diff * clarityFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 14. è¤ªè‰²è°ƒæ•´
            const fadeFactor = effectParams.fade / 100;
            const fadeGray = 128;
            r = r * (1 - fadeFactor) + fadeGray * fadeFactor;
            g = g * (1 - fadeFactor) + fadeGray * fadeFactor;
            b = b * (1 - fadeFactor) + fadeGray * fadeFactor;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 15. æš—è§’è°ƒæ•´
            const vignetteFactor = effectParams.vignette / 100;
            if (vignetteFactor > 0) {
                const x = (i / 4) % tempCanvas.width;
                const y = Math.floor((i / 4) / tempCanvas.width);
                const centerX = tempCanvas.width / 2;
                const centerY = tempCanvas.height / 2;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
                const vignette = 1 - (distance / maxDistance) * vignetteFactor;
                r *= vignette;
                g *= vignette;
                b *= vignette;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 16. HSLè°ƒæ•´
            // è½¬æ¢ä¸ºHSL
            let [h2, s2, l2] = this.rgbToHsl(r, g, b);
            
            // è°ƒæ•´è‰²ç›¸ (-100åˆ°100è½¬æ¢ä¸º-1åˆ°1ï¼Œå†ä¹˜ä»¥360åº¦)
            let adjustedH = h2 + (hslParams.hue / 100);
            // ç¡®ä¿è‰²ç›¸åœ¨0-1èŒƒå›´å†…
            adjustedH = (adjustedH + 1) % 1;
            if (adjustedH < 0) adjustedH += 1;
            
            // è°ƒæ•´é¥±å’Œåº¦ (-100åˆ°100è½¬æ¢ä¸º0åˆ°2çš„å› å­)
            let adjustedS2 = s2 * (1 + hslParams.saturation / 100);
            adjustedS2 = Math.max(0, Math.min(1, adjustedS2));
            
            // è°ƒæ•´æ˜åº¦ (-100åˆ°100è½¬æ¢ä¸º-1åˆ°1çš„åç§»)
            let adjustedL = l2 + (hslParams.lightness / 200); // 0.5çš„èŒƒå›´ï¼Œå› ä¸ºæ˜åº¦èŒƒå›´æ˜¯0-1
            adjustedL = Math.max(0, Math.min(1, adjustedL));
            
            // è½¬æ¢å›RGB
            const [adjustedR, adjustedG, adjustedB] = this.hslToRgb(adjustedH, adjustedS2, adjustedL);
            r = adjustedR;
            g = adjustedG;
            b = adjustedB;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // 17. è‰²è½®è°ƒæ•´
            // è½¬æ¢ä¸ºHSLä»¥è·å–l
            [h2, s2, l2] = this.rgbToHsl(r, g, b);
            // æš—éƒ¨è°ƒæ•´
            if (l2 < 0.3) {
                const shadowsHueShift = colorWheelParams.shadows / 200;
                adjustedH = h2 + shadowsHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [shadowsR, shadowsG, shadowsB] = this.hslToRgb(adjustedH, s2, l2);
                r = shadowsR;
                g = shadowsG;
                b = shadowsB;
            }
            // ä¸­ç°è°ƒæ•´
            else if (l2 >= 0.3 && l2 <= 0.7) {
                const midtonesHueShift = colorWheelParams.midtones / 200;
                adjustedH = h2 + midtonesHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [midtonesR, midtonesG, midtonesB] = this.hslToRgb(adjustedH, s2, l2);
                r = midtonesR;
                g = midtonesG;
                b = midtonesB;
            }
            // è„¸éƒ¨è°ƒæ•´ (ç®€åŒ–å®ç°ï¼Œå‡è®¾è„¸éƒ¨åœ¨äº®éƒ¨)
            else if (l2 > 0.7) {
                const facesHueShift = colorWheelParams.faces / 200;
                adjustedH = h2 + facesHueShift;
                adjustedH = (adjustedH + 1) % 1;
                if (adjustedH < 0) adjustedH += 1;
                const [facesR, facesG, facesB] = this.hslToRgb(adjustedH, s2, l2);
                r = facesR;
                g = facesG;
                b = facesB;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // 18. è‰²è°ƒåç§»
            const offsetHueShift = colorWheelParams.offset / 200;
            const [hOffset, sOffset, lOffset] = this.rgbToHsl(r, g, b);
            const adjustedHOffset = (hOffset + offsetHueShift + 1) % 1;
            const [offsetR, offsetG, offsetB] = this.hslToRgb(adjustedHOffset, sOffset, lOffset);
            r = offsetR;
            g = offsetG;
            b = offsetB;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            // æœ€ç»ˆèµ‹å€¼
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
        }

        tempCtx.putImageData(imageData, 0, 0);
        
        // è·å–æœ€ç»ˆè°ƒæ•´å›¾åƒæ•°æ®
        const finalDataURL = tempCanvas.toDataURL('image/png');
        
        // æ›´æ–°DOMä¸­çš„å›¾ç‰‡ï¼Œä¿æŒå½“å‰å°ºå¯¸ä¸å˜
        const imgElement = document.getElementById(`image-${this.state.currentImage.id}`);
        if (imgElement) {
            const img = imgElement.querySelector('img');
            if (img) {
                // ç›´æ¥ä½¿ç”¨åŸå§‹å°ºå¯¸ä½œä¸ºå›¾ç‰‡å…ƒç´ çš„å°ºå¯¸ï¼Œç¡®ä¿å›¾ç‰‡æ¯”ä¾‹æ­£ç¡®
                img.width = originalWidth;
                img.height = originalHeight;
                img.src = finalDataURL;
                // ä¿æŒå›¾ç‰‡æ¡†å°ºå¯¸ä¸å˜ï¼Œä¸å½“å‰æ˜¾ç¤ºå°ºå¯¸ä¸€è‡´
                imgElement.style.width = `${currentWidth}px`;
                imgElement.style.height = `${currentHeight}px`;
                // ç¡®ä¿å›¾ç‰‡åœ¨æ¡†å†…æ­£ç¡®æ˜¾ç¤º
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                // ç¡®ä¿ä½ç½®å’Œæ—‹è½¬ä¹Ÿæ­£ç¡®
                imgElement.style.transform = `translate(${this.state.currentImage.x}px, ${this.state.currentImage.y}px) rotate(${this.state.currentImage.rotation || 0}deg)`;
            }
        }
        
        // æ›´æ–°å›¾ç‰‡æ•°æ®ï¼Œä¿æŒæ‰€æœ‰å°ºå¯¸å±æ€§ä¸å˜
        this.state.currentImage.src = finalDataURL;
        // ç¡®ä¿åŸå§‹å°ºå¯¸å’Œå½“å‰æ˜¾ç¤ºå°ºå¯¸éƒ½ä¿æŒä¸å˜
        this.state.currentImage.originalWidth = originalWidth;
        this.state.currentImage.originalHeight = originalHeight;
        this.state.currentImage.width = currentWidth;
        this.state.currentImage.height = currentHeight;
        
        this.state.currentImage.updatedAt = new Date().toISOString();
        
        // ä¿å­˜æ›´æ–°åçš„æ•°æ®
        if (window.imageHandler && window.imageHandler.saveImages) {
            window.imageHandler.saveImages();
        }
        
        // éšè—è°ƒè‰²é¢æ¿
        this.hide();
    },
    
    // å·²ç§»é™¤æ¢å¤åŸè‰²åŠŸèƒ½ï¼Œä¿ç•™é‡ç½®å‚æ•°åŠŸèƒ½
    restoreOriginalImage() {
        // æ­¤æ–¹æ³•å·²è¢«ç§»é™¤ï¼Œä¿ç•™ä»…ä¸ºäº†å…¼å®¹ç°æœ‰ä»£ç 
        this.resetAllParams();
    },
    
    // é‡ç½®æ‰€æœ‰å‚æ•°
    resetAllParams() {
        // é‡ç½®è‰²å½©ç»„å‚æ•°
        this.state.colorEffects = {
            temperature: 0,
            tint: 0,
            saturation: 0,
            naturalSaturation: 0
        };
        
        // é‡ç½®æ˜åº¦ç»„å‚æ•°
        this.state.lightEffects = {
            brightness: 0,
            contrast: 0,
            highlight: 0,
            shadow: 0,
            white: 0,
            black: 0,
            lightSense: 0
        };
        
        // é‡ç½®æ•ˆæœç»„å‚æ•°
        this.state.effectEffects = {
            sharpen: 0,
            clarity: 0,
            grain: 0,
            fade: 0,
            vignette: 0
        };
        
        // é‡ç½®HSLç»„å‚æ•°
        this.state.hslEffects = {
            hue: 0,
            saturation: 0,
            lightness: 0
        };
        
        // é‡ç½®è‰²è½®ç»„å‚æ•°
        this.state.colorWheelEffects = {
            shadows: 0,
            midtones: 0,
            faces: 0,
            offset: 0
        };
        
        // é‡ç½®è’™ç‰ˆç»„å‚æ•°
        this.state.maskEffects = {
            type: 'none',
            invert: false,
            feather: 0,
            params: {
                linear: {
                    angle: 0,
                    position: 50
                },
                circle: {
                    x: 50,
                    y: 50,
                    radius: 50
                },
                rect: {
                    x: 25,
                    y: 25,
                    width: 50,
                    height: 50
                },
                text: {
                    content: '',
                    fontSize: 24,
                    fontFamily: 'Arial',
                    fontWeight: 'normal',
                    color: '#ffffff'
                }
            }
        };
        
        // æ›´æ–°UI
        const allParams = {
            ...this.state.colorEffects,
            ...this.state.lightEffects,
            ...this.state.effectEffects,
            ...this.state.hslEffects,
            ...this.state.colorWheelEffects,
            type: this.state.maskEffects.type,
            invert: this.state.maskEffects.invert,
            feather: this.state.maskEffects.feather
        };
        Object.keys(allParams).forEach(param => {
            const slider = document.getElementById(`color-${param}`);
            const valueElement = document.getElementById(`color-${param}-value`);
            
            if (slider) {
                slider.value = allParams[param];
            }
            if (valueElement) {
                valueElement.textContent = allParams[param];
            }
        });
        
        // é‡æ–°åº”ç”¨è°ƒæ•´åˆ°é¢„è§ˆ
        this.applyColorAdjustmentsToPreview();
    },
    
    // åŠ è½½å›¾ç‰‡åˆ°è°ƒè‰²å™¨
    loadImage(image) {
        this.state.currentImage = image;
        
        // æ¢å¤å›¾ç‰‡çš„è°ƒè‰²å‚æ•°
        if (image.colorParams) {
            // æ›´æ–°çŠ¶æ€ä¸­çš„è‰²å½©ç»„å‚æ•°
            this.state.colorEffects = {
                temperature: image.colorParams.temperature || 0,
                tint: image.colorParams.tint || 0,
                saturation: image.colorParams.saturation || 0,
                naturalSaturation: image.colorParams.naturalSaturation || 0
            };
            
            // æ›´æ–°çŠ¶æ€ä¸­çš„æ˜åº¦ç»„å‚æ•°
            this.state.lightEffects = {
                brightness: image.colorParams.brightness || 0,
                contrast: image.colorParams.contrast || 0,
                highlight: image.colorParams.highlight || 0,
                shadow: image.colorParams.shadow || 0,
                white: image.colorParams.white || 0,
                black: image.colorParams.black || 0,
                lightSense: image.colorParams.lightSense || 0
            };
            
            // æ›´æ–°çŠ¶æ€ä¸­çš„æ•ˆæœç»„å‚æ•°
            this.state.effectEffects = {
                sharpen: image.colorParams.sharpen || 0,
                clarity: image.colorParams.clarity || 0,
                grain: image.colorParams.grain || 0,
                fade: image.colorParams.fade || 0,
                vignette: image.colorParams.vignette || 0
            };
            
            // æ›´æ–°çŠ¶æ€ä¸­çš„HSLç»„å‚æ•°
            this.state.hslEffects = {
                hue: image.colorParams.hue || 0,
                saturation: image.colorParams.hslSaturation || 0,
                lightness: image.colorParams.hslLightness || 0
            };
            
            // æ›´æ–°çŠ¶æ€ä¸­çš„è‰²è½®ç»„å‚æ•°
            this.state.colorWheelEffects = {
                shadows: image.colorParams.shadows || 0,
                midtones: image.colorParams.midtones || 0,
                faces: image.colorParams.faces || 0,
                offset: image.colorParams.offset || 0
            };
            
            // æ›´æ–°çŠ¶æ€ä¸­çš„è’™ç‰ˆç»„å‚æ•°
            this.state.maskEffects = {
                type: image.colorParams.maskType || 'none',
                invert: image.colorParams.maskInvert || false,
                feather: image.colorParams.maskFeather || 0,
                params: {
                    linear: {
                        angle: 0,
                        position: 50
                    },
                    circle: {
                        x: 50,
                        y: 50,
                        radius: 50
                    },
                    rect: {
                        x: 25,
                        y: 25,
                        width: 50,
                        height: 50
                    },
                    text: {
                        content: '',
                        fontSize: 24,
                        fontFamily: 'Arial',
                        fontWeight: 'normal',
                        color: '#ffffff'
                    }
                }
            };
            
            // æ›´æ–°UIæ»‘å—å’Œæ•°å€¼æ˜¾ç¤º
            const allParams = {
                ...this.state.colorEffects,
                ...this.state.lightEffects,
                ...this.state.effectEffects,
                ...this.state.hslEffects,
                ...this.state.colorWheelEffects,
                ...this.state.maskEffects
            };
            Object.keys(allParams).forEach(param => {
                const slider = document.getElementById(`color-${param}`);
                const valueElement = document.getElementById(`color-${param}-value`);
                const value = allParams[param];
                
                if (slider) {
                    slider.value = value;
                }
                if (valueElement) {
                    valueElement.textContent = value;
                }
            });
        } else {
            // é‡ç½®ä¸ºé»˜è®¤å€¼
            this.resetAllParams();
        }
        
        // åŠ è½½è£å‰ªåçš„åŸå›¾ï¼ˆç”¨äºå·¦ä¾§æ˜¾ç¤ºï¼‰
        const originalImg = new Image();
        originalImg.onload = () => {
            // ä¿å­˜è£å‰ªåçš„åŸå›¾
            this.state.originalImage = originalImg;
            
            // ä¿å­˜å½“å‰æ˜¾ç¤ºçš„è£å‰ªåå›¾ç‰‡ï¼Œç”¨äºå³ä¾§è°ƒè‰²é¢„è§ˆ
            const currentImg = new Image();
            currentImg.onload = () => {
                this.state.currentDisplayImage = currentImg;
                
                // è®¡ç®—åˆé€‚çš„Canvaså°ºå¯¸
                const maxWidth = 350;
                const maxHeight = 450;
                let width = currentImg.width;
                let height = currentImg.height;
                
                // æŒ‰æ¯”ä¾‹ç¼©å°åˆ°å¤§å°ºå¯¸
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width = Math.round(width * ratio);
                    height = Math.round(height * ratio);
                }
                
                // è®¾ç½®ä¸¤ä¸ªCanvasçš„å°ºå¯¸
                this.state.canvas.width = width;
                this.state.canvas.height = height;
                this.state.compareCanvas.width = width;
                this.state.compareCanvas.height = height;
                
                // ç»˜åˆ¶è£å‰ªåçš„åŸå›¾åˆ°å·¦ä¾§Canvas
                this.state.compareCtx.drawImage(originalImg, 0, 0, width, height);
                // ç»˜åˆ¶å½“å‰æ˜¾ç¤ºçš„å›¾åƒåˆ°å³ä¾§Canvas
                this.state.ctx.drawImage(currentImg, 0, 0, width, height);
                
                // åº”ç”¨å½“å‰å‚æ•°åˆ°å³ä¾§Canvas
                this.applyColorAdjustmentsToPreview();
            };
            currentImg.src = image.src;
        };
        originalImg.src = image.src; // ä½¿ç”¨è£å‰ªåçš„åŸå›¾è¿›è¡Œè°ƒè‰²å¯¹æ¯”
    },
    
    // å¯¼å‡ºå‚æ•°æ•°æ®
    exportColorParams() {
        // å‚æ•°åç§°æ˜ å°„ï¼šä¸­æ–‡(è‹±æ–‡)
        const paramNames = {
            // è‰²å½©ç»„
            temperature: 'è‰²æ¸©(temperature)',
            tint: 'è‰²è°ƒ(tint)',
            saturation: 'é¥±å’Œåº¦(saturation)',
            naturalSaturation: 'è‡ªç„¶é¥±å’Œåº¦(naturalSaturation)',
            // æ˜åº¦ç»„
            brightness: 'äº®åº¦(brightness)',
            contrast: 'å¯¹æ¯”åº¦(contrast)',
            highlight: 'é«˜å…‰(highlight)',
            shadow: 'é˜´å½±(shadow)',
            white: 'ç™½è‰²(white)',
            black: 'é»‘è‰²(black)',
            lightSense: 'å…‰æ„Ÿ(lightSense)',
            // æ•ˆæœç»„
            sharpen: 'é”åŒ–(sharpen)',
            clarity: 'æ¸…æ™°(clarity)',
            grain: 'é¢—ç²’(grain)',
            fade: 'è¤ªè‰²(fade)',
            vignette: 'æš—è§’(vignette)',
            // HSLç»„
            hue: 'è‰²ç›¸(hue)',
            hslSaturation: 'é¥±å’Œåº¦(saturation)',
            hslLightness: 'äº®åº¦(lightness)',
            // è‰²è½®ç»„
            shadows: 'æš—éƒ¨(shadows)',
            midtones: 'ä¸­ç°(midtones)',
            faces: 'è„¸éƒ¨(faces)',
            offset: 'åç§»(offset)',
            // è’™ç‰ˆç»„
            maskType: 'è’™ç‰ˆç±»å‹(type)',
            maskInvert: 'åé€‰(invert)',
            maskFeather: 'ç¾½åŒ–(feather)'
        };
        
        // æ„å»ºå‚æ•°æ–‡æœ¬
        let paramText = '';
        
        // è‰²å½©ç»„å‚æ•°
        paramText += 'è‰²å½©ç»„å‚æ•°:\n';
        const colorParams = this.state.colorEffects;
        for (const [key, value] of Object.entries(colorParams)) {
            paramText += `${paramNames[key]}: ${value}\n`;
        }
        
        // æ¢è¡Œåˆ†éš”ç»„
        paramText += '\n';
        
        // æ˜åº¦ç»„å‚æ•°
        paramText += 'æ˜åº¦ç»„å‚æ•°:\n';
        const lightParams = this.state.lightEffects;
        for (const [key, value] of Object.entries(lightParams)) {
            paramText += `${paramNames[key]}: ${value}\n`;
        }
        
        // æ¢è¡Œåˆ†éš”ç»„
        paramText += '\n';
        
        // æ•ˆæœç»„å‚æ•°
        paramText += 'æ•ˆæœç»„å‚æ•°:\n';
        const effectParams = this.state.effectEffects;
        for (const [key, value] of Object.entries(effectParams)) {
            paramText += `${paramNames[key]}: ${value}\n`;
        }
        
        // æ¢è¡Œåˆ†éš”ç»„
        paramText += '\n';
        
        // HSLç»„å‚æ•°
        paramText += 'HSLç»„å‚æ•°:\n';
        const hslParams = this.state.hslEffects;
        paramText += `${paramNames.hue}: ${hslParams.hue}\n`;
        paramText += `${paramNames.hslSaturation}: ${hslParams.saturation}\n`;
        paramText += `${paramNames.hslLightness}: ${hslParams.lightness}\n`;
        
        // æ¢è¡Œåˆ†éš”ç»„
        paramText += '\n';
        
        // è‰²è½®ç»„å‚æ•°
        paramText += 'è‰²è½®ç»„å‚æ•°:\n';
        const colorWheelParams = this.state.colorWheelEffects;
        for (const [key, value] of Object.entries(colorWheelParams)) {
            paramText += `${paramNames[key]}: ${value}\n`;
        }
        
        // æ¢è¡Œåˆ†éš”ç»„
        paramText += '\n';
        
        // è’™ç‰ˆç»„å‚æ•°
        paramText += 'è’™ç‰ˆç»„å‚æ•°:\n';
        const maskParams = this.state.maskEffects;
        paramText += `${paramNames.maskType}: ${maskParams.type}\n`;
        paramText += `${paramNames.maskInvert}: ${maskParams.invert}\n`;
        paramText += `${paramNames.maskFeather}: ${maskParams.feather}\n`;
        
        // åˆ›å»ºæ–‡æœ¬æ–‡ä»¶å¹¶ä¸‹è½½
        const blob = new Blob([paramText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'color-params.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },
    
    // å¯¼å…¥å‚æ•°æ•°æ®
    importColorParams(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            
            // è§£æå‚æ•°
            const params = this.parseColorParams(content);
            
            // æ›´æ–°è‰²å½©ç»„å‚æ•°
            if (params.colorEffects) {
                Object.assign(this.state.colorEffects, params.colorEffects);
            }
            
            // æ›´æ–°æ˜åº¦ç»„å‚æ•°
            if (params.lightEffects) {
                Object.assign(this.state.lightEffects, params.lightEffects);
            }
            
            // æ›´æ–°æ•ˆæœç»„å‚æ•°
            if (params.effectEffects) {
                Object.assign(this.state.effectEffects, params.effectEffects);
            }
            
            // æ›´æ–°HSLç»„å‚æ•°
            if (params.hslEffects) {
                Object.assign(this.state.hslEffects, params.hslEffects);
            }
            
            // æ›´æ–°è‰²è½®ç»„å‚æ•°
            if (params.colorWheelEffects) {
                Object.assign(this.state.colorWheelEffects, params.colorWheelEffects);
            }
            
            // æ›´æ–°è’™ç‰ˆç»„å‚æ•°
            if (params.maskEffects) {
                Object.assign(this.state.maskEffects, params.maskEffects);
            }
            
            // æ›´æ–°UI
            this.updateUI();
            
            // é‡æ–°åº”ç”¨è°ƒè‰²æ•ˆæœ
            this.applyColorAdjustmentsToPreview();
        };
        
        reader.readAsText(file);
        
        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
        event.target.value = '';
    },
    
    // è§£æå‚æ•°æ–‡æœ¬
    parseColorParams(content) {
        const lines = content.split('\n');
        const params = {
            colorEffects: {},
            lightEffects: {},
            effectEffects: {},
            hslEffects: {},
            colorWheelEffects: {},
            maskEffects: {}
        };
        
        let currentGroup = null;
        
        // æ­£åˆ™è¡¨è¾¾å¼ï¼šåŒ¹é… ä¸­æ–‡(è‹±æ–‡): å€¼ æˆ– è‹±æ–‡: å€¼
        const paramRegex = /^([\u4e00-\u9fa5]+\([a-zA-Z]+\)|[a-zA-Z]+):\s*(-?\d+|true|false|none|linear|mirror|circle|rect|text)$/;
        
        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // è·³è¿‡ç©ºè¡Œ
            if (!trimmedLine) continue;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç»„æ ‡é¢˜
            if (trimmedLine.includes('è‰²å½©ç»„å‚æ•°')) {
                currentGroup = 'colorEffects';
                continue;
            }
            if (trimmedLine.includes('æ˜åº¦ç»„å‚æ•°')) {
                currentGroup = 'lightEffects';
                continue;
            }
            if (trimmedLine.includes('æ•ˆæœç»„å‚æ•°')) {
                currentGroup = 'effectEffects';
                continue;
            }
            if (trimmedLine.includes('HSLç»„å‚æ•°')) {
                currentGroup = 'hslEffects';
                continue;
            }
            if (trimmedLine.includes('è‰²è½®ç»„å‚æ•°')) {
                currentGroup = 'colorWheelEffects';
                continue;
            }
            if (trimmedLine.includes('è’™ç‰ˆç»„å‚æ•°')) {
                currentGroup = 'maskEffects';
                continue;
            }
            
            // è§£æå‚æ•°è¡Œ
            const match = trimmedLine.match(paramRegex);
            if (match && currentGroup) {
                let paramKey = match[1];
                let paramValue = match[2];
                
                // æå–è‹±æ–‡å‚æ•°å
                if (paramKey.includes('(')) {
                    // æ ¼å¼ï¼šä¸­æ–‡(è‹±æ–‡)
                    paramKey = paramKey.match(/\(([^)]+)\)/)[1];
                }
                
                // è½¬æ¢å€¼ç±»å‹
                if (!isNaN(paramValue)) {
                    paramValue = parseInt(paramValue);
                } else if (paramValue === 'true') {
                    paramValue = true;
                } else if (paramValue === 'false') {
                    paramValue = false;
                }
                
                // æ·»åŠ åˆ°å¯¹åº”ç»„
                params[currentGroup][paramKey] = paramValue;
            }
        }
        
        return params;
    },
    
    // æ›´æ–°UIæ˜¾ç¤º
    updateUI() {
        // åˆå¹¶æ‰€æœ‰å‚æ•°
        const allParams = {
            ...this.state.colorEffects,
            ...this.state.lightEffects,
            ...this.state.effectEffects,
            ...this.state.hslEffects,
            ...this.state.colorWheelEffects,
            type: this.state.maskEffects.type,
            invert: this.state.maskEffects.invert,
            feather: this.state.maskEffects.feather
        };
        
        // æ›´æ–°æ‰€æœ‰æ»‘å—å’Œæ•°å€¼æ˜¾ç¤º
        Object.keys(allParams).forEach(param => {
            const slider = document.getElementById(`color-${param}`);
            const valueElement = document.getElementById(`color-${param}-value`);
            const value = allParams[param];
            
            if (slider) {
                slider.value = value;
            }
            if (valueElement) {
                valueElement.textContent = value;
            }
        });
    },
    
    // æ˜¾ç¤ºè°ƒè‰²å™¨
    show() {
        const container = document.getElementById('image-color-adjuster-container');
        if (container) {
            container.style.display = 'flex';
        }
        this.state.isAdjusting = true;
    },
    
    // éšè—è°ƒè‰²å™¨
    hide() {
        const container = document.getElementById('image-color-adjuster-container');
        if (container) {
            container.style.display = 'none';
        }
        this.state.isAdjusting = false;
    },
    
    // åˆ‡æ¢è°ƒè‰²å™¨æ˜¾ç¤ºçŠ¶æ€
    toggle() {
        const container = document.getElementById('image-color-adjuster-container');
        if (container) {
            if (container.style.display === 'flex') {
                this.saveAndHide();
            } else {
                this.show();
            }
        }
    }
};

// åˆå§‹åŒ–å›¾ç‰‡è°ƒè‰²æ¨¡å—
window.addEventListener('load', () => {
    imageColorAdjuster.init();
});

// å›¾ç‰‡ç›´æ–¹å›¾åŠŸèƒ½æ¨¡å—
const ImageHistogram = window.ImageHistogram = {
    // åˆå§‹åŒ–ç›´æ–¹å›¾åŠŸèƒ½
    init() {
        this.setupEventListeners();
    },

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    setupEventListeners() {
        // ç›‘å¬è°ƒè‰²ç•Œé¢çš„æ˜¾ç¤ºäº‹ä»¶ï¼Œåœ¨ç•Œé¢æ˜¾ç¤ºåæ·»åŠ ç›´æ–¹å›¾
        const colorAdjusterContainer = document.getElementById('image-color-adjuster-container');
        if (colorAdjusterContainer) {
            colorAdjusterContainer.addEventListener('DOMNodeInserted', () => {
                this.addHistogramsToColorAdjuster();
            });
        }
    },

    // å‘è°ƒè‰²ç•Œé¢æ·»åŠ ç›´æ–¹å›¾
    addHistogramsToColorAdjuster() {
        // æ£€æŸ¥æ˜¯å¦å·²ç»æ·»åŠ è¿‡ç›´æ–¹å›¾
        if (document.getElementById('histogram-container')) {
            return;
        }

        // è·å–å¯¹æ¯”å›¾å®¹å™¨
        const compareContainer = document.getElementById('color-compare-container');
        if (!compareContainer) {
            return;
        }

        // åˆ›å»ºç›´æ–¹å›¾å®¹å™¨
        const histogramContainer = document.createElement('div');
        histogramContainer.id = 'histogram-container';
        histogramContainer.style.cssText = `
            display: flex;
            gap: 10px;
            padding: 10px;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            width: 100%;
        `;

        // åˆ›å»ºåŸå›¾ç›´æ–¹å›¾åŒºåŸŸ
        const originalHistogramArea = this.createHistogramArea('original');
        // åˆ›å»ºä¿®å›¾ç›´æ–¹å›¾åŒºåŸŸ
        const editedHistogramArea = this.createHistogramArea('edited');

        // æ·»åŠ åˆ°å®¹å™¨
        histogramContainer.appendChild(originalHistogramArea);
        histogramContainer.appendChild(editedHistogramArea);

        // å°†ç›´æ–¹å›¾å®¹å™¨æ·»åŠ åˆ°å¯¹æ¯”å›¾å®¹å™¨ä¸‹æ–¹
        compareContainer.parentNode.insertBefore(histogramContainer, compareContainer.nextSibling);
    },

    // åˆ›å»ºå•ä¸ªç›´æ–¹å›¾åŒºåŸŸ
    createHistogramArea(type) {
        const area = document.createElement('div');
        area.className = `histogram-area ${type}-histogram-area`;
        area.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        `;

        // ç›´æ–¹å›¾æ ‡é¢˜
        const title = document.createElement('div');
        title.className = 'histogram-title';
        title.textContent = type === 'original' ? 'åŸå›¾ç›´æ–¹å›¾' : 'ä¿®å›¾ç›´æ–¹å›¾';
        title.style.cssText = `
            font-size: 14px;
            font-weight: bold;
            color: ${type === 'original' ? '#2196F3' : '#4CAF50'};
            text-align: center;
        `;

        // ç›´æ–¹å›¾æ§åˆ¶é€‰é¡¹
        const controls = document.createElement('div');
        controls.className = 'histogram-controls';
        controls.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            align-items: center;
        `;

        // ç°åº¦/RGBåˆ‡æ¢æŒ‰é’®
        const modeToggle = document.createElement('select');
        modeToggle.className = 'histogram-mode-toggle';
        modeToggle.dataset.type = type;
        modeToggle.innerHTML = `
            <option value="grayscale">ç°åº¦</option>
            <option value="rgb">RGB</option>
        `;
        modeToggle.style.cssText = `
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 12px;
        `;
        modeToggle.addEventListener('change', (e) => {
            this.updateHistograms();
        });

        // ç›´æ–¹å›¾Canvaså®¹å™¨
        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'histogram-canvas-container';
        canvasContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 5px;
        `;

        // ä¸»ç›´æ–¹å›¾Canvas
        const canvas = document.createElement('canvas');
        canvas.id = `${type}-histogram-canvas`;
        canvas.width = 300;
        canvas.height = 150;
        canvas.style.cssText = `
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        `;

        // ç»Ÿè®¡ä¿¡æ¯
        const statsContainer = document.createElement('div');
        statsContainer.id = `${type}-histogram-stats`;
        statsContainer.className = 'histogram-stats';
        statsContainer.style.cssText = `
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        `;

        // ç»„è£…
        controls.appendChild(modeToggle);
        canvasContainer.appendChild(canvas);
        canvasContainer.appendChild(statsContainer);
        area.appendChild(title);
        area.appendChild(controls);
        area.appendChild(canvasContainer);

        return area;
    },

    // è®¡ç®—ç›´æ–¹å›¾æ•°æ®
    calculateHistogram(imageData, mode = 'grayscale') {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const totalPixels = width * height;

        // åˆå§‹åŒ–ç›´æ–¹å›¾æ•°ç»„
        const histogram = {
            red: Array(256).fill(0),
            green: Array(256).fill(0),
            blue: Array(256).fill(0),
            grayscale: Array(256).fill(0)
        };

        // è®¡ç®—ç›´æ–¹å›¾
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // è®¡ç®—ç°åº¦å€¼
            const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

            // æ›´æ–°å„é€šé“ç›´æ–¹å›¾
            histogram.red[r]++;
            histogram.green[g]++;
            histogram.blue[b]++;
            histogram.grayscale[gray]++;
        }

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        const stats = this.calculateStats(histogram.grayscale, totalPixels);

        return { histogram, stats, totalPixels };
    },

    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    calculateStats(grayscaleHistogram, totalPixels) {
        // è®¡ç®—å¹³å‡å€¼
        let sum = 0;
        let sumSquared = 0;
        for (let i = 0; i < 256; i++) {
            sum += i * grayscaleHistogram[i];
            sumSquared += i * i * grayscaleHistogram[i];
        }
        const mean = sum / totalPixels;

        // è®¡ç®—æ ‡å‡†å·®
        const variance = (sumSquared / totalPixels) - (mean * mean);
        const stdDev = Math.sqrt(variance);

        // è®¡ç®—ä¸­ä½æ•°
        let cumulative = 0;
        let median = 0;
        const halfPixels = totalPixels / 2;
        for (let i = 0; i < 256; i++) {
            cumulative += grayscaleHistogram[i];
            if (cumulative >= halfPixels) {
                median = i;
                break;
            }
        }

        // è®¡ç®—æœ€å°å€¼å’Œæœ€å¤§å€¼
        let min = 0;
        for (let i = 0; i < 256; i++) {
            if (grayscaleHistogram[i] > 0) {
                min = i;
                break;
            }
        }

        let max = 255;
        for (let i = 255; i >= 0; i--) {
            if (grayscaleHistogram[i] > 0) {
                max = i;
                break;
            }
        }

        return {
            mean: mean.toFixed(1),
            median: median.toFixed(0),
            stdDev: stdDev.toFixed(1),
            min: min,
            max: max
        };
    },

    // ç»˜åˆ¶ç›´æ–¹å›¾
    drawHistogram(canvasId, histogramData, mode = 'grayscale') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, width, height);

        const { histogram, totalPixels } = histogramData;
        const binWidth = width / 256;

        // è®¡ç®—æœ€å¤§é¢‘ç‡ï¼ˆç”¨äºå½’ä¸€åŒ–ï¼‰
        let maxFreq = 0;
        if (mode === 'grayscale') {
            maxFreq = Math.max(...histogram.grayscale);
        } else {
            maxFreq = Math.max(
                Math.max(...histogram.red),
                Math.max(...histogram.green),
                Math.max(...histogram.blue)
            );
        }

        // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        
        // æ°´å¹³ç½‘æ ¼çº¿
        for (let i = 0; i <= 5; i++) {
            const y = height - (i / 5) * height;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }

        // å‚ç›´ç½‘æ ¼çº¿
        for (let i = 0; i <= 4; i++) {
            const x = (i / 4) * width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }

        // ç»˜åˆ¶ç›´æ–¹å›¾
        if (mode === 'grayscale') {
            // ç»˜åˆ¶ç°åº¦ç›´æ–¹å›¾
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 256; i++) {
                const freq = histogram.grayscale[i];
                const barHeight = (freq / maxFreq) * height * 0.9;
                const x = i * binWidth;
                const y = height - barHeight;
                
                ctx.fillRect(x, y, binWidth, barHeight);
            }
        } else {
            // ç»˜åˆ¶RGBç›´æ–¹å›¾
            const colors = {
                red: 'rgba(255, 0, 0, 0.6)',
                green: 'rgba(0, 255, 0, 0.6)',
                blue: 'rgba(0, 0, 255, 0.6)'
            };

            for (const channel of ['red', 'green', 'blue']) {
                ctx.fillStyle = colors[channel];
                for (let i = 0; i < 256; i++) {
                    const freq = histogram[channel][i];
                    const barHeight = (freq / maxFreq) * height * 0.9;
                    const x = i * binWidth;
                    const y = height - barHeight;
                    
                    ctx.fillRect(x, y, binWidth, barHeight);
                }
            }
        }

        // ç»˜åˆ¶åæ ‡è½´
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        
        // Xè½´
        ctx.beginPath();
        ctx.moveTo(0, height - 1);
        ctx.lineTo(width, height - 1);
        ctx.stroke();
        
        // Yè½´
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, height);
        ctx.stroke();
    },

    // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    displayStats(statsId, stats) {
        const statsContainer = document.getElementById(statsId);
        if (!statsContainer) return;

        statsContainer.innerHTML = `
            <div>å‡å€¼: ${stats.mean}</div>
            <div>ä¸­ä½æ•°: ${stats.median}</div>
            <div>æ ‡å‡†å·®: ${stats.stdDev}</div>
            <div>èŒƒå›´: ${stats.min}-${stats.max}</div>
        `;
    },

    // æ›´æ–°ç›´æ–¹å›¾
    updateHistograms() {
        // è·å–å½“å‰è°ƒè‰²ç•Œé¢çš„Canvas
        const originalCanvas = document.getElementById('color-original-canvas');
        const editedCanvas = document.getElementById('color-edited-canvas');
        
        if (!originalCanvas || !editedCanvas) return;

        // è·å–Canvasæ•°æ®
        const originalCtx = originalCanvas.getContext('2d');
        const editedCtx = editedCanvas.getContext('2d');
        
        const originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
        const editedImageData = editedCtx.getImageData(0, 0, editedCanvas.width, editedCanvas.height);

        // è·å–å½“å‰æ¨¡å¼
        const originalMode = document.querySelector('.histogram-mode-toggle[data-type="original"]').value;
        const editedMode = document.querySelector('.histogram-mode-toggle[data-type="edited"]').value;

        // è®¡ç®—å¹¶ç»˜åˆ¶åŸå›¾ç›´æ–¹å›¾
        const originalHistogramData = this.calculateHistogram(originalImageData, originalMode);
        this.drawHistogram('original-histogram-canvas', originalHistogramData, originalMode);
        this.displayStats('original-histogram-stats', originalHistogramData.stats);

        // è®¡ç®—å¹¶ç»˜åˆ¶ä¿®å›¾ç›´æ–¹å›¾
        const editedHistogramData = this.calculateHistogram(editedImageData, editedMode);
        this.drawHistogram('edited-histogram-canvas', editedHistogramData, editedMode);
        this.displayStats('edited-histogram-stats', editedHistogramData.stats);
    },

    // åœ¨å›¾ç‰‡åŠ è½½å®Œæˆåæ›´æ–°ç›´æ–¹å›¾
    onImageLoaded() {
        // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿Canvaså·²ç»ç»˜åˆ¶å®Œæˆ
        setTimeout(() => {
            this.updateHistograms();
        }, 100);
    }
};

// ç›‘å¬DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        ImageHistogram.init();
    });
} else {
    ImageHistogram.init();
}

// ç›‘å¬è°ƒè‰²å‚æ•°å˜åŒ–ï¼Œæ›´æ–°ç›´æ–¹å›¾
const originalAdjusterUpdateParam = imageColorAdjuster.updateParam;
imageColorAdjuster.updateParam = function(param, value) {
    originalAdjusterUpdateParam.call(this, param, value);
    ImageHistogram.updateHistograms();
};

// ç›‘å¬è°ƒè‰²ç•Œé¢æ˜¾ç¤ºï¼Œç¡®ä¿ç›´æ–¹å›¾å­˜åœ¨
const originalColorAdjusterShow = imageColorAdjuster.show;
imageColorAdjuster.show = function(image) {
    if (originalColorAdjusterShow) {
        originalColorAdjusterShow.call(this, image);
    }
    ImageHistogram.addHistogramsToColorAdjuster();
    ImageHistogram.onImageLoaded();
};

// ç¡®ä¿ç›´æ–¹å›¾åœ¨å›¾ç‰‡åŠ è½½åæ›´æ–°
const originalApplyColorAdjustmentsToPreview = imageColorAdjuster.applyColorAdjustmentsToPreview;
imageColorAdjuster.applyColorAdjustmentsToPreview = function() {
    originalApplyColorAdjustmentsToPreview.call(this);
    ImageHistogram.updateHistograms();
};

class PlacementGame {
    constructor() {
        this.folders = {};
        this.canvasItems = [];
        this.activeItem = null;
        this.layerCounter = 0;
        this.gameLayer = null;
        this.itemToImageMap = {}; // æ˜ å°„canvasItemåˆ°imgine.jsçš„image
        this.init();
    }

    init() {
        this.createGameLayer();
        this.setupDragAndDrop();
    }

    createGameLayer() {
        const container = document.getElementById('container');
        
        this.gameLayer = document.createElement('div');
        this.gameLayer.id = 'game-layer';
        this.gameLayer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            overflow: visible;
            pointer-events: none;
        `;
        
        container.appendChild(this.gameLayer);
    }

    setupDragAndDrop() {
        const vp = document.getElementById('viewport');
        
        vp.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        vp.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                this.processDragItems(e.dataTransfer.items);
            }
            
            // å¤„ç†å•ä¸ªæ–‡ä»¶çš„æ‹–æ‹½
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                this.processSingleFileDrag(e.dataTransfer.files, e.clientX, e.clientY);
            }
        });
    }
    
    processSingleFileDrag(files, clientX, clientY) {
        // æ£€æŸ¥å½“å‰åè®®
        const isFileProtocol = window.location.protocol === 'file:';
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            if (file.type.match(/image\//)) {
                // å¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼Œåˆ›å»ºæ–‡ä»¶å¤¹é¢æ¿ä½†ä¸è‡ªåŠ¨æ·»åŠ åˆ°ç”»å¸ƒ
                this.handleImageFile(file, clientX, clientY, false);
            }
        }
    }
    
    handleImageFile(file, clientX, clientY, autoAddToCanvas = true) {
        // ä¸ºæ‹–æ‹½çš„å›¾ç‰‡åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶å¤¹
        const tempFolderName = 'æ‹–æ‹½å›¾ç‰‡';
        if (!this.folders[tempFolderName]) {
            this.folders[tempFolderName] = {
                name: tempFolderName,
                images: [],
                panel: null
            };
            
            // åˆ›å»ºä¸´æ—¶æ–‡ä»¶å¤¹é¢æ¿
            const panel = document.createElement('div');
            panel.id = `folder-panel-${tempFolderName}`;
            panel.className = 'folder-panel';
            panel.style.cssText = `
                position: fixed;
                left: 10px;
                top: ${Object.keys(this.folders).length * 280}px;
                width: 240px;
                height: 260px;
                background: rgba(30, 30, 30, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                z-index: 1002;
                pointer-events: auto;
                display: flex;
                flex-direction: column;
            `;

            panel.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 12px 0 12px; cursor: move; user-select: none;">
                    <span style="color: #2196F3; font-size: 14px; font-weight: bold;">${tempFolderName}</span>
                    <span class="close-panel-btn" data-folder="${tempFolderName}" style="color: #ccc; font-size: 18px; cursor: pointer; line-height: 1;">Ã—</span>
                </div>
                <div class="image-grid" data-folder="${tempFolderName}" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; padding: 12px; flex: 1; overflow-y: auto;"></div>
            `;

            document.body.appendChild(panel);
            this.folders[tempFolderName].panel = panel;

            panel.querySelector('.close-panel-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.closeFolderPanel(tempFolderName);
            });

            this.makePanelDraggable(panel);
            
            // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨
            const grid = panel.querySelector('.image-grid');
            if (grid) {
                grid.addEventListener('scroll', () => {
                    this.handlePanelScroll(tempFolderName, panel);
                });
            }
        }
        
        // æ·»åŠ å›¾ç‰‡åˆ°ä¸´æ—¶æ–‡ä»¶å¤¹
        const imageId = Date.now() + Math.random();
        const reader = new FileReader();
        reader.onload = (event) => {
            const dataURL = event.target.result;
            this.folders[tempFolderName].images.push({
                id: imageId,
                name: file.name,
                file: file,
                src: dataURL
            });
            this.addImageToPanel(tempFolderName, imageId, file.name);
            
            // åªæœ‰åœ¨autoAddToCanvasä¸ºtrueæ—¶æ‰è‡ªåŠ¨å°†å›¾ç‰‡æ·»åŠ åˆ°ç”»å¸ƒ
            if (autoAddToCanvas) {
                this.createCanvasItem({
                    folder: tempFolderName,
                    imageId: imageId
                }, clientX, clientY);
            }
        };
        reader.readAsDataURL(file);
    }

    processDragItems(items) {
        // æ£€æŸ¥å½“å‰åè®®
        const isFileProtocol = window.location.protocol === 'file:';
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry();
                if (entry && entry.isDirectory) {
                    if (isFileProtocol) {
                        // åœ¨ file:// åè®®ä¸‹ï¼Œå°è¯•ç›´æ¥å¤„ç†æ‹–æ‹½çš„æ–‡ä»¶
                        this.handleLocalFolderDrag(items);
                    } else {
                        // åœ¨ http:// åè®®ä¸‹ï¼Œä½¿ç”¨åŸæ¥çš„æ–¹æ³•
                        this.createFolderPanel(entry);
                    }
                }
            }
        }
    }
    
    handleLocalFolderDrag(items) {
        // å°è¯•ç›´æ¥ä»æ‹–æ‹½äº‹ä»¶ä¸­è·å–æ–‡ä»¶
        const files = [];
        let folderName = 'æ–‡ä»¶å¤¹';
        let hasDirectory = false;
        
        // éå†æ‰€æœ‰æ‹–æ‹½é¡¹
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    if (entry.isDirectory) {
                        folderName = entry.name;
                        hasDirectory = true;
                    } else if (entry.isFile && entry.name.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
                        // å¦‚æœæ˜¯å›¾ç‰‡æ–‡ä»¶ï¼Œç›´æ¥æ·»åŠ 
                        entry.file(file => {
                            files.push(file);
                        });
                    }
                }
            }
        }
        
        // å»¶è¿Ÿæ£€æŸ¥ï¼Œç¡®ä¿æ‰€æœ‰æ–‡ä»¶éƒ½å·²å¤„ç†
        setTimeout(() => {
            if (files.length > 0) {
                this.handleFolderFiles(folderName, files);
            } else if (hasDirectory) {
                // å¦‚æœæ£€æµ‹åˆ°æ–‡ä»¶å¤¹ä½†æ²¡æœ‰è·å–åˆ°æ–‡ä»¶ï¼Œä½¿ç”¨æ–‡ä»¶è¾“å…¥ä½œä¸ºåå¤‡æ–¹æ¡ˆ
                this.createFileInputForFolder(folderName);
            }
        }, 100);
    }
    
    createFileInputForFolder(folderName) {
        // åˆ›å»ºä¸€ä¸ªéšè—çš„æ–‡ä»¶è¾“å…¥å…ƒç´ ï¼Œæ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.webkitdirectory = true;
        fileInput.multiple = true;
        fileInput.style.display = 'none';
        
        // è®¾ç½®æ–‡ä»¶è¾“å…¥çš„äº‹ä»¶å¤„ç†
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                // ç›´æ¥å¤„ç†é€‰æ‹©çš„æ–‡ä»¶ï¼Œæ— éœ€é¢å¤–ç¡®è®¤
                this.handleFolderFiles(folderName, files);
            }
            // ç§»é™¤ä¸´æ—¶æ–‡ä»¶è¾“å…¥
            document.body.removeChild(fileInput);
        });
        
        // æ·»åŠ åˆ°æ–‡æ¡£å¹¶è§¦å‘ç‚¹å‡»
        document.body.appendChild(fileInput);
        
        // å°è¯•è‡ªåŠ¨è§¦å‘ï¼Œå‡å°‘ç”¨æˆ·æ“ä½œ
        try {
            fileInput.click();
        } catch (error) {
            console.log('è‡ªåŠ¨è§¦å‘æ–‡ä»¶é€‰æ‹©å¤±è´¥ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©');
        }
    }
    
    handleFolderFiles(folderName, files) {
        // æ£€æŸ¥æ–‡ä»¶å¤¹æ˜¯å¦å·²å­˜åœ¨
        if (this.folders[folderName]) {
            return;
        }

        this.folders[folderName] = {
            name: folderName,
            images: [],
            panel: null
        };

        const panel = document.createElement('div');
        panel.id = `folder-panel-${folderName}`;
        panel.className = 'folder-panel';
        panel.style.cssText = `
            position: fixed;
            left: 10px;
            top: ${Object.keys(this.folders).length * 280}px;
            width: 240px;
            height: 260px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            z-index: 1002;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        `;

        panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 12px 0 12px; cursor: move; user-select: none;">
                <span style="color: #2196F3; font-size: 14px; font-weight: bold;">${folderName}</span>
                <span class="close-panel-btn" data-folder="${folderName}" style="color: #ccc; font-size: 18px; cursor: pointer; line-height: 1;">Ã—</span>
            </div>
            <div class="image-grid" data-folder="${folderName}" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; padding: 12px; flex: 1; overflow-y: auto;"></div>
        `;

        document.body.appendChild(panel);
        this.folders[folderName].panel = panel;

        panel.querySelector('.close-panel-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeFolderPanel(folderName);
        });

        this.makePanelDraggable(panel);
        
        // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨
        const grid = panel.querySelector('.image-grid');
        if (grid) {
            grid.addEventListener('scroll', () => {
                this.handlePanelScroll(folderName, panel);
            });
        }
        
        // å¤„ç†æ–‡ä»¶
        Array.from(files).forEach(file => {
            if (file.name.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
                const imageId = Date.now() + Math.random();
                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataURL = event.target.result;
                    this.folders[folderName].images.push({
                        id: imageId,
                        name: file.name,
                        file: file,
                        src: dataURL
                    });
                    this.addImageToPanel(folderName, imageId, file.name);
                };
                reader.readAsDataURL(file);
            }
        });
    }

    createFolderPanel(directory) {
        const folderName = directory.name;
        if (this.folders[folderName]) {
            return;
        }

        this.folders[folderName] = {
            name: folderName,
            images: [],
            panel: null
        };

        const panel = document.createElement('div');
        panel.id = `folder-panel-${folderName}`;
        panel.className = 'folder-panel';
        panel.style.cssText = `
            position: fixed;
            left: 10px;
            top: ${Object.keys(this.folders).length * 280}px;
            width: 240px;
            height: 260px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            z-index: 1002;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        `;

        panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 12px 0 12px; cursor: move; user-select: none;">
                <span style="color: #2196F3; font-size: 14px; font-weight: bold;">${folderName}</span>
                <span class="close-panel-btn" data-folder="${folderName}" style="color: #ccc; font-size: 18px; cursor: pointer; line-height: 1;">Ã—</span>
            </div>
            <div class="image-grid" data-folder="${folderName}" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; padding: 12px; flex: 1; overflow-y: auto;"></div>
        `;

        document.body.appendChild(panel);
        this.folders[folderName].panel = panel;

        panel.querySelector('.close-panel-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeFolderPanel(folderName);
        });

        this.makePanelDraggable(panel);
        this.loadFolderContent(directory, folderName);

        // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬å™¨ï¼Œå®ç°æ‡’åŠ è½½
        const grid = panel.querySelector('.image-grid');
        if (grid) {
            grid.addEventListener('scroll', () => {
                this.handlePanelScroll(folderName, panel);
            });
        }
    }

    makePanelDraggable(panel) {
        const header = panel.querySelector('div:first-child');
        let isDragging = false;
        let startX, startY, offsetX, offsetY;

        header.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('close-panel-btn')) return;
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = panel.getBoundingClientRect();
            offsetX = startX - rect.left;
            offsetY = startY - rect.top;
            panel.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                panel.style.left = (e.clientX - offsetX) + 'px';
                panel.style.top = (e.clientY - offsetY) + 'px';
                panel.style.transform = 'none';
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            panel.style.cursor = 'move';
        });
    }

    loadFolderContent(directory, folderName) {
        const reader = directory.createReader();

        const readEntries = () => {
            reader.readEntries((entries) => {
                if (entries.length) {
                    entries.forEach(entry => {
                        if (entry.isFile && entry.name.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
                            entry.file(file => {
                                const imageId = Date.now() + Math.random();
                                this.folders[folderName].images.push({
                                    id: imageId,
                                    name: file.name,
                                    file: file, // ä¿å­˜æ–‡ä»¶å¯¹è±¡ï¼Œä¸ç«‹å³è¯»å–
                                    src: null // åˆå§‹åŒ–ä¸ºnullï¼Œåç»­æ‡’åŠ è½½
                                });
                                this.addImageToPanel(folderName, imageId, file.name);
                            });
                        }
                    });
                    setTimeout(readEntries, 0);
                }
            });
        };

        readEntries();
    }

    addImageToPanel(folderName, imageId, name) {
        const panel = this.folders[folderName].panel;
        if (!panel) return;

        const grid = panel.querySelector('.image-grid');
        const item = document.createElement('div');
        item.className = 'game-image-item';
        item.draggable = true;
        item.dataset.folder = folderName;
        item.dataset.imageId = imageId;
        item.style.cssText = `
            width: 70px;
            height: 70px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 3px;
            overflow: hidden;
            cursor: grab;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        `;

        // åˆ›å»ºå ä½ç¬¦
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        placeholder.style.cssText = `
            color: #666;
            font-size: 12px;
            text-align: center;
            padding: 10px;
            word-break: break-all;
        `;
        placeholder.textContent = name;

        const img = document.createElement('img');
        img.alt = name;
        img.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none; /* åˆå§‹éšè—ï¼Œæ‡’åŠ è½½åæ˜¾ç¤º */
        `;

        item.appendChild(placeholder);
        item.appendChild(img);
        grid.appendChild(item);

        item.addEventListener('dragstart', (e) => {
            // ç¡®ä¿åœ¨æ‹–æ‹½å‰åŠ è½½å›¾ç‰‡
            this.loadImageIfNeeded(folderName, imageId, img);
            
            e.dataTransfer.setData('text/plain', JSON.stringify({
                folder: folderName,
                imageId: imageId
            }));
            item.style.opacity = '0.5';
            e.stopPropagation();
        });

        item.addEventListener('dragend', () => {
            item.style.opacity = '1';
        });
    }

    closeFolderPanel(folderName) {
        const panel = this.folders[folderName].panel;
        if (panel) {
            panel.remove();
        }
        delete this.folders[folderName];
    }

    loadImageIfNeeded(folderName, imageId, imgElement) {
        const folder = this.folders[folderName];
        if (!folder) return;

        const image = folder.images.find(img => img.id == imageId);
        if (!image) return;

        // å¦‚æœå›¾ç‰‡å·²ç»åŠ è½½ï¼Œç›´æ¥è¿”å›
        if (image.src) {
            if (imgElement) {
                imgElement.src = image.src;
                imgElement.style.display = 'block';
                const placeholder = imgElement.previousElementSibling;
                if (placeholder && placeholder.className === 'image-placeholder') {
                    placeholder.style.display = 'none';
                }
            }
            return;
        }

        // å¦åˆ™åŠ è½½å›¾ç‰‡
        if (image.file) {
            // ä½¿ç”¨FileReaderè¯»å–ä¸ºDataURLï¼Œç¡®ä¿å›¾ç‰‡æ•°æ®èƒ½è¢«ä¿å­˜
            const reader = new FileReader();
            reader.onload = (event) => {
                const dataURL = event.target.result;
                image.src = dataURL;
                if (imgElement) {
                    imgElement.src = dataURL;
                    imgElement.style.display = 'block';
                    const placeholder = imgElement.previousElementSibling;
                    if (placeholder && placeholder.className === 'image-placeholder') {
                        placeholder.style.display = 'none';
                    }
                }
            };
            reader.readAsDataURL(image.file);
        }
    }

    handlePanelScroll(folderName, panel) {
        const grid = panel.querySelector('.image-grid');
        if (!grid) return;

        const items = grid.querySelectorAll('.game-image-item');
        const panelRect = panel.getBoundingClientRect();

        items.forEach(item => {
            const itemRect = item.getBoundingClientRect();
            
            // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦åœ¨å¯è§†åŒºåŸŸå†…
            if (itemRect.top < panelRect.bottom + 100 && itemRect.bottom > panelRect.top - 100) {
                const imageId = item.dataset.imageId;
                const imgElement = item.querySelector('img');
                if (imageId && imgElement) {
                    this.loadImageIfNeeded(folderName, imageId, imgElement);
                }
            }
        });
    }

    createCanvasItem(itemData, clientX, clientY) {
        const folder = this.folders[itemData.folder];
        if (!folder) return;

        const image = folder.images.find(img => img.id == itemData.imageId);
        if (!image) return;

        // ç¡®ä¿å›¾ç‰‡å·²ç»åŠ è½½
        if (!image.src && image.file) {
            // ä½¿ç”¨FileReaderè¯»å–ä¸ºDataURLï¼Œç¡®ä¿å›¾ç‰‡æ•°æ®èƒ½è¢«ä¿å­˜
            const reader = new FileReader();
            reader.onload = (event) => {
                const dataURL = event.target.result;
                image.src = dataURL;
                this.createCanvasItemWithLoadedImage(itemData, clientX, clientY, image);
            };
            reader.readAsDataURL(image.file);
            return;
        }

        this.createCanvasItemWithLoadedImage(itemData, clientX, clientY, image);
    }

    createCanvasItemWithLoadedImage(itemData, clientX, clientY, image) {
        const container = document.getElementById('container');
        const containerRect = container.getBoundingClientRect();
        
        // è®¡ç®—åœ¨containerå†…çš„åæ ‡ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œå¹³ç§»ï¼‰
        const appInstance = window.app;
        let zoom = appInstance ? appInstance.zoom : 1;
        let panX = appInstance ? appInstance.panX : 0;
        let panY = appInstance ? appInstance.panY : 0;
        
        // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºcontainerå†…çš„ä¸–ç•Œåæ ‡
        const worldX = (clientX - containerRect.left - panX) / zoom;
        const worldY = (clientY - containerRect.top - panY) / zoom;
        
        const itemId = Date.now();

        const canvasItem = {
            id: itemId,
            folder: itemData.folder,
            imageId: itemData.imageId,
            x: worldX,
            y: worldY,
            scale: 1,
            rotation: 0,
            src: image.src
        };

        this.canvasItems.push(canvasItem);

        // åªä½¿ç”¨imgine.jsçš„addImageæ–¹æ³•æ·»åŠ å›¾ç‰‡ï¼Œä¸å†åˆ›å»ºè‡ªå·±çš„å›¾ç‰‡å…ƒç´ 
        if (window.imageHandler && imageHandler.addImage) {
            // ä½¿ç”¨imgine.jsçš„addImageæ–¹æ³•æ·»åŠ å›¾ç‰‡
            const imgineImageId = imageHandler.addImage(image.src, worldX, worldY);
            // å»ºç«‹æ˜ å°„å…³ç³»
            this.itemToImageMap[itemId] = imgineImageId;
        }

        // ä¸å†åˆ›å»ºè‡ªå·±çš„å›¾ç‰‡å…ƒç´ ï¼Œç›´æ¥ä½¿ç”¨imgine.jsçš„å›¾ç‰‡
        // ä¸å†è°ƒç”¨selectItemå’ŒcreateItemControlsï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨imgine.jsçš„æ§åˆ¶é¢æ¿
    }

    selectItem(element) {
        if (this.activeItem) {
            this.activeItem.style.outline = 'none';
        }
        
        this.activeItem = element;
        this.activeItem.style.outline = '2px solid #2196F3';
        
        const itemId = parseInt(element.dataset.itemId);
        const item = this.canvasItems.find(i => i.id === itemId);
        if (item) {
            this.createItemControls(item);
            
            // åŒæ—¶é€‰æ‹©å¯¹åº”çš„imgine.jsçš„image
            if (window.imageHandler && imageHandler.selectImage && this.itemToImageMap[itemId]) {
                const imgineImageId = this.itemToImageMap[itemId];
                imageHandler.selectImage(imgineImageId);
            }
        }
    }

    updateItemPosition(element, item) {
        element.style.left = item.x + 'px';
        element.style.top = item.y + 'px';
    }

    // ä¸å†éœ€è¦createItemControlsæ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨imgine.jsçš„æ§åˆ¶é¢æ¿
    createItemControls(item) {
        // ç©ºå®ç°ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨imgine.jsçš„æ§åˆ¶é¢æ¿
    }

    // ä¸å†éœ€è¦updateItemDisplayæ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨imgine.jsçš„å›¾ç‰‡
    updateItemDisplay(item) {
        // ç©ºå®ç°ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨imgine.jsçš„å›¾ç‰‡
    }

    // ä¸å†éœ€è¦å›¾å±‚æ§åˆ¶æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬å°†åœ¨imgine.jsä¸­å®ç°è¿™äº›åŠŸèƒ½
    changeLayer(item, direction) {
        // ç©ºå®ç°
    }

    bringToTop(item) {
        // ç©ºå®ç°
    }

    bringToBottom(item) {
        // ç©ºå®ç°
    }

    deleteItem(item) {
        // åªåˆ é™¤å¯¹åº”çš„imgine.jsçš„image
        if (window.imageHandler && imageHandler.deleteImage && this.itemToImageMap[item.id]) {
            const imgineImageId = this.itemToImageMap[item.id];
            imageHandler.deleteImage(imgineImageId);
            // æ¸…ç†æ˜ å°„å…³ç³»
            delete this.itemToImageMap[item.id];
        }

        this.canvasItems = this.canvasItems.filter(i => i.id !== item.id);

        if (this.activeItem && this.activeItem.dataset.itemId == item.id) {
            this.activeItem = null;
        }
    }
}

(function() {
    // åªä¿ç•™dragoverå’Œdropäº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºå¤„ç†ä»æ–‡ä»¶å¤¹é¢æ¿æ‹–æ‹½å›¾ç‰‡åˆ°ç”»å¸ƒ
    const viewport = document.getElementById('viewport');
    if (viewport) {
        viewport.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        viewport.addEventListener('drop', (e) => {
            e.preventDefault();
            const data = e.dataTransfer.getData('text/plain');
            try {
                const itemData = JSON.parse(data);
                if (itemData.folder && itemData.imageId && window.placementGame) {
                    window.placementGame.createCanvasItem(itemData, e.clientX, e.clientY);
                }
            } catch (error) {
                console.error('Failed to parse drag data:', error);
            }
        });
    }
})();

window.addEventListener('load', () => {
    window.placementGame = new PlacementGame();
});


// storage.js - ç‹¬ç«‹çš„å­˜å‚¨ç³»ç»Ÿæ¨¡å—
const StorageSystem = {
    // å­˜å‚¨é”®å
    STORAGE_KEY: 'flow_v3_3',
    
    // å½“å‰åº”ç”¨å®ä¾‹å¼•ç”¨ï¼ˆå°†åœ¨åˆå§‹åŒ–æ—¶è®¾ç½®ï¼‰
    app: null,
    
    // ç»˜ç”»ç®¡ç†å™¨å¼•ç”¨
    drawingManager: null,
    
    // å›¾ç‰‡å¤„ç†å™¨å¼•ç”¨
    imageHandler: null,
    
    // åˆå§‹åŒ–å­˜å‚¨ç³»ç»Ÿ
    init(appInstance, drawingManagerInstance, imageHandlerInstance) {
        this.app = appInstance;
        this.drawingManager = drawingManagerInstance;
        this.imageHandler = imageHandlerInstance;
        console.log('å­˜å‚¨ç³»ç»Ÿå·²åˆå§‹åŒ–');
    },
    
    // --- å®æ—¶ä¿å­˜å’ŒåŠ è½½ï¼ˆä½¿ç”¨localStorageï¼‰---
    
    // ä¿å­˜å½“å‰çŠ¶æ€åˆ°localStorage
    save() {
        try {
            const data = {
                // èŠ‚ç‚¹æ•°æ®
                n: this.app.nodes,
                // è¿æ¥æ•°æ®
                c: this.app.conns,
                // è§†å›¾çŠ¶æ€
                x: this.app.panX,
                y: this.app.panY,
                z: this.app.zoom,
                // ç»˜ç”»æ•°æ®
                d: this.drawingManager ? this.drawingManager.paths : [],
                // emojiæ•°æ®
                e: this.drawingManager ? this.drawingManager.emojis : [],
                // å›¾ç‰‡æ•°æ®ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                i: this.imageHandler ? this.imageHandler.images : []
            };
            
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
            console.log('çŠ¶æ€å·²ä¿å­˜åˆ°localStorage');
        } catch (error) {
            console.error('ä¿å­˜çŠ¶æ€å¤±è´¥:', error);
        }
    },
    
    // ä»localStorageåŠ è½½çŠ¶æ€
    load() {
        try {
            const savedData = localStorage.getItem(this.STORAGE_KEY);
            if (!savedData) {
                console.log('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„æ•°æ®');
                return false;
            }
            
            const data = JSON.parse(savedData);
            
            // æ¢å¤è§†å›¾çŠ¶æ€
            this.app.panX = data.x || 0;
            this.app.panY = data.y || 0;
            this.app.zoom = data.z || 1;
            
            // æ¸…ç©ºç°æœ‰æ•°æ®
            this.app.nodes = [];
            this.app.conns = [];
            this.app.nodeMap.clear();
            this.app.layer.innerHTML = '';
            this.app.svgGroup.innerHTML = '';
            
            // é‡æ–°åˆ›å»ºæ‰€æœ‰èŠ‚ç‚¹
            if (data.n && Array.isArray(data.n)) {
                data.n.forEach(n => {
                    this.app.createNode(n.id, n.x, n.y, n.w, n.h, n.name, n.code, n.isInstance, n.originalId);
                });
            }
            
            // è¿‡æ»¤æ‰è¿æ¥åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„è¿æ¥ï¼Œé˜²æ­¢æ­»å¾ªç¯
            if (data.c && Array.isArray(data.c)) {
                this.app.conns = data.c.filter(conn => {
                    const toNodeIndex = this.app.nodes.findIndex(n => n.id === conn.to);
                    return toNodeIndex !== 0;
                });
            }
            
            // åŠ è½½ç»˜ç”»æ•°æ®
            if (this.drawingManager && data.d && Array.isArray(data.d)) {
                this.drawingManager.paths = data.d;
                this.drawingManager.renderAllDrawingPaths();
            }
            
            // åŠ è½½emojiæ•°æ®
            if (this.drawingManager && data.e && Array.isArray(data.e)) {
                // æ¸…ç©ºç°æœ‰emoji
                this.drawingManager.emojis.forEach(emoji => {
                    if (emoji.element && emoji.element.parentNode) {
                        emoji.element.parentNode.removeChild(emoji.element);
                    }
                });
                this.drawingManager.emojis = [];
                
                // é‡æ–°åˆ›å»ºæ‰€æœ‰emoji
                const container = document.getElementById('container');
                data.e.forEach(emojiData => {
                    const emojiElement = document.createElement('div');
                    emojiElement.textContent = emojiData.emoji;
                    emojiElement.style.position = 'absolute';
                    emojiElement.style.left = `${emojiData.x}px`;
                    emojiElement.style.top = `${emojiData.y}px`;
                    emojiElement.style.fontSize = '50px';
                    emojiElement.style.cursor = 'move';
                    emojiElement.style.zIndex = '20';
                    emojiElement.style.userSelect = 'none';
                    emojiElement.className = 'emoji-item';
                    emojiElement.dataset.emojiId = emojiData.id;
                    
                    // æ·»åŠ åˆ°ç”»å¸ƒ
                    container.appendChild(emojiElement);
                    
                    // æ·»åŠ åˆ°emojisæ•°ç»„
                    this.drawingManager.emojis.push({
                        id: emojiData.id,
                        element: emojiElement,
                        x: emojiData.x,
                        y: emojiData.y,
                        emoji: emojiData.emoji
                    });
                    
                    // ä¸ºemojiå…ƒç´ æ·»åŠ äº¤äº’åŠŸèƒ½
                    this.drawingManager.makeEmojiInteractive(emojiElement);
                });
            }
            
            // åŠ è½½å›¾ç‰‡æ•°æ®
            if (this.imageHandler && data.i && Array.isArray(data.i)) {
                this.imageHandler.images = data.i || [];
                // é‡æ–°æ¸²æŸ“æ‰€æœ‰å›¾ç‰‡
                this.imageHandler.images.forEach(image => {
                    this.imageHandler.renderImage(image);
                });
            }
            
            // æ›´æ–°è§†å›¾
            this.app.updateTransform();
            this.app.renderConns();
            this.app.updateMinimap();
            
            console.log('çŠ¶æ€å·²ä»localStorageåŠ è½½');
            return true;
        } catch (error) {
            console.error('åŠ è½½çŠ¶æ€å¤±è´¥:', error);
            return false;
        }
    },
    
    // æ¸…ç©ºæ‰€æœ‰å­˜å‚¨æ•°æ®
    clearAll() {
        if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿ")) {
            AudioSystem.playDeleteSound();
            localStorage.clear();
            location.reload();
        }
    },
    
    // --- JSONæ–‡ä»¶å¯¼å‡ºå’Œå¯¼å…¥ ---
    
    // å¯¼å‡ºæ•°æ®ä¸ºJSONæ–‡ä»¶
    exportJson() {
        const now = Date.now();
        // æ£€æŸ¥å¯¼å‡ºé—´éš”ï¼Œé™åˆ¶ä¸º1ç§’ï¼ˆ1000æ¯«ç§’ï¼‰
        if (now - this.app.lastExportTime < 1000) {
            // å¯¼å‡ºè¿‡äºé¢‘ç¹ï¼Œæ˜¾ç¤ºæç¤º
            if (window.FXManager) {
                FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ff0000', 50);
            }
            return;
        }
        
        try {
            const data = {
                nodes: this.app.nodes,
                conns: this.app.conns,
                panX: this.app.panX,
                panY: this.app.panY,
                zoom: this.app.zoom,
                drawing: this.drawingManager ? this.drawingManager.paths : [],
                emojis: this.drawingManager ? this.drawingManager.emojis : [],
                images: this.imageHandler ? this.imageHandler.images : []
            };
            
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // ä½¿ç”¨æ›´æ˜“è¯»çš„æ—¶é—´æ ¼å¼ï¼šYYYY-MM-DD-HH-mm-ss
            const date = new Date();
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            const fileName = `flow-${year}-${month}-${day}-${hours}-${minutes}-${seconds}.json`;
            a.download = fileName;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // æ˜¾ç¤ºæˆåŠŸç‰¹æ•ˆ
            if (window.FXManager) {
                FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#00ff00', 50);
            }
            
            // æ›´æ–°ä¸Šæ¬¡å¯¼å‡ºæ—¶é—´
            this.app.lastExportTime = now;
            
            console.log('æ•°æ®å·²å¯¼å‡ºä¸ºJSONæ–‡ä»¶');
        } catch (error) {
            console.error('å¯¼å‡ºJSONæ–‡ä»¶å¤±è´¥:', error);
            if (window.FXManager) {
                FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ff0000', 50);
            }
        }
    },
    
    // è§¦å‘æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ä»¥å¯¼å…¥JSON
    importJson() {
        const now = Date.now();
        // æ£€æŸ¥å¯¼å…¥é—´éš”ï¼Œé™åˆ¶ä¸º1ç§’ï¼ˆ1000æ¯«ç§’ï¼‰
        if (now - this.app.lastExportTime < 1000) {
            // å¯¼å…¥è¿‡äºé¢‘ç¹ï¼Œæ˜¾ç¤ºæç¤º
            if (window.FXManager) {
                FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ff0000', 50);
            }
            return;
        }
        
        // åˆ›å»ºæ–‡ä»¶è¾“å…¥å…ƒç´ 
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.style.display = 'none';
        
        input.onchange = (event) => {
            this.handleFileImport(event);
        };
        
        document.body.appendChild(input);
        input.click();
        document.body.removeChild(input);
        
        // æ›´æ–°ä¸Šæ¬¡å¯¼å‡º/å¯¼å…¥æ—¶é—´
        this.app.lastExportTime = now;
    },
    
    // å¤„ç†æ–‡ä»¶å¯¼å…¥
    handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                this.loadFromJson(data);
                
                // æ˜¾ç¤ºæˆåŠŸç‰¹æ•ˆ
                if (window.FXManager) {
                    FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#00ff00', 50);
                }
            } catch (error) {
                alert('å¯¼å…¥å¤±è´¥ï¼šæ— æ•ˆçš„JSONæ–‡ä»¶');
                console.error('å¯¼å…¥JSONæ–‡ä»¶å¤±è´¥:', error);
                
                // æ˜¾ç¤ºå¤±è´¥ç‰¹æ•ˆ
                if (window.FXManager) {
                    FXManager.spawn(window.innerWidth / 2, window.innerHeight / 2, '#ff0000', 50);
                }
            }
        };
        reader.readAsText(file);
    },
    
    // ä»JSONæ•°æ®åŠ è½½ç”»å¸ƒå†…å®¹
    loadFromJson(data) {
        // æ¸…ç©ºç°æœ‰èŠ‚ç‚¹å’Œæ˜ å°„è¡¨
        this.app.nodes = [];
        this.app.nodeMap.clear();
        this.app.conns = [];
        this.app.layer.innerHTML = '';
        this.app.svgGroup.innerHTML = '';
        
        // è®¾ç½®è§†å›¾çŠ¶æ€
        this.app.panX = data.panX || 0;
        this.app.panY = data.panY || 0;
        this.app.zoom = data.zoom || 1;
        
        // é‡æ–°åˆ›å»ºæ‰€æœ‰èŠ‚ç‚¹
        if (data.nodes && Array.isArray(data.nodes)) {
            data.nodes.forEach(n => {
                this.app.createNode(n.id, n.x, n.y, n.w, n.h, n.name, n.code, n.isInstance, n.originalId);
            });
        }
        
        // è®¾ç½®è¿æ¥
        if (data.conns && Array.isArray(data.conns)) {
            this.app.conns = data.conns.filter(conn => {
                const toNodeIndex = this.app.nodes.findIndex(n => n.id === conn.to);
                return toNodeIndex !== 0;
            });
        }
        
        // åŠ è½½ç»˜ç”»æ•°æ®
        if (this.drawingManager) {
            if (data.drawing && Array.isArray(data.drawing)) {
                this.drawingManager.paths = data.drawing;
            } else if (data.d && Array.isArray(data.d)) {
                // å…¼å®¹æ—§ç‰ˆæœ¬æ•°æ®
                this.drawingManager.paths = data.d;
            }
            this.drawingManager.renderAllDrawingPaths();
        }
        
        // åŠ è½½emojiæ•°æ®
        if (this.drawingManager) {
            // å…ˆæ¸…ç©ºç°æœ‰emoji
            this.drawingManager.emojis.forEach(emoji => {
                if (emoji.element && emoji.element.parentNode) {
                    emoji.element.parentNode.removeChild(emoji.element);
                }
            });
            this.drawingManager.emojis = [];
            
            // ä»ä¸åŒæ¥æºåŠ è½½emojiæ•°æ®
            let emojiDataArray = [];
            if (data.emojis && Array.isArray(data.emojis)) {
                emojiDataArray = data.emojis;
            } else if (data.e && Array.isArray(data.e)) {
                // å…¼å®¹æ—§ç‰ˆæœ¬æ•°æ®
                emojiDataArray = data.e;
            }
            
            // é‡æ–°åˆ›å»ºæ‰€æœ‰emoji
            if (emojiDataArray.length > 0) {
                const container = document.getElementById('container');
                emojiDataArray.forEach(emojiData => {
                    const emojiElement = document.createElement('div');
                    emojiElement.textContent = emojiData.emoji;
                    emojiElement.style.position = 'absolute';
                    emojiElement.style.left = `${emojiData.x}px`;
                    emojiElement.style.top = `${emojiData.y}px`;
                    emojiElement.style.fontSize = '50px';
                    emojiElement.style.cursor = 'move';
                    emojiElement.style.zIndex = '20';
                    emojiElement.style.userSelect = 'none';
                    emojiElement.className = 'emoji-item';
                    emojiElement.dataset.emojiId = emojiData.id;
                    
                    // æ·»åŠ åˆ°ç”»å¸ƒ
                    container.appendChild(emojiElement);
                    
                    // æ·»åŠ åˆ°emojisæ•°ç»„
                    this.drawingManager.emojis.push({
                        id: emojiData.id,
                        element: emojiElement,
                        x: emojiData.x,
                        y: emojiData.y,
                        emoji: emojiData.emoji
                    });
                    
                    // ä¸ºemojiå…ƒç´ æ·»åŠ äº¤äº’åŠŸèƒ½
                    this.drawingManager.makeEmojiInteractive(emojiElement);
                });
            }
        }
        
        // åŠ è½½å›¾ç‰‡æ•°æ®
        if (this.imageHandler && data.images && Array.isArray(data.images)) {
            this.imageHandler.images = data.images;
            // é‡æ–°æ¸²æŸ“æ‰€æœ‰å›¾ç‰‡
            this.imageHandler.images.forEach(image => {
                this.imageHandler.renderImage(image);
            });
        }
        
        this.app.updateTransform();
        this.app.renderConns();
        this.save(); // ä¿å­˜åˆ°localStorage
        this.app.updateMinimap();
        
        console.log('æ•°æ®å·²ä»JSONæ–‡ä»¶åŠ è½½');
    },
    
    // è·å–å½“å‰çŠ¶æ€çš„JSONå­—ç¬¦ä¸²ï¼ˆä¸ä¿å­˜ä¸ºæ–‡ä»¶ï¼‰
    getStateAsJson() {
        const data = {
            nodes: this.app.nodes,
            conns: this.app.conns,
            panX: this.app.panX,
            panY: this.app.panY,
            zoom: this.app.zoom,
            drawing: this.drawingManager ? this.drawingManager.paths : [],
            emojis: this.drawingManager ? this.drawingManager.emojis : [],
            images: this.imageHandler ? this.imageHandler.images : []
        };
        
        return JSON.stringify(data, null, 2);
    },
    
    // ä»JSONå­—ç¬¦ä¸²åŠ è½½çŠ¶æ€ï¼ˆä¸ä»æ–‡ä»¶ï¼‰
    loadFromJsonString(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            this.loadFromJson(data);
            return true;
        } catch (error) {
            console.error('ä»JSONå­—ç¬¦ä¸²åŠ è½½å¤±è´¥:', error);
            return false;
        }
    },
    
    // å¤‡ä»½å½“å‰çŠ¶æ€ï¼ˆè¿”å›å¤‡ä»½IDï¼‰
    backup() {
        const backupId = 'backup_' + Date.now();
        const backupData = this.getStateAsJson();
        localStorage.setItem(backupId, backupData);
        console.log(`å·²åˆ›å»ºå¤‡ä»½: ${backupId}`);
        return backupId;
    },
    
    // ä»å¤‡ä»½æ¢å¤
    restore(backupId) {
        const backupData = localStorage.getItem(backupId);
        if (!backupData) {
            console.error(`å¤‡ä»½ä¸å­˜åœ¨: ${backupId}`);
            return false;
        }
        
        return this.loadFromJsonString(backupData);
    },
    
    // è·å–æ‰€æœ‰å¤‡ä»½åˆ—è¡¨
    getBackupList() {
        const backups = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('backup_')) {
                backups.push(key);
            }
        }
        return backups.sort().reverse(); // æœ€æ–°çš„åœ¨å‰é¢
    },
    
    // åˆ é™¤å¤‡ä»½
    deleteBackup(backupId) {
        localStorage.removeItem(backupId);
        console.log(`å·²åˆ é™¤å¤‡ä»½: ${backupId}`);
    }
};

// æš´éœ²ç»™å…¨å±€
window.StorageSystem = StorageSystem;


const CutImgSystem = {
    init() {
        this.createPanel();
        this.setupEventListeners();
    },

    createPanel() {
        const panel = document.createElement('div');
        panel.id = 'cutimg-panel';
        panel.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            backdrop-filter: blur(5px);
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            height: 90%;
            max-height: 800px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        `;

        content.innerHTML = `
            <style>
                * { box-sizing: border-box; margin: 0; padding: 0; }
                :root {
                    --red-main: #B72A2A;
                    --green-main: #2E8B57;
                    --red-light: #d9544f;
                    --green-light: #4aaa7a;
                }
                #cutimg-panel header {
                    background: var(--red-main);
                    color: white;
                    padding: 28px;
                    text-align: center;
                    flex-shrink: 0;
                    box-shadow: 0 4px 12px rgba(183,42,42,0.2);
                    transition: background 0.5s ease;
                    position: relative;
                }
                #cutimg-panel header h1 { font-size: 30px; font-weight: 600; letter-spacing: 2px; }
                #cutimg-panel .tabs {
                    display: flex;
                    background: #fff;
                    border-bottom: 1px solid #eee;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                }
                #cutimg-panel .tab {
                    flex: 1;
                    padding: 18px;
                    text-align: center;
                    cursor: pointer;
                    font-size: 18px;
                    font-weight: 500;
                    transition: all 0.3s;
                    position: relative;
                }
                #cutimg-panel .tab:hover { background: #f5f5f5; }
                #cutimg-panel .tab.active {
                    color: var(--red-main);
                    background: #fff8f6;
                }
                #cutimg-panel .tab.active::after {
                    content: '';
                    position: absolute;
                    bottom: 0; left: 0; width: 100%; height: 4px;
                    background: var(--red-main);
                }
                #cutimg-panel .tab:nth-child(2).active { 
                    color: var(--green-main); 
                    background: #f6fdf8; 
                }
                #cutimg-panel .tab:nth-child(2).active::after { background: var(--green-main); }
                #cutimg-panel .controls {
                    padding: 20px 28px;
                    background: #fff;
                    text-align: center;
                    flex-shrink: 0;
                    border-bottom: 1px solid #eee;
                    display: flex;
                    flex-wrap: wrap;
                    gap: 16px;
                    align-items: center;
                    justify-content: center;
                }
                #cutimg-panel .btn {
                    padding: 14px 36px;
                    font-size: 18px;
                    border: none;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.3s;
                    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
                    font-weight: 500;
                    color: white;
                }
                #cutimg-panel .split-mode .btn { background: var(--red-main); }
                #cutimg-panel .split-mode .btn:hover { background: var(--red-light); transform: translateY(-3px); }
                #cutimg-panel .combine-mode .btn { background: var(--green-main); }
                #cutimg-panel .combine-mode .btn:hover { background: var(--green-light); transform: translateY(-3px); }
                #cutimg-panel .btn.small { padding: 10px 28px; font-size: 15px; }
                #cutimg-panel .btn:disabled { background: #bbb; cursor: not-allowed; transform: none; box-shadow: none; }
                #cutimg-panel .main {
                    flex: 1;
                    display: flex;
                    overflow: hidden;
                }
                #cutimg-panel .panel {
                    flex: 1;
                    display: none;
                    overflow: hidden;
                }
                #cutimg-panel .panel.active {
                    display: flex;
                }
                #cutimg-panel .split-left {
                    width: 320px;
                    background: #fff;
                    border-right: 1px solid #eee;
                    display: flex;
                    flex-direction: column;
                    overflow-y: auto;
                    box-shadow: 2px 0 10px rgba(0,0,0,0.05);
                }
                #cutimg-panel .split-right {
                    flex: 1;
                    overflow-y: auto;
                    padding: 28px;
                    background: #fff8f6;
                    transition: background 0.5s;
                }
                #cutimg-panel .combine-mode .split-right {
                    background: #f6fdf8;
                }
                #cutimg-panel .section {
                    padding: 28px;
                    text-align: center;
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                }
                #cutimg-panel .section h2 {
                    margin-bottom: 24px;
                    font-size: 22px;
                    color: var(--red-main);
                    transition: color 0.5s;
                }
                #cutimg-panel .combine-mode .section h2 {
                    color: var(--green-main);
                }
                #cutimg-panel #originalCanvas {
                    max-height: 70vh;
                    max-width: 420px;
                    border-radius: 16px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
                    background: #f0f0f0;
                    margin: 0 auto;
                }
                #cutimg-panel #preview {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                    gap: 24px;
                }
                #cutimg-panel .item {
                    background: white;
                    border-radius: 18px;
                    padding: 20px;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.08);
                    transition: all 0.3s;
                }
                #cutimg-panel .item:hover {
                    transform: translateY(-10px);
                    box-shadow: 0 20px 40px rgba(0,0,0,0.12);
                }
                #cutimg-panel .preview-box {
                    width: 200px;
                    height: 200px;
                    margin: 0 auto 15px;
                    background: #f8f8f8;
                    border-radius: 12px;
                    overflow: hidden;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 6px 16px rgba(0,0,0,0.1);
                }
                #cutimg-panel .preview-box canvas {
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                }
                #cutimg-panel .info {
                    font-size: 16px;
                    color: #555;
                    margin: 14px 0 20px;
                }
                #cutimg-panel .count-info {
                    text-align: center;
                    font-size: 20px;
                    margin-bottom: 20px;
                    font-weight: 500;
                    color: var(--red-main);
                    transition: color 0.5s;
                }
                #cutimg-panel .checkbox-container {
                    margin-top: 12px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                    font-size: 15px;
                    color: #555;
                }
                #cutimg-panel .checkbox-container input[type="checkbox"] {
                    width: 18px;
                    height: 18px;
                    cursor: pointer;
                }
                #cutimg-panel .combine-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    padding: 28px;
                    overflow-y: auto;
                    background: #f6fdf8;
                }
                #cutimg-panel #combinePreview {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
                    gap: 20px;
                    margin: 28px 0;
                }
                #cutimg-panel .combine-item {
                    text-align: center;
                    background: white;
                    padding: 16px;
                    border-radius: 14px;
                    box-shadow: 0 6px 16px rgba(0,0,0,0.08);
                }
                #cutimg-panel .combine-item img {
                    max-width: 100%;
                    max-height: 180px;
                    background: #f0f0f0;
                    border-radius: 12px;
                }
                #cutimg-panel #spriteCanvas {
                    max-width: 100%;
                    border-radius: 16px;
                    box-shadow: 0 12px 36px rgba(0,0,0,0.15);
                    background: #f0f0f0;
                    margin: 28px auto;
                    display: block;
                }
                #cutimg-panel #spriteSize {
                    text-align: center;
                    font-size: 20px;
                    margin-top: 14px;
                    font-weight: 500;
                    color: var(--green-main);
                }
                #cutimg-panel #close-btn {
                    background: #ff4444;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                }
            </style>
            <div style="position: relative;">
                <header>
                    <h1>è¯è¯´,å¤©ä¸‹é€æ˜å›¾ç‰‡</h1>
                </header>
                <button id="close-btn" onclick="CutImgSystem.hidePanel()" style="position: absolute; top: 15px; right: 15px; z-index: 10;">å…³é—­</button>
            </div>
            <div class="tabs">
                <div class="tab active" onclick="CutImgSystem.switchTab('split')">åˆä¹…å¿…åˆ†</div>
                <div class="tab" onclick="CutImgSystem.switchTab('combine')">åˆ†ä¹…å¿…åˆ</div>
            </div>
            <div class="controls" id="splitControls">
                <input type="file" id="fileInput" accept="image/*" multiple>
                <button class="btn" onclick="CutImgSystem.processImages()">ç¾¤é›„å‰²æ®</button>
                <div class="checkbox-container">
                    <input type="checkbox" id="selectAllCheckbox">
                    <label for="selectAllCheckbox">å…¨é€‰</label>
                </div>
                <button class="btn" onclick="CutImgSystem.downloadSelectedAsZip()" id="selectBatchBtn" disabled>æ‰“åŒ…é€‰ä¸­</button>
                <button class="btn" onclick="CutImgSystem.generateSpriteFromSplit()" id="splitUnifyBtn" disabled>ä¸€ç»Ÿå¤©ä¸‹</button>
                <button class="btn" onclick="CutImgSystem.downloadSpriteFromSplit()" id="splitDownloadSpriteBtn" disabled>ä¸‹è½½å…¨å®¶ç¦</button>
            </div>
            <div class="controls" id="combineControls" style="display:none;">
                <input type="file" id="combineFiles" accept="image/*" multiple>
                <button class="btn" onclick="CutImgSystem.generateSprite()">ä¸€ç»Ÿå¤©ä¸‹</button>
                <button class="btn" onclick="CutImgSystem.downloadSprite()" id="spriteDownloadBtn" disabled>ä¸‹è½½å…¨å®¶ç¦</button>
            </div>
            <div class="main">
                <div class="panel active" id="splitPanel">
                    <div class="split-left">
                        <div class="section">
                            <h2>åŸå›¾é‰´èµ</h2>
                            <div id="originalPreview" style="display:flex;flex-direction:column;gap:16px;overflow-y:auto;padding:10px;"></div>
                        </div>
                    </div>
                    <div class="split-right">
                        <div class="count-info" id="countInfo"></div>
                        <div id="preview"></div>
                        <div id="splitSpritePreview" style="display:none;margin-top:30px;">
                            <h3 style="text-align:center;color:var(--red-main);margin-bottom:20px;">å…¨å®¶ç¦é¢„è§ˆ</h3>
                            <canvas id="splitSpriteCanvas" style="max-width:100%;border-radius:16px;box-shadow:0 12px 36px rgba(0,0,0,0.15);background:#f0f0f0;margin:0 auto;display:block;"></canvas>
                            <p id="splitSpriteSize" style="text-align:center;font-size:20px;margin-top:14px;font-weight:500;color:var(--red-main);"></p>
                        </div>
                    </div>
                </div>
                <div class="panel" id="combinePanel">
                    <div class="combine-container">
                        <div id="combinePreview"></div>
                        <canvas id="spriteCanvas"></canvas>
                        <p id="spriteSize"></p>
                    </div>
                </div>
            </div>
        `;

        panel.appendChild(content);
        document.body.appendChild(panel);

        // åˆå§‹åŒ–å˜é‡
        this.splitPreviewDiv = document.getElementById('preview');
        this.allSplitComponents = [];
        this.originalImages = [];
        this.combineItems = [];
        this.FIXED_TOLERANCE = 98;
        this.MIN_AREA_FOR_NOISE = 50;
        this.PADDING = 25;
    },

    setupEventListeners() {
        // ç‚¹å‡»é¢æ¿å¤–é¢åŒºåŸŸå…³é—­é¢æ¿
        const panel = document.getElementById('cutimg-panel');
        panel.addEventListener('click', (e) => {
            if (e.target === panel) {
                this.hidePanel();
            }
        });

        // åˆ†å‰²æ–‡ä»¶é€‰æ‹©äº‹ä»¶
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            document.getElementById('countInfo').textContent = `å·²é€‰æ‹© ${files.length} ä¸ªæ–‡ä»¶ï¼Œç‚¹å‡»ç¾¤é›„å‰²æ®å¼€å§‹å¤„ç†`;
            
            // æ˜¾ç¤ºé€‰ä¸­çš„åŸå›¾
            this.originalImages = [];
            const originalPreview = document.getElementById('originalPreview');
            originalPreview.innerHTML = '';
            
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        this.originalImages.push(img);
                        
                        const imgContainer = document.createElement('div');
                        imgContainer.style.cssText = `
                            background: #f0f0f0;
                            border-radius: 12px;
                            padding: 10px;
                            text-align: center;
                            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                        `;
                        
                        const imgElement = document.createElement('img');
                        imgElement.src = img.src;
                        imgElement.style.cssText = `
                            max-width: 100%;
                            max-height: 150px;
                            border-radius: 8px;
                            object-fit: contain;
                        `;
                        
                        const fileName = document.createElement('p');
                        fileName.textContent = file.name;
                        fileName.style.cssText = `
                            margin: 8px 0 0 0;
                            font-size: 14px;
                            color: #555;
                            font-weight: 500;
                        `;
                        
                        imgContainer.appendChild(imgElement);
                        imgContainer.appendChild(fileName);
                        originalPreview.appendChild(imgContainer);
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        // åˆæˆæ–‡ä»¶é€‰æ‹©äº‹ä»¶
        document.getElementById('combineFiles').addEventListener('change', async (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            this.combineItems = [];
            document.getElementById('combinePreview').innerHTML = '';
            document.getElementById('spriteDownloadBtn').disabled = true;
            document.getElementById('spriteSize').textContent = '';

            for (let file of files) {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(r => img.onload = r);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tctx = tempCanvas.getContext('2d');
                tctx.drawImage(img, 0, 0);
                const data = tctx.getImageData(0, 0, img.width, img.height).data;

                let minX = img.width, maxX = 0, minY = img.height, maxY = 0;
                let hasPixel = false;
                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        if (data[(y * img.width + x) * 4 + 3] > 0) {
                            hasPixel = true;
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }

                const contentW = hasPixel ? maxX - minX + 1 : 1;
                const contentH = hasPixel ? maxY - minY + 1 : 1;

                const div = document.createElement('div');
                div.className = 'combine-item';
                div.innerHTML = `<img src="${img.src}"><p>${file.name}<br>æœ‰æ•ˆåŒºåŸŸ: ${contentW}Ã—${contentH}</p>`;
                document.getElementById('combinePreview').appendChild(div);

                this.combineItems.push({img, minX, minY, contentW, contentH, fileName: file.name});
            }
        });

        // å…¨é€‰åŠŸèƒ½
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        if (selectAllCheckbox) {
            selectAllCheckbox.addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('[id^="pack_"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
            });
        }
    },

    showPanel(mode = 'split') {
        document.getElementById('cutimg-panel').style.display = 'block';
        this.switchTab(mode);
    },

    hidePanel() {
        document.getElementById('cutimg-panel').style.display = 'none';
    },

    switchTab(mode) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        document.querySelectorAll('.controls').forEach(c => c.style.display = 'none');

        if (mode === 'split') {
            document.querySelector('.tab:nth-child(1)').classList.add('active');
            document.getElementById('splitPanel').classList.add('active');
            document.getElementById('splitControls').style.display = 'flex';
            document.body.className = 'split-mode';
            document.querySelector('#cutimg-panel header').style.background = 'var(--red-main)';
        } else if (mode === 'combine') {
            document.querySelector('.tab:nth-child(2)').classList.add('active');
            document.getElementById('combinePanel').classList.add('active');
            document.getElementById('combineControls').style.display = 'flex';
            document.body.className = 'combine-mode';
            document.querySelector('#cutimg-panel header').style.background = 'var(--green-main)';
        }
    },

    hasTransparentBgForSplit(img) {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const corners = [
            {x: 0, y: 0},
            {x: canvas.width - 1, y: 0},
            {x: 0, y: canvas.height - 1},
            {x: canvas.width - 1, y: canvas.height - 1}
        ];
        return corners.every(pos => data[(pos.y * canvas.width + pos.x) * 4 + 3] === 0);
    },

    autoRemoveBgForSplit(img, callback) {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;

        const corners = [
            {x: 0, y: 0},
            {x: canvas.width - 1, y: 0},
            {x: 0, y: canvas.height - 1},
            {x: canvas.width - 1, y: canvas.height - 1}
        ];

        const FIXED_TOLERANCE = this.FIXED_TOLERANCE;

        function floodFill(startX, startY) {
            const target = [data[(startY * canvas.width + startX) * 4], data[(startY * canvas.width + startX) * 4 + 1], data[(startY * canvas.width + startX) * 4 + 2]];
            if (data[(startY * canvas.width + startX) * 4 + 3] === 0) return;

            const stack = [{x: startX, y: startY}];
            const visited = new Uint8Array(canvas.width * canvas.height);

            while (stack.length) {
                const {x, y} = stack.pop();
                const idx = (y * canvas.width + x) * 4;
                if (visited[y * canvas.width + x]) continue;
                visited[y * canvas.width + x] = 1;

                const r = data[idx], g = data[idx+1], b = data[idx+2];
                if (Math.abs(r - target[0]) <= FIXED_TOLERANCE && Math.abs(g - target[1]) <= FIXED_TOLERANCE && Math.abs(b - target[2]) <= FIXED_TOLERANCE) {
                    data[idx + 3] = 0;
                    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                    for (const [dx, dy] of dirs) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height && !visited[ny * canvas.width + nx]) {
                            stack.push({x: nx, y: ny});
                        }
                    }
                }
            }
        }

        corners.forEach(pos => floodFill(pos.x, pos.y));
        ctx.putImageData(imageData, 0, 0);
        const resultImg = new Image();
        resultImg.src = canvas.toDataURL('image/png');
        resultImg.onload = () => callback(resultImg);
    },

    async processImages() {
        const files = document.getElementById('fileInput').files;
        if (files.length === 0) {
            alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
            return;
        }

        // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
        this.splitPreviewDiv.innerHTML = '';
        this.allSplitComponents = [];
        document.getElementById('selectBatchBtn').disabled = true;
        document.getElementById('splitUnifyBtn').disabled = true;
        document.getElementById('splitDownloadSpriteBtn').disabled = true;
        document.getElementById('splitSpritePreview').style.display = 'none';

        document.getElementById('countInfo').textContent = `æ­£åœ¨å¤„ç† ${files.length} ä¸ªæ–‡ä»¶...`;

        // å¤„ç†æ¯ä¸ªæ–‡ä»¶
        const processFile = (file) => {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        if (this.hasTransparentBgForSplit(img)) {
                            this.processSingleImage(img, file.name).then(resolve);
                        } else {
                            this.autoRemoveBgForSplit(img, (resultImg) => {
                                this.processSingleImage(resultImg, file.name).then(resolve);
                            });
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
        };

        // å¤„ç†æ‰€æœ‰æ–‡ä»¶
        const filePromises = Array.from(files).map(file => processFile(file));
        await Promise.all(filePromises);

        // æ›´æ–°ç•Œé¢
        if (this.allSplitComponents.length === 0) {
            this.splitPreviewDiv.innerHTML = '<p class="tip">æœªæ£€æµ‹åˆ°ä»»ä½•æœ‰æ•ˆåƒç´ </p>';
            document.getElementById('countInfo').textContent = 'å¤„ç†å®Œæˆï¼šæœªæ£€æµ‹åˆ°ä»»ä½•æœ‰æ•ˆåƒç´ ';
            return;
        }

        // è®¡ç®—æ¯ä¸ªç»„ä»¶çš„é¢ç§¯ï¼Œå¹¶æ ‡è®°æ˜æ˜¾å°äºå…¶ä»–çš„ç»„ä»¶
        this.allSplitComponents.forEach(bbox => {
            bbox.area = (bbox.maxX - bbox.minX + 1) * (bbox.maxY - bbox.minY + 1);
        });

        // è®¡ç®—å¹³å‡é¢ç§¯ï¼ˆæ’é™¤é¢ç§¯ä¸º0çš„ï¼‰
        const validComponents = this.allSplitComponents.filter(bbox => bbox.area > 0);
        const totalArea = validComponents.reduce((sum, bbox) => sum + bbox.area, 0);
        const avgArea = totalArea / validComponents.length;
        
        // è®¡ç®—ä¸­ä½æ•°é¢ç§¯ï¼ˆæ›´èƒ½åæ˜ å…¸å‹å€¼ï¼‰
        const sortedAreas = validComponents.map(bbox => bbox.area).sort((a, b) => a - b);
        const medianArea = sortedAreas[Math.floor(sortedAreas.length / 2)];
        
        // è®¾ç½®é˜ˆå€¼ï¼šé¢ç§¯å°äºä¸­ä½æ•°1/5çš„è‡ªåŠ¨å–æ¶ˆé€‰æ‹©
        const AUTO_UNCHECK_THRESHOLD = medianArea / 5;
        
        let autoUncheckedCount = 0;
        
        // æ˜¾ç¤ºæ‰€æœ‰åˆ†å‰²ç»“æœ
        this.allSplitComponents.forEach((bbox, i) => {
            // å†³å®šæ˜¯å¦è‡ªåŠ¨å–æ¶ˆé€‰æ‹©
            const shouldAutoUncheck = bbox.area < AUTO_UNCHECK_THRESHOLD;
            const initialChecked = !shouldAutoUncheck;
            if (shouldAutoUncheck) autoUncheckedCount++;
            
            const div = document.createElement('div');
            div.className = 'item';
            div.innerHTML = `
                <div class="preview-box"><canvas></canvas></div>
                <div class="info">
                     <input type="checkbox" id="pack_${i}" ${initialChecked ? 'checked' : ''}>
                    <label for="pack_${i}" <strong>${bbox.fileName}_è‹±é›„_${i + 1}</strong></label>
                    <br>
                    å®½ x é«˜ = ${bbox.maxX - bbox.minX + 1} Ã— ${bbox.maxY - bbox.minY + 1} px
                    ${shouldAutoUncheck ? '<br><span style="color:#ff6b6b;font-size:12px;">(è‡ªåŠ¨å–æ¶ˆï¼šé¢ç§¯è¿‡å°)</span>' : ''}
                </div>
            `;
            div.querySelector('.preview-box canvas').replaceWith(bbox.canvas);

            const btn = document.createElement('button');
            btn.textContent = 'å•ç‹¬ä¸‹è½½';
            btn.className = 'btn small';
            btn.onclick = (e) => {
                // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘é¢æ¿ç‚¹å‡»äº‹ä»¶
                e.stopPropagation();
                const a = document.createElement('a');
                a.href = bbox.canvas.toDataURL('image/png');
                a.download = `${bbox.fileName}_element_${i + 1}.png`;
                a.click();
            };
            div.appendChild(btn);

            // æ·»åŠ é¢æ¿ç‚¹å‡»äº‹ä»¶ï¼Œç‚¹å‡»é¢æ¿åˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
            div.addEventListener('click', (e) => {
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯æŒ‰é’®æˆ–å¤é€‰æ¡†æœ¬èº«ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¤„ç†
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                const checkbox = div.querySelector(`#pack_${i}`);
                checkbox.checked = !checkbox.checked;
                this.updateSelectAllStatus();
            });

            // ä¸ºå¤é€‰æ¡†æ·»åŠ changeäº‹ä»¶ç›‘å¬å™¨
            const checkbox = div.querySelector(`#pack_${i}`);
            checkbox.addEventListener('change', this.updateSelectAllStatus);

            this.splitPreviewDiv.appendChild(div);
        });

        let infoText = `å¤„ç†å®Œæˆï¼šå…±ä» ${files.length} ä¸ªæ–‡ä»¶ä¸­æå– ${this.allSplitComponents.length} ä¸ªç‹¬ç«‹å…ƒç´ `;
        if (autoUncheckedCount > 0) {
            infoText += `ï¼ˆè‡ªåŠ¨å–æ¶ˆ ${autoUncheckedCount} ä¸ªé¢ç§¯æ˜æ˜¾è¾ƒå°çš„å…ƒç´ é€‰æ‹©ï¼‰`;
        }
        document.getElementById('countInfo').textContent = infoText;

        document.getElementById('selectBatchBtn').disabled = false;
        document.getElementById('splitUnifyBtn').disabled = false;
        this.updateSelectAllStatus();
    },

    processSingleImage(img, fileName) {
        return new Promise((resolve) => {
            const w = img.width;
            const h = img.height;
            
            // åˆ›å»ºä¸´æ—¶canvasæ¥å¤„ç†å›¾ç‰‡
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);

            let imageData = tempCtx.getImageData(0, 0, w, h);
            let data = imageData.data;
            const visited = new Uint8Array(w * h);
            const temp = [];

            const isFg = (x, y) => data[(y * w + x) * 4 + 3] > 0;

            const bfs = (sx, sy) => {
                const q = [{x: sx, y: sy}];
                let minX = sx, maxX = sx, minY = sy, maxY = sy, area = 0;
                visited[sy * w + sx] = 1;
                const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

                while (q.length) {
                    const {x, y} = q.shift();
                    area++;
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                    for (const [dx, dy] of dirs) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h && !visited[ny * w + nx] && isFg(nx, ny)) {
                            visited[ny * w + nx] = 1;
                            q.push({x: nx, y: ny});
                        }
                    }
                }
                return {minX, maxX, minY, maxY, area};
            };

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (!visited[y * w + x] && isFg(x, y)) {
                        temp.push(bfs(x, y));
                    }
                }
            }

            const filtered = temp.filter(c => c.area > this.MIN_AREA_FOR_NOISE);
            
            // ä¸ºæ¯ä¸ªåˆ†å‰²ç»“æœåˆ›å»ºcanvas
            filtered.forEach(bbox => {
                const cropW = bbox.maxX - bbox.minX + 1 + this.PADDING * 2;
                const cropH = bbox.maxY - bbox.minY + 1 + this.PADDING * 2;
                const canvas = document.createElement('canvas');
                canvas.width = cropW;
                canvas.height = cropH;
                const cctx = canvas.getContext('2d');
                cctx.drawImage(img,
                    bbox.minX, bbox.minY,
                    bbox.maxX - bbox.minX + 1, bbox.maxY - bbox.minY + 1,
                    this.PADDING, this.PADDING,
                    bbox.maxX - bbox.minX + 1, bbox.maxY - bbox.minY + 1
                );
                
                bbox.canvas = canvas;
                bbox.fileName = fileName;
                this.allSplitComponents.push(bbox);
            });

            resolve();
        });
    },

    downloadSelectedAsZip() {
        const selected = [];
        this.allSplitComponents.forEach((c, i) => {
            if (document.getElementById(`pack_${i}`).checked) {
                selected.push({c, i});
            }
        });

        if (selected.length === 0) {
            alert('è‡³å°‘é€‰æ‹©ä¸€å¼ å›¾ç‰‡æ‰“åŒ…ï¼');
            return;
        }

        // ç”±äºä¸ä½¿ç”¨å¤–éƒ¨åº“ï¼Œæˆ‘ä»¬é€ä¸ªä¸‹è½½é€‰ä¸­çš„å›¾ç‰‡
        selected.forEach(({c, i}) => {
            const a = document.createElement('a');
            a.href = c.canvas.toDataURL('image/png');
            a.download = `${c.fileName}_element_${i + 1}.png`;
            a.click();
        });
    },

    async generateSpriteFromSplit() {
        const selected = [];
        this.allSplitComponents.forEach((c, i) => {
            if (document.getElementById(`pack_${i}`).checked) {
                selected.push({c, i});
            }
        });

        if (selected.length === 0) {
            alert('è‡³å°‘é€‰æ‹©ä¸€å¼ å›¾ç‰‡åˆæˆï¼');
            return;
        }

        const SPACING = 10;
        const MARGIN = 20;

        // åŠ è½½æ‰€æœ‰å›¾ç‰‡å¹¶ç¡®ä¿å®ƒä»¬å·²å®ŒæˆåŠ è½½
        const loadImage = (src) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = src;
            });
        };

        const combineItemsPromises = selected.map(async ({c, i}) => {
            const img = await loadImage(c.canvas.toDataURL('image/png'));
            return {
                img: img,
                minX: 0,
                minY: 0,
                contentW: c.canvas.width,
                contentH: c.canvas.height,
                fileName: `${c.fileName}_element_${i + 1}.png`
            };
        });

        const combineItemsFromSplit = await Promise.all(combineItemsPromises);

        combineItemsFromSplit.sort((a, b) => b.contentH * b.contentW - a.contentH * a.contentW);

        const totalArea = combineItemsFromSplit.reduce((sum, it) => sum + it.contentW * it.contentH, 0);
        const avgRatio = combineItemsFromSplit.reduce((sum, it) => sum + it.contentW / it.contentH, 0) / combineItemsFromSplit.length || 1;
        const idealWidth = Math.sqrt(totalArea * avgRatio) * 1.2;

        let rows = [];
        let remaining = [...combineItemsFromSplit];

        while (remaining.length > 0) {
            let row = [];
            let rowW = 0;
            let i = 0;
            while (i < remaining.length) {
                const item = remaining[i];
                const addedW = item.contentW + (row.length > 0 ? SPACING : 0);
                if (rowW + addedW > idealWidth && row.length > 0) break;
                row.push(item);
                rowW += addedW;
                i++;
            }
            if (row.length === 0 && remaining.length > 0) {
                row.push(remaining[0]);
                i = 1;
            }
            rows.push(row);
            remaining.splice(0, i);
        }

        let maxRowW = 0;
        let totalH = MARGIN * 2;
        for (let row of rows) {
            const rowH = Math.max(...row.map(it => it.contentH), 0);
            totalH += rowH + (totalH > MARGIN * 2 ? SPACING : 0);
            const rowW = row.reduce((sum, it, idx) => sum + it.contentW + (idx > 0 ? SPACING : 0), 0);
            maxRowW = Math.max(maxRowW, rowW);
        }
        const totalW = maxRowW + MARGIN * 2;

        // ä½¿ç”¨é¡µé¢ä¸Šçš„canvaså…ƒç´ æ˜¾ç¤ºé¢„è§ˆ
        const canvas = document.getElementById('splitSpriteCanvas');
        canvas.width = totalW;
        canvas.height = totalH;
        const sctx = canvas.getContext('2d');
        sctx.clearRect(0, 0, totalW, totalH);

        let y = MARGIN;
        for (let row of rows) {
            const rowH = Math.max(...row.map(it => it.contentH), 0);
            let x = MARGIN;
            for (let item of row) {
                sctx.drawImage(item.img,
                    item.minX, item.minY, item.contentW, item.contentH,
                    x, y + (rowH - item.contentH) / 2,
                    item.contentW, item.contentH
                );
                x += item.contentW + SPACING;
            }
            y += rowH + SPACING;
        }

        // æ›´æ–°é¢„è§ˆä¿¡æ¯
        document.getElementById('splitSpriteSize').textContent = `å…¨å®¶ç¦å°ºå¯¸ï¼š${canvas.width} Ã— ${canvas.height} åƒç´ `;
        document.getElementById('splitSpritePreview').style.display = 'block';
        
        // ä¿å­˜åˆæˆåçš„canvasä»¥ä¾¿ä¸‹è½½
        window.splitSpriteCanvas = canvas;
        document.getElementById('splitDownloadSpriteBtn').disabled = false;
    },

    downloadSpriteFromSplit() {
        if (!window.splitSpriteCanvas) {
            alert('è¯·å…ˆç‚¹å‡»ä¸€ç»Ÿå¤©ä¸‹ç”Ÿæˆåˆæˆå›¾ï¼');
            return;
        }
        const a = document.createElement('a');
        a.href = window.splitSpriteCanvas.toDataURL('image/png');
        a.download = 'sprite_sheet_from_split.png';
        a.click();
    },

    generateSprite() {
        if (this.combineItems.length === 0) return alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼');

        const SPACING = 10;
        const MARGIN = 20;

        this.combineItems.sort((a, b) => b.contentH * b.contentW - a.contentH * a.contentW);

        const totalArea = this.combineItems.reduce((sum, it) => sum + it.contentW * it.contentH, 0);
        const avgRatio = this.combineItems.reduce((sum, it) => sum + it.contentW / it.contentH, 0) / this.combineItems.length || 1;
        const idealWidth = Math.sqrt(totalArea * avgRatio) * 1.2;

        let rows = [];
        let remaining = [...this.combineItems];

        while (remaining.length > 0) {
            let row = [];
            let rowW = 0;
            let i = 0;
            while (i < remaining.length) {
                const item = remaining[i];
                const addedW = item.contentW + (row.length > 0 ? SPACING : 0);
                if (rowW + addedW > idealWidth && row.length > 0) break;
                row.push(item);
                rowW += addedW;
                i++;
            }
            if (row.length === 0 && remaining.length > 0) {
                row.push(remaining[0]);
                i = 1;
            }
            rows.push(row);
            remaining.splice(0, i);
        }

        let maxRowW = 0;
        let totalH = MARGIN * 2;
        for (let row of rows) {
            const rowH = Math.max(...row.map(it => it.contentH), 0);
            totalH += rowH + (totalH > MARGIN * 2 ? SPACING : 0);
            const rowW = row.reduce((sum, it, idx) => sum + it.contentW + (idx > 0 ? SPACING : 0), 0);
            maxRowW = Math.max(maxRowW, rowW);
        }
        const totalW = maxRowW + MARGIN * 2;

        const canvas = document.getElementById('spriteCanvas');
        canvas.width = totalW;
        canvas.height = totalH;
        const sctx = canvas.getContext('2d');
        sctx.clearRect(0, 0, totalW, totalH);

        let y = MARGIN;
        for (let row of rows) {
            const rowH = Math.max(...row.map(it => it.contentH), 0);
            let x = MARGIN;
            for (let item of row) {
                sctx.drawImage(item.img,
                    item.minX, item.minY, item.contentW, item.contentH,
                    x, y + (rowH - item.contentH) / 2,
                    item.contentW, item.contentH
                );
                x += item.contentW + SPACING;
            }
            y += rowH + SPACING;
        }

        document.getElementById('spriteSize').textContent = `ç²¾çµå›¾å°ºå¯¸ï¼š${canvas.width} Ã— ${canvas.height} åƒç´ `;
        document.getElementById('spriteDownloadBtn').disabled = false;
    },

    downloadSprite() {
        const canvas = document.getElementById('spriteCanvas');
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = 'sprite_sheet.png';
        a.click();
    },

    updateSelectAllStatus() {
        const checkboxes = document.querySelectorAll('[id^="pack_"]');
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        
        if (checkboxes.length === 0) {
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }
            return;
        }

        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        if (selectAllCheckbox) {
            selectAllCheckbox.checked = allChecked;
        }
    }
};

// åˆå§‹åŒ–
window.addEventListener('load', () => {
    CutImgSystem.init();
});


const ReadJS = {
    init() {
        this.setupDragAndDrop();
    },

    setupDragAndDrop() {
        const viewport = document.getElementById('viewport');
        
        // æ‹–æ‹½è¿›å…¥äº‹ä»¶
        viewport.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            viewport.classList.add('drag-over');
        });

        // æ‹–æ‹½ç¦»å¼€äº‹ä»¶
        viewport.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.target === viewport) {
                viewport.classList.remove('drag-over');
            }
        });

        // æ‹–æ‹½æ‚¬åœäº‹ä»¶
        viewport.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        // æ‹–æ‹½é‡Šæ”¾äº‹ä»¶
        viewport.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            viewport.classList.remove('drag-over');
            
            this.handleDrop(e);
        });
    },

    handleDrop(e) {
        const files = e.dataTransfer.files;
        
        for (const file of files) {
            if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
                this.readTxtFile(file, e.clientX, e.clientY);
            }
        }
    },

    readTxtFile(file, clientX, clientY) {
        const reader = new FileReader();
        
        reader.onload = (event) => {
            const content = event.target.result;
            this.createNodeFromTxt(content, clientX, clientY, file.name);
        };
        
        reader.onerror = (error) => {
            console.error('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
        };
        
        reader.readAsText(file, 'utf-8');
    },

    createNodeFromTxt(content, clientX, clientY, fileName) {
        // è®¡ç®—èŠ‚ç‚¹ä½ç½®
        const container = document.getElementById('container');
        const rect = container.getBoundingClientRect();
        const zoom = app.zoom;
        
        const mx = (clientX - rect.left) / zoom;
        const my = (clientY - rect.top) / zoom;
        
        const w = 380, h = 180;
        let pos = {
            x: mx - w / 2,
            y: my - h / 2
        };

        // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰èŠ‚ç‚¹é‡å 
        let overlap = false;
        for (const node of app.nodes) {
            if (this.isOverlap(pos.x, pos.y, w, h, node.x, node.y, node.w, node.h)) {
                overlap = true;
                break;
            }
        }

        // å¦‚æœé‡å ï¼Œä½¿ç”¨findNonOverlapPos
        if (overlap) {
            pos = app.findNonOverlapPos(w, h);
        }

        // åˆ›å»ºèŠ‚ç‚¹
        const newId = Date.now();
        const nodeName = fileName.replace('.txt', '');
        app.createNode(newId, pos.x, pos.y, w, h, nodeName, content);
        
        // æ’­æ”¾éŸ³æ•ˆ
        AudioSystem.playCreateSound();
        
        // æ˜¾ç¤ºç‰¹æ•ˆ
        if (typeof FXManager !== 'undefined') {
            FXManager.spawn(clientX, clientY, '#00ff00');
        }
        
        // ä¿å­˜çŠ¶æ€
        app.save();
        app.markMinimapDirty();
        app.updateMinimap();
        app.updateVisibleNodes();
    },

    isOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
    }
};

// å½“DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', function() {
        console.log('ReadJS: åˆå§‹åŒ–æ–‡ä»¶æ‹–æ‹½åŠŸèƒ½');
        ReadJS.init();
    });
}


</script>
</body>

</html>